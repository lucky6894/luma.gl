/*! For license information please see 643d9d1e.3a232c01.js.LICENSE.txt */
"use strict";(self.webpackChunkwebsite_docusaurus=self.webpackChunkwebsite_docusaurus||[]).push([[9633],{1208:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>d,contentTitle:()=>i,default:()=>l,frontMatter:()=>a,metadata:()=>o,toc:()=>c});var s=n(4848),t=n(8453);const a={},i="Transform",o={id:"api-reference/engine/transform",title:"Transform",description:"The Transform class provides easy interface to perform Transform Feedback operations on given data. Applications can use this class to move data processing from CPU to GPU, where multiple parallel execution units will be used for processing. Data is handled in form of Buffer objects, i.e. data resides in the GPU memory. Output of this class can directly set as attributes on Model or VertexArray for regular rendering operations, CPU access is not required hence avoids expensive CPU and GPU sync.",source:"@site/../docs/api-reference/engine/transform.md",sourceDirName:"api-reference/engine",slug:"/api-reference/engine/transform",permalink:"/docs/api-reference/engine/transform",draft:!1,unlisted:!1,editUrl:"https://github.com/visgl/luma.gl/tree/main/docs/../docs/api-reference/engine/transform.md",tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Computation",permalink:"/docs/api-reference/engine/computation"},next:{title:"BufferTransform",permalink:"/docs/api-reference/engine/transform/buffer-transform"}},d={},c=[{value:"Use case : Specify source and destination buffers.",id:"use-case--specify-source-and-destination-buffers",level:3},{value:"Use case : Create destination buffers automatically.",id:"use-case--create-destination-buffers-automatically",level:3},{value:"Use case : Multiple iterations using swap().",id:"use-case--multiple-iterations-using-swap",level:3},{value:"Use case : Update one or more buffers using update() method..",id:"use-case--update-one-or-more-buffers-using-update-method",level:3},{value:"Use case : Reading source data from texture object (Experimental)",id:"use-case--reading-source-data-from-texture-object-experimental",level:3},{value:"Use case : Generating a texture object (Experimental)",id:"use-case--generating-a-texture-object-experimental",level:3},{value:"Constructor",id:"constructor",level:2},{value:"Experimental",id:"experimental",level:4},{value:"delete() : Transform",id:"delete--transform",level:3},{value:"Methods",id:"methods",level:2},{value:"getBuffer(varyingName : String) : Buffer",id:"getbuffervaryingname--string--buffer",level:3},{value:"getData([options : Object]) : ArrayBufferView",id:"getdataoptions--object--arraybufferview",level:3},{value:"getFramebuffer() : Framebuffer",id:"getframebuffer--framebuffer",level:3},{value:"<code>run({uniforms : Object, unbindModels : Object}) : Transform</code>",id:"rununiforms--object-unbindmodels--object--transform",level:3},{value:"update(props) : Transform",id:"updateprops--transform",level:3},{value:"swap() : Transform",id:"swap--transform",level:3},{value:"_getTargetTexture() : Texture2D/null (EXPERIMENTAL)",id:"_gettargettexture--texture2dnull-experimental",level:3}];function u(e){const r={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.h1,{id:"transform",children:"Transform"}),"\n",(0,s.jsxs)(r.p,{children:["The ",(0,s.jsx)(r.code,{children:"Transform"})," class provides easy interface to perform Transform Feedback operations on given data. Applications can use this class to move data processing from CPU to GPU, where multiple parallel execution units will be used for processing. Data is handled in form of ",(0,s.jsx)(r.code,{children:"Buffer"})," objects, i.e. data resides in the GPU memory. Output of this class can directly set as attributes on ",(0,s.jsx)(r.code,{children:"Model"})," or ",(0,s.jsx)(r.code,{children:"VertexArray"})," for regular rendering operations, CPU access is not required hence avoids expensive CPU and GPU sync."]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.code,{children:"Transform"})," class creates and holds ",(0,s.jsx)(r.code,{children:"Model"})," and ",(0,s.jsx)(r.code,{children:"TransformFeedback"})," instances."]}),"\n",(0,s.jsx)(r.h3,{id:"use-case--specify-source-and-destination-buffers",children:"Use case : Specify source and destination buffers."}),"\n",(0,s.jsxs)(r.p,{children:["Create a ",(0,s.jsx)(r.code,{children:"Transform"})," object by passing, vs (vertex shader), source buffer(s), varyings (output variable names in vertex shader) and destination buffers. Then call ",(0,s.jsx)(r.code,{children:"run"})," to perform one transform feedback iteration."]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-typescript",children:"const VS = `\\\n#version 300 es\nattribute float inValue;\nvarying float outValue;\n\nvoid main()\n{\n  outValue = 2.0 * inValue;\n}\n`;\n\nconst sourceData = new Float32Array([10, 20, 31, 0, -57]);\nconst sourceBuffer = new Buffer(gl, {data: sourceData});\n\n// Default values applied for size (1) and type (gl.FLOAT)\nconst feedbackBuffer = new Buffer(gl, {byteLength: sourceData.length * 4});\n\nconst transform = new Transform(gl2, {\n  sourceBuffers: {\n    inValue: sourceBuffer\n  },\n  feedbackBuffers: {\n    outValue: feedbackBuffer\n  },\n  vs: VS,\n  varyings: ['outValue'],\n  elementCount: 5\n});\n\n// Perform one transform feedback iteration\ntransform.run();\n"})}),"\n",(0,s.jsx)(r.h3,{id:"use-case--create-destination-buffers-automatically",children:"Use case : Create destination buffers automatically."}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.code,{children:"Transform"})," can internally create destination buffers (i.e. feedback buffers), when ",(0,s.jsx)(r.code,{children:"feedbackMap"})," is provided. Each destination buffer is created with same settings and layout as corresponding source buffer as per ",(0,s.jsx)(r.code,{children:"feedbackMap"}),"."]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-typescript",children:"const transform = new Transform(gl2, {\n  sourceBuffers: {\n    inValue: sourceBuffer\n  },\n  feedbackMap: {\n    inValue: 'outValue'\n  },\n  vs: VS,\n  varyings: ['outValue'],\n  elementCount: 5\n});\n"})}),"\n",(0,s.jsx)(r.h3,{id:"use-case--multiple-iterations-using-swap",children:"Use case : Multiple iterations using swap()."}),"\n",(0,s.jsxs)(r.p,{children:["When ",(0,s.jsx)(r.code,{children:"feedbackMap"})," is specified buffers can be swapped using a single call to ",(0,s.jsx)(r.code,{children:"swap()"}),", this is useful for cases like particle simulation, where output of one transform feedback iteration is piped as input to the next iteration."]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-typescript",children:"// Setup Transform with `feedbackMap` as above\n\ntransform.run();\n\nlet bufferWithNewValues = transform.getBuffer('outValue');\n...\n// Render using 'bufferWithNewValues'\n...\n\n//swap buffers\ntransform.swap();\ntransform.run();\nbufferWithNewValues = transform.getBuffer('outValue');\n...\n// Render using 'bufferWithNewValues'\n...\n"})}),"\n",(0,s.jsx)(r.h3,{id:"use-case--update-one-or-more-buffers-using-update-method",children:"Use case : Update one or more buffers using update() method.."}),"\n",(0,s.jsxs)(r.p,{children:["Once ",(0,s.jsx)(r.code,{children:"Transform"})," object is constructed and used, one or more source or destination buffers can be updated using ",(0,s.jsx)(r.code,{children:"update"}),"."]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-typescript",children:"// transform is set up as above\n...\n\n// update buffer binding for 'inValue' attribute\nconst newSourceBuffer = new Buffer(gl, {data: newSourceData});\ntransform.update({\n  sourceBuffers: {\n    inValue: newSourceBuffer\n  }\n});\n\n// now data is provided from newly bound buffer.\ntransform.run();\n"})}),"\n",(0,s.jsx)(r.h3,{id:"use-case--reading-source-data-from-texture-object-experimental",children:"Use case : Reading source data from texture object (Experimental)"}),"\n",(0,s.jsx)(r.p,{children:"In addition to reading data from Buffer objects, Transform can read from texture objects. Transform allows to access texture data in the same way as buffer data and internally generates required texture co-ordinates and sample instructions."}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-typescript",children:"// simple shader that adds data from a buffer and texture to generate new buffer.\n\nconst vs = `\\\n#version 300 es\nin float inBuffer;\nin float inTexture;\nout float outBuffer;\n\nvoid main()\n{\n  outBuffer = inTexture + inBuffer;\n}`;\n\nconst sourceBuffer = new Buffer(...);\nconst sourceTexture = new Texture2D(...);\n\nconst transform = new Transform(gl2, {\n  sourceBuffers: {\n    inBuffer: sourceBuffer\n  },\n  // specify source texture object using input attribute name\n  _sourceTextures: {\n    inTexture: sourceTexture\n  },\n  vs,\n  feedbackMap: {\n    inBuffer: 'outBuffer'\n  },\n  elementCount\n});\n\ntransform.run();\n\n// resulting buffer contains sum of input buffer and texture data.\nconst outData = transform.getBuffer('outBuffer').getData();\n"})}),"\n",(0,s.jsx)(r.h3,{id:"use-case--generating-a-texture-object-experimental",children:"Use case : Generating a texture object (Experimental)"}),"\n",(0,s.jsx)(r.p,{children:"In addition to reading data from a texture object, Transform can generate texture object, by rendering data into it offline. Source data can be either buffer(s), texture(s) or any combination."}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-typescript",children:"const vs = `\\\n#version 300 es\nin vec4 inTexture;\nout vec4 outTexture;\n\nvoid main()\n{\n  outTexture = 2. *  inTexture;\n}\n`\nconst sourceTexture = new Texture2D(...);\nconst transform = new Transform(gl2, {\n  _sourceTextures: {\n    inTexture: sourceTexture\n  },\n  _targetTexture: 'inTexture',\n  _targetTextureVarying: 'outTexture',\n  vs,\n  elementCount\n});\n\ntransform.run();\n\nconst outTexture = transform._getTargetTexture();\n"})}),"\n",(0,s.jsx)(r.h2,{id:"constructor",children:"Constructor"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-ts",children:"### Transform(device: Device, props: Object)\n"})}),"\n",(0,s.jsxs)(r.p,{children:["Constructs a ",(0,s.jsx)(r.code,{children:"Transform"})," object. It then creates destination buffers if needed and binds the buffers to ",(0,s.jsx)(r.code,{children:"Model"})," and ",(0,s.jsx)(r.code,{children:"TransformFeedback"})," objects."]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"device"})," - context"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"props.sourceBuffers"})," (",(0,s.jsx)(r.code,{children:"Object"}),") - key and value pairs, where key is the name of vertex shader attribute and value is the corresponding ",(0,s.jsx)(r.code,{children:"Attribute"}),", ",(0,s.jsx)(r.code,{children:"Buffer"})," or attribute descriptor object."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"props.feedbackBuffers"})," (",(0,s.jsx)(r.code,{children:"Object"}),", Optional) - key and value pairs, where key is the name of vertex shader varying and value is the corresponding ",(0,s.jsx)(r.code,{children:"Buffer"})," object or buffer params object. If a buffer params object is specified, it will contain following fields, these can be used to capture data into the buffer a particular offset and size.","\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"buffer"}),"=(Buffer) - Buffer object to be bound."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"byteOffset"}),"=(Number, default: 0) - Byte offset that is used to start recording the data in the buffer."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"byteSize"}),"=(Number, default: remaining buffer size) - Size in bytes that is used for recording the data."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"props.vs"})," (",(0,s.jsx)(r.code,{children:"String"}),") - vertex shader string."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"props.modules"})," - shader modules to be applied."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"props.varyings"})," (",(0,s.jsx)(r.code,{children:"Array"}),") - Array of vertex shader varyings names. When not provided this can be deduced from ",(0,s.jsx)(r.code,{children:"feedbackMap"}),". Either ",(0,s.jsx)(r.code,{children:"varyings"})," or ",(0,s.jsx)(r.code,{children:"feedbackMap"})," must be provided."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"props.feedbackMap"})," (",(0,s.jsx)(r.code,{children:"Object"}),", Optional) - key and value pairs, where key is a vertex shader attribute name and value is a vertex shader varying name."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"props.drawMode"})," (",(0,s.jsx)(r.code,{children:"GLEnum"})," = gl.POINTS, Optional) - Draw mode to be set on ",(0,s.jsx)(r.code,{children:"Model"})," and ",(0,s.jsx)(r.code,{children:"TransformFeedback"})," objects during draw/render time."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"props.elementCount"})," (",(0,s.jsx)(r.code,{children:"Integer"}),") - Number set to vertex count when rendering the model."]}),"\n"]}),"\n",(0,s.jsx)(r.h4,{id:"experimental",children:"Experimental"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"props._sourceTextures"})," (",(0,s.jsx)(r.code,{children:"Object"}),") - key and value pairs, where key is the name of vertex shader attribute and value is the corresponding ",(0,s.jsx)(r.code,{children:"Texture2D"})," object."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"props._targetTexture"})," (",(0,s.jsx)(r.code,{children:"Texture2D"})," or ",(0,s.jsx)(r.code,{children:"String"}),") - Defines texture object that is used as color attachment for rendering. If ",(0,s.jsx)(r.code,{children:"Texture2D"})," object, it is used as is, if ",(0,s.jsx)(r.code,{children:"String"}),", it must be one of the source texture attributes name, a new texture object is cloned from corresponding texture and used as color attachment."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"props._targetTextureVarying"})," (",(0,s.jsx)(r.code,{children:"String"}),") : varying name used in vertex shader who's data should go into target texture."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"props._swapTexture"})," (",(0,s.jsx)(r.code,{children:"String"}),") : source texture attribute name, that is swapped with target texture every time ",(0,s.jsx)(r.code,{children:"swap()"})," is called."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"props._fs"})," (",(0,s.jsx)(r.code,{children:"String"}),", Optional) - fragment shader string, when rendering to a texture, fragments can be processed using this custom shader, when not specified, pass through fragment shader will be used."]}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"Notes:"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["Internally, creates ",(0,s.jsx)(r.code,{children:"Model"}),", ",(0,s.jsx)(r.code,{children:"TransformFeedback"})," and ",(0,s.jsx)(r.code,{children:"Framebuffer"})," instances."]}),"\n"]}),"\n",(0,s.jsx)(r.h3,{id:"delete--transform",children:"delete() : Transform"}),"\n",(0,s.jsxs)(r.p,{children:["Deletes all owned resources, ",(0,s.jsx)(r.code,{children:"Model"}),", ",(0,s.jsx)(r.code,{children:"TransformFeedback"})," and any ",(0,s.jsx)(r.code,{children:"Buffer"})," objects that are crated internally."]}),"\n",(0,s.jsx)(r.h2,{id:"methods",children:"Methods"}),"\n",(0,s.jsx)(r.h3,{id:"getbuffervaryingname--string--buffer",children:"getBuffer(varyingName : String) : Buffer"}),"\n",(0,s.jsx)(r.p,{children:"Returns current destination buffer corresponding to given varying name."}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"varyingName"})," (",(0,s.jsx)(r.code,{children:"String"}),") - varying name."]}),"\n"]}),"\n",(0,s.jsx)(r.h3,{id:"getdataoptions--object--arraybufferview",children:"getData([options : Object]) : ArrayBufferView"}),"\n",(0,s.jsx)(r.p,{children:"Reads and returns data from current destination buffer corresponding to the given varying name. When no 'varyingName' is provided, it reads and returns data from current target texture."}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"options.varyingName"})," (",(0,s.jsx)(r.code,{children:"String"}),", Optional) - when specified, first checks if there is a corresponding feedback buffer, if so reads data from this buffer and returns. When not specified, there must be target texture and data is read from this texture and returned."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"options.packed"})," (Boolean, Optional, Default: false) - applicable only when reading data from target texture, when true, data is packed to the actual size varyings. When false return array contains 4 values (R, G, B and A) for each element. Un-used element value will be 0 for R, G and B and 1 for A channel."]}),"\n"]}),"\n",(0,s.jsx)(r.h3,{id:"getframebuffer--framebuffer",children:"getFramebuffer() : Framebuffer"}),"\n",(0,s.jsxs)(r.p,{children:["When rendering to a texture, i.e. ",(0,s.jsx)(r.code,{children:"_targetTexture"})," is set, ",(0,s.jsx)(r.code,{children:"Transform"})," class internally setups a ",(0,s.jsx)(r.code,{children:"Framebuffer"})," object. ",(0,s.jsx)(r.code,{children:"getFramebuffer()"})," returns this ",(0,s.jsx)(r.code,{children:"Framebuffer"})," object."]}),"\n",(0,s.jsx)(r.h3,{id:"rununiforms--object-unbindmodels--object--transform",children:(0,s.jsx)(r.code,{children:"run({uniforms : Object, unbindModels : Object}) : Transform"})}),"\n",(0,s.jsx)(r.p,{children:"Performs one transform feedback iteration."}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"uniforms"}),"=",(0,s.jsx)(r.code,{children:"null"})," (",(0,s.jsx)(r.code,{children:"Object"})," = ",", Optional) - Sets uniforms before rendering."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"unbindModels"}),"=",(0,s.jsx)(r.code,{children:"[]"})," (Model[]) - Array of models whose VertexAttributes will be temporarily unbound during the transform feedback to avoid triggering a possible ",(0,s.jsx)(r.a,{href:"https://github.com/KhronosGroup/WebGL/issues/2346",children:"Khronos/Chrome bug"}),"."]}),"\n"]}),"\n",(0,s.jsx)(r.h3,{id:"updateprops--transform",children:"update(props) : Transform"}),"\n",(0,s.jsx)(r.p,{children:"Updates buffer bindings with provided buffer objects for one or more source or destination buffers."}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"props.sourceBuffers"})," (",(0,s.jsx)(r.code,{children:"Object"}),") - key and value pairs, where key is the name of vertex shader attribute and value is the corresponding ",(0,s.jsx)(r.code,{children:"Attribute"}),", ",(0,s.jsx)(r.code,{children:"Buffer"})," or attribute descriptor object."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"props.feedbackBuffers"})," (",(0,s.jsx)(r.code,{children:"Object"}),", Optional) - key and value pairs, where key is the name of vertex shader varying and value is the corresponding ",(0,s.jsx)(r.code,{children:"Buffer"})," object."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"props.elementCount"})," (",(0,s.jsx)(r.code,{children:"Integer"}),", Optional) - Number set to vertex count when rendering the model. If not supplied, the previously set element count is used."]}),"\n"]}),"\n",(0,s.jsx)(r.h3,{id:"swap--transform",children:"swap() : Transform"}),"\n",(0,s.jsxs)(r.p,{children:["Swaps source and destination buffers and textures. Buffer swapping is performed when ",(0,s.jsx)(r.code,{children:"feedbackMap"})," is provided and texture swapping is performed when ",(0,s.jsx)(r.code,{children:"_swapTexture"})," is provided. If buffer swapping is needed, ",(0,s.jsx)(r.code,{children:"sourceBuffers"})," and ",(0,s.jsx)(r.code,{children:"feedbackBuffers"})," supplied to the constructor and/or the ",(0,s.jsx)(r.code,{children:"update"})," method must be ",(0,s.jsx)(r.code,{children:"Buffer"})," objects."]}),"\n",(0,s.jsx)(r.h3,{id:"_gettargettexture--texture2dnull-experimental",children:"_getTargetTexture() : Texture2D/null (EXPERIMENTAL)"}),"\n",(0,s.jsx)(r.p,{children:"When transform is setup to render to a texture, returns current target texture, otherwise null."})]})}function l(e={}){const{wrapper:r}={...(0,t.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},1020:(e,r,n)=>{var s=n(6540),t=Symbol.for("react.element"),a=Symbol.for("react.fragment"),i=Object.prototype.hasOwnProperty,o=s.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,d={key:!0,ref:!0,__self:!0,__source:!0};function c(e,r,n){var s,a={},c=null,u=null;for(s in void 0!==n&&(c=""+n),void 0!==r.key&&(c=""+r.key),void 0!==r.ref&&(u=r.ref),r)i.call(r,s)&&!d.hasOwnProperty(s)&&(a[s]=r[s]);if(e&&e.defaultProps)for(s in r=e.defaultProps)void 0===a[s]&&(a[s]=r[s]);return{$$typeof:t,type:e,key:c,ref:u,props:a,_owner:o.current}}r.Fragment=a,r.jsx=c,r.jsxs=c},4848:(e,r,n)=>{e.exports=n(1020)},8453:(e,r,n)=>{n.d(r,{R:()=>i,x:()=>o});var s=n(6540);const t={},a=s.createContext(t);function i(e){const r=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function o(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),s.createElement(a.Provider,{value:r},e.children)}}}]);