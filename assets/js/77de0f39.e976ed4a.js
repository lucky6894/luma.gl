/*! For license information please see 77de0f39.e976ed4a.js.LICENSE.txt */
"use strict";(self.webpackChunkwebsite_docusaurus=self.webpackChunkwebsite_docusaurus||[]).push([[6954],{3155:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>i,default:()=>h,frontMatter:()=>c,metadata:()=>r,toc:()=>o});var t=s(4848),a=s(8453);const c={},i="CanvasContext",r={id:"api-reference/core/canvas-context",title:"CanvasContext",description:"A CanvasContext holds a connection between a GPU Device and canvas, (either an HTML ` element, aka HTMLCanvasELement, or an OffscreenCanvas`).",source:"@site/../docs/api-reference/core/canvas-context.md",sourceDirName:"api-reference/core",slug:"/api-reference/core/canvas-context",permalink:"/docs/api-reference/core/canvas-context",draft:!1,unlisted:!1,editUrl:"https://github.com/visgl/luma.gl/tree/main/docs/../docs/api-reference/core/canvas-context.md",tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"DeviceLimits",permalink:"/docs/api-reference/core/device-limits"},next:{title:"GPU Parameters",permalink:"/docs/api-reference/core/parameters"}},d={},o=[{value:"Usage",id:"usage",level:2},{value:"Types",id:"types",level:2},{value:"<code>CanvasContextProps</code>",id:"canvascontextprops",level:3},{value:"Static Fields",id:"static-fields",level:2},{value:"<code>CanvasContext.isPageLoaded: boolean</code>",id:"canvascontextispageloaded-boolean",level:3},{value:"<code>CanvasContext.pageLoaded: Promise&lt;void&gt;</code>",id:"canvascontextpageloaded-promisevoid",level:3},{value:"Fields",id:"fields",level:2},{value:"<code>canvas: HMTLCanvas | OffscreenCanvas</code>",id:"canvas-hmtlcanvas--offscreencanvas",level:3},{value:"<code>useDevicePixels: boolean | number</code>",id:"usedevicepixels-boolean--number",level:3},{value:"Methods",id:"methods",level:2},{value:"constructor",id:"constructor",level:3},{value:"getCurrentFramebuffer(): Framebuffer",id:"getcurrentframebuffer-framebuffer",level:3},{value:"<code>getDevicePixelResolution(): [number, number]</code>",id:"getdevicepixelresolution-number-number",level:3},{value:"<code>getPixelSize(): [number, number]</code>",id:"getpixelsize-number-number",level:3},{value:"<code>resize(): void</code>",id:"resize-void",level:3}];function l(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"canvascontext",children:"CanvasContext"}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.code,{children:"CanvasContext"})," holds a connection between a GPU ",(0,t.jsx)(n.code,{children:"Device"})," and canvas, (either an HTML ",(0,t.jsx)(n.code,{children:"<canvas />"})," element, aka ",(0,t.jsx)(n.code,{children:"HTMLCanvasELement"}),", or an ",(0,t.jsx)(n.code,{children:"OffscreenCanvas"}),")."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["A ",(0,t.jsx)(n.code,{children:"CanvasContext"})," enables the application to render into the associated canvas, by acting as a source of ",(0,t.jsx)(n.code,{children:"Framebuffer"}),"s with special ",(0,t.jsx)(n.code,{children:"Texture"})," color attachments that are copied to the screen at the end of a ",(0,t.jsx)(n.code,{children:"RenderPass"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["It handles canvas resizing, making sure the returned ",(0,t.jsx)(n.code,{children:"Framebuffer"}),"s correspond to the current size of the canvas."]}),"\n",(0,t.jsx)(n.li,{children:"It also provides support for device pixel ratios (mapping between device pixels and CSS pixels)"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,t.jsxs)(n.p,{children:["The luma.gl API is designed to allow a ",(0,t.jsx)(n.code,{children:"Device"})," to create multiple associated ",(0,t.jsx)(n.code,{children:"CanvasContext"}),"s (or none, if only used for compute)."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"const device = await luma.createDevice(...);\nconst canvasContext1 = device.createCanvasContext(...);\nconst canvasContext2 = device.createCanvasContext(...);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["However this is only supported on WebGPU. A WebGL ",(0,t.jsx)(n.code,{children:"Device"})," always has exactly one ",(0,t.jsx)(n.code,{children:"CanvasContext"})," that must be created when the device is created, and a WebGL device can only render into that single canvas. (This is a fundamental limitation of the WebGL API, outside of luma.gl's control)."]}),"\n",(0,t.jsxs)(n.p,{children:["Because of this, the ",(0,t.jsx)(n.code,{children:"Device"})," class provides a ",(0,t.jsx)(n.code,{children:"DeviceProps.createCanvasContext"})," property that creates a default ",(0,t.jsx)(n.code,{children:"CanvasContext"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"const device = await luma.createDevice({createCanvasContext: true});\nconst canvasContext = device.getDefaultCanvasContext()\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The application can also provide properties for the default ",(0,t.jsx)(n.code,{children:"CanvasContext"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"const device = await luma.createDevice({createCanvasContext: {width, height}}); // Creates a new HTML canvas and adds it to document.body.\nconst canvasContext = device.getDefaultCanvasContext()\n"})}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.code,{children:"CanvasContext"})," can be associated with an existing canvas:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"const device = await luma.createDevice({createCanvasContext: {canvas: document.getElementById('canvas-id')}}); // Creates a new HTML canvas and adds it to document.body.\nconst canvasContext = device.getDefaultCanvasContext()\n"})}),"\n",(0,t.jsx)(n.p,{children:"Use a device's default canvas context to render into the associated canvas"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const renderPass = device.beginRenderPass({});\n"})}),"\n",(0,t.jsx)(n.p,{children:"This is equivalent to"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"const renderPass = device.beginRenderPass({\n  framebuffer: device.getDefaultCanvasContext().getFramebuffer()\n});\n"})}),"\n",(0,t.jsx)(n.p,{children:"Rendering into  additional canvas contexts (WebGPU only):"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const newCanvasContext = device.createCanvasContext({canvas: ...});\nconst renderPass = device.beginRenderPass({\n  framebuffer: newCanvasContext.getFramebuffer()\n});\n"})}),"\n",(0,t.jsxs)(n.p,{children:['On high-DPI screens, the number of pixels in a canvas can be a multiple of the "CSS size" reported by HTMLCanvasElement. Because of this, luma.gl allows the resolution of the textures returned by ',(0,t.jsx)(n.code,{children:"canvasContext.getFramebuffer"})," to be controlled. The ",(0,t.jsx)(n.code,{children:"CanvasContextProps.useDevicePixels"})," prop if set to ",(0,t.jsx)(n.code,{children:"true"}),", multiples the canvas HTML size with the system device pixel ratio. This prop can also a custom ratio (",(0,t.jsx)(n.code,{children:"number"}),"), as well. This allows setting the target texture size to higher or lower resolutions that indicated by an HMTLCanvasElements CSS width and height, to ensure that screen renderings use the maximum resolution of the device (at the cost of using more GPU memory)."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const newCanvasContext = device.createCanvasContext({canvas: ..., useDevicePixels: true});\n"})}),"\n",(0,t.jsx)(n.p,{children:"Mote that when using high value (usually more than device pixel ratio), it is possible it can get clamped down outside of luma.gl's control due to system memory limitation, in such cases a warning will be logged to the browser console."}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"CanvasContext"})," also provides methods for converting between device and CSS pixels, e.g"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"canvasContext.getDevicePixelResolution()\n"})}),"\n",(0,t.jsx)(n.h2,{id:"types",children:"Types"}),"\n",(0,t.jsx)(n.h3,{id:"canvascontextprops",children:(0,t.jsx)(n.code,{children:"CanvasContextProps"})}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Property"}),(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"width?"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"number"})}),(0,t.jsxs)(n.td,{children:["Width in pixels of the canvas (if ",(0,t.jsx)(n.code,{children:"canvas"})," is not supplied)"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"height?"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"number"})}),(0,t.jsxs)(n.td,{children:["Height in pixels of the canvas (if ",(0,t.jsx)(n.code,{children:"canvas"})," is not supplied)"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"canvas?"})}),(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"HTMLCanvasElement"})," | ",(0,t.jsx)(n.code,{children:"OffscreenCanvas"})," | ",(0,t.jsx)(n.code,{children:"string"})]}),(0,t.jsx)(n.td,{children:"A new canvas will be created if not supplied."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"container?"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"HTMLElement"})}),(0,t.jsxs)(n.td,{children:["Parent DOM element for new canvas. Defaults to first child of ",(0,t.jsx)(n.code,{children:"document.body"})]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"useDevicePixels?"})}),(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"boolean"})," | ",(0,t.jsx)(n.code,{children:"number"})]}),(0,t.jsxs)(n.td,{children:["Device pixels scale factor (",(0,t.jsx)(n.code,{children:"true"})," uses browser DPI)"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"autoResize?"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"boolean"})}),(0,t.jsx)(n.td,{children:"Whether to track resizes"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"visible?"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"boolean"})}),(0,t.jsx)(n.td,{children:"Visibility (only used if new canvas is created)."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"alphaMode?: string"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"'opaque'"})}),(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"'opaque' | 'premultiplied'"}),". See ",(0,t.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/GPUCanvasContext/configure#alphamode",children:"alphaMode"}),"."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"colorSpace?: 'string"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"'srgb'"})}),(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"'srgb' | 'display-p3'"}),". See ",(0,t.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/GPUCanvasContext/configure#colorspace",children:"colorSpace"}),"."]})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"static-fields",children:"Static Fields"}),"\n",(0,t.jsx)(n.h3,{id:"canvascontextispageloaded-boolean",children:(0,t.jsx)(n.code,{children:"CanvasContext.isPageLoaded: boolean"})}),"\n",(0,t.jsx)(n.p,{children:"A boolean that indicates if the web page has been loaded. This is sometimes useful as a canvas element specified in the page HTML will not be available until the page has loaded."}),"\n",(0,t.jsx)(n.h3,{id:"canvascontextpageloaded-promisevoid",children:(0,t.jsx)(n.code,{children:"CanvasContext.pageLoaded: Promise<void>"})}),"\n",(0,t.jsx)(n.p,{children:"A promise that resolves when the page is loaded."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"  await CanvasContex.isPageLoaded;\n  const canvas = document.getElementById('canvas');\n"})}),"\n",(0,t.jsx)(n.h2,{id:"fields",children:"Fields"}),"\n",(0,t.jsx)(n.h3,{id:"canvas-hmtlcanvas--offscreencanvas",children:(0,t.jsx)(n.code,{children:"canvas: HMTLCanvas | OffscreenCanvas"})}),"\n",(0,t.jsx)(n.h3,{id:"usedevicepixels-boolean--number",children:(0,t.jsx)(n.code,{children:"useDevicePixels: boolean | number"})}),"\n",(0,t.jsx)(n.p,{children:"Whether the framebuffer backing this canvas context is sized using device pixels."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"false"})," - Framebuffer is sized according to CSS pixel size."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"true"})," - Framebuffer is sized according to the device pixel ratio reported by the browser."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"number"})," - Framebuffer is sized according to the provided ratio."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"methods",children:"Methods"}),"\n",(0,t.jsx)(n.h3,{id:"constructor",children:"constructor"}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.code,{children:"CanvasContext"})," should not be constructed directly. Default canvas contexts are created when instantiating a ",(0,t.jsx)(n.code,{children:"WebGPUDevice"})," or a ",(0,t.jsx)(n.code,{children:"WebGLDevice"})," by supplying the ",(0,t.jsx)(n.code,{children:"canvasContext"})," property, and can be accessed through the ",(0,t.jsx)(n.code,{children:"device.canvasContext"})," field.  Additional canvas contexts can be explicitly created through ",(0,t.jsx)(n.code,{children:"WebGPUDevice.createCanvasContext(...)"}),"."]})}),"\n",(0,t.jsxs)(n.p,{children:["On ",(0,t.jsx)(n.code,{children:"Device"})," instances that support it (see ",(0,t.jsx)(n.a,{href:"#remarks",children:"remarks"})," below) additional canvas contexts are created using ",(0,t.jsx)(n.code,{children:"device.createCanvasContext()"}),". Depending on options passed, this either:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"creates a new canvas element with the specified properties,"}),"\n",(0,t.jsx)(n.li,{children:"or attaches the context to an existing canvas element"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"getcurrentframebuffer-framebuffer",children:"getCurrentFramebuffer(): Framebuffer"}),"\n",(0,t.jsxs)(n.p,{children:["Returns a framebuffer with properly resized current 'swap chain' textures. Rendering to this framebuffer will update the canvas associated with that ",(0,t.jsx)(n.code,{children:"CanvasContext"}),". Note that a new ",(0,t.jsx)(n.code,{children:"Framebuffer"})," must be requested on every redraw cycle."]}),"\n",(0,t.jsx)(n.h3,{id:"getdevicepixelresolution-number-number",children:(0,t.jsx)(n.code,{children:"getDevicePixelResolution(): [number, number]"})}),"\n",(0,t.jsx)(n.p,{children:"TBA"}),"\n",(0,t.jsx)(n.h3,{id:"getpixelsize-number-number",children:(0,t.jsx)(n.code,{children:"getPixelSize(): [number, number]"})}),"\n",(0,t.jsx)(n.p,{children:"Returns the size in pixels required to cover the canvas at the current device pixel resolution."}),"\n",(0,t.jsx)(n.h3,{id:"resize-void",children:(0,t.jsx)(n.code,{children:"resize(): void"})}),"\n",(0,t.jsx)(n.p,{children:"Resize the drawing surface. Usually called after the window has been resized. Note that automatic resizing is performed as size changes to the underlying canvas object are detected."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"canvasContext.resize(options: {width: number, height: number; userDevicePixels})\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"width"}),": New drawing surface width."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"height"}),": New drawing surface height."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"useDevicePixels"}),": Whether to scale the drawing surface using the device pixel ratio."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},1020:(e,n,s)=>{var t=s(6540),a=Symbol.for("react.element"),c=Symbol.for("react.fragment"),i=Object.prototype.hasOwnProperty,r=t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,d={key:!0,ref:!0,__self:!0,__source:!0};function o(e,n,s){var t,c={},o=null,l=null;for(t in void 0!==s&&(o=""+s),void 0!==n.key&&(o=""+n.key),void 0!==n.ref&&(l=n.ref),n)i.call(n,t)&&!d.hasOwnProperty(t)&&(c[t]=n[t]);if(e&&e.defaultProps)for(t in n=e.defaultProps)void 0===c[t]&&(c[t]=n[t]);return{$$typeof:a,type:e,key:o,ref:l,props:c,_owner:r.current}}n.Fragment=c,n.jsx=o,n.jsxs=o},4848:(e,n,s)=>{e.exports=s(1020)},8453:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>r});var t=s(6540);const a={},c=t.createContext(a);function i(e){const n=t.useContext(c);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),t.createElement(c.Provider,{value:n},e.children)}}}]);