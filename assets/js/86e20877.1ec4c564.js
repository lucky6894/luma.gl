/*! For license information please see 86e20877.1ec4c564.js.LICENSE.txt */
"use strict";(self.webpackChunkwebsite_docusaurus=self.webpackChunkwebsite_docusaurus||[]).push([[858],{9647:(e,t,n)=>{n.d(t,{M:()=>l,P:()=>a});var i=n(8862);const r={f32:["f32",1],"vec2<f32>":["f32",2],"vec3<f32>":["f32",3],"vec4<f32>":["f32",4],f16:["f16",1],"vec2<f16>":["f16",2],"vec3<f16>":["f16",3],"vec4<f16>":["f16",4],i32:["i32",1],"vec2<i32>":["i32",2],"vec3<i32>":["i32",3],"vec4<i32>":["i32",4],u32:["u32",1],"vec2<u32>":["u32",2],"vec3<u32>":["u32",3],"vec4<u32>":["u32",4]},o={f32:4,f16:2,i32:4,u32:4};var s=n(8337);function a(e,t){const n={};for(const i of e.attributes){const r=c(e,t,i.name);r&&(n[i.name]=r)}return n}function l(e,t,n){void 0===n&&(n=16);const i=a(e,t),r=new Array(n).fill(null);for(const o of Object.values(i))r[o.location]=o;return r}function c(e,t,n){const a=function(e,t){const n=e.attributes.find((e=>e.name===t));n||i.R.warn(`shader layout attribute "${t}" not present in shader`);return n||null}(e,n),l=function(e,t){u(e);let n=function(e,t){for(const n of e)if(n.format&&n.name===t)return{attributeName:n.name,bufferName:t,stepMode:n.stepMode,vertexFormat:n.format,byteOffset:0,byteStride:n.byteStride||0};return null}(e,t);if(n)return n;if(n=function(e,t){for(const n of e){let e=n.byteStride;if("number"!=typeof n.byteStride)for(const t of n.attributes||[]){e+=(0,s.w)(t.format).byteLength}const i=n.attributes?.find((e=>e.attribute===t));if(i)return{attributeName:i.attribute,bufferName:n.name,stepMode:n.stepMode,vertexFormat:i.format,byteOffset:i.byteOffset,byteStride:e}}return null}(e,t),n)return n;return i.R.warn(`layout for attribute "${t}" not present in buffer layout`),null}(t,n);if(!a)return null;const c=function(e){const[t,n]=r[e],i="i32"===t||"u32"===t,s="u32"!==t,a=o[t]*n,l=function(e,t){let n;switch(e){case"f32":n="float32";break;case"i32":n="sint32";break;case"u32":n="uint32";break;case"f16":return t<=2?"float16x2":"float16x4"}return 1===t?n:`${n}x${t}`}(t,n);return{dataType:t,components:n,defaultVertexFormat:l,byteLength:a,integer:i,signed:s}}(a.type),d=l?.vertexFormat||c.defaultVertexFormat,f=(0,s.w)(d);return{attributeName:l?.attributeName||a.name,bufferName:l?.bufferName||a.name,location:a.location,shaderType:a.type,shaderDataType:c.dataType,shaderComponents:c.components,vertexFormat:d,bufferDataType:f.type,bufferComponents:f.components,normalized:f.normalized,integer:c.integer,stepMode:l?.stepMode||a.stepMode||"vertex",byteOffset:l?.byteOffset||0,byteStride:l?.byteStride||0}}function u(e){for(const t of e)(t.attributes&&t.format||!t.attributes&&!t.format)&&i.R.warn(`BufferLayout ${name} must have either 'attributes' or 'format' field`)}},8564:(e,t,n)=>{n.d(t,{h:()=>r});var i=n(8314);class r extends i.F{static defaultProps={...i.F.defaultProps,usage:0,byteLength:0,byteOffset:0,data:null,indexType:"uint16",mappedAtCreation:!1};static MAP_READ=1;static MAP_WRITE=2;static COPY_SRC=4;static COPY_DST=8;static INDEX=16;static VERTEX=32;static UNIFORM=64;static STORAGE=128;static INDIRECT=256;static QUERY_RESOLVE=512;get[Symbol.toStringTag](){return"Buffer"}constructor(e,t){const n={...t};(t.usage||0)&r.INDEX&&!t.indexType&&(t.data instanceof Uint32Array?n.indexType="uint32":t.data instanceof Uint16Array&&(n.indexType="uint16")),delete n.data,super(e,n,r.defaultProps),this.usage=n.usage||0,this.indexType=n.indexType,this.updateTimestamp=e.incrementTimestamp()}clone(e){return this.device.createBuffer({...this.props,...e})}readSyncWebGL(e,t){throw new Error("not implemented")}static DEBUG_DATA_MAX_LENGTH=32;debugData=(()=>new ArrayBuffer(0))();_setDebugData(e,t,n){const i=ArrayBuffer.isView(e)?e.buffer:e,o=Math.min(e?e.byteLength:n,r.DEBUG_DATA_MAX_LENGTH);null===i?this.debugData=new ArrayBuffer(o):0===t&&n===i.byteLength?this.debugData=i.slice(0,o):this.debugData=i.slice(t,t+o)}}},5128:(e,t,n)=>{n.d(t,{C:()=>r});var i=n(8314);class r extends i.F{static defaultProps=(()=>({...i.F.defaultProps,shader:void 0,entryPoint:void 0,constants:{},shaderLayout:void 0}))();get[Symbol.toStringTag](){return"ComputePipeline"}hash="";constructor(e,t){super(e,t,r.defaultProps),this.shaderLayout=t.shaderLayout}}},9853:(e,t,n)=>{n.d(t,{r:()=>r});var i=n(8314);class r extends i.F{static defaultProps={...i.F.defaultProps,vs:null,vertexEntryPoint:"vertexMain",vsConstants:{},fs:null,fragmentEntryPoint:"fragmentMain",fsConstants:{},shaderLayout:null,bufferLayout:[],topology:"triangle-list",parameters:{},bindings:{},uniforms:{}};get[Symbol.toStringTag](){return"RenderPipeline"}linkStatus="pending";hash="";constructor(e,t){super(e,t,r.defaultProps),this.shaderLayout=this.props.shaderLayout,this.bufferLayout=this.props.bufferLayout||[]}setUniformsWebGL(e){throw new Error("Use uniform blocks")}}},8314:(e,t,n)=>{n.d(t,{F:()=>r});var i=n(1010);class r{static defaultProps={id:"undefined",handle:void 0,userData:void 0};userData={};destroyed=!1;allocatedBytes=0;_attachedResources=(()=>new Set)();constructor(e,t,n){if(!e)throw new Error("no device");this._device=e,this.props=function(e,t){const n={...t};for(const i in e)void 0!==e[i]&&(n[i]=e[i]);return n}(t,n);const r="undefined"!==this.props.id?this.props.id:(0,i.L)(this[Symbol.toStringTag]);this.props.id=r,this.id=r,this.userData=this.props.userData||{},this.addStats()}destroy(){this.destroyResource()}delete(){return this.destroy(),this}toString(){return`${this[Symbol.toStringTag]||this.constructor.name}(${this.id})`}getProps(){return this.props}attachResource(e){this._attachedResources.add(e)}detachResource(e){this._attachedResources.delete(e)}destroyAttachedResource(e){this._attachedResources.delete(e)&&e.destroy()}destroyAttachedResources(){for(const e of Object.values(this._attachedResources))e.destroy();this._attachedResources=new Set}destroyResource(){this.destroyAttachedResources(),this.removeStats(),this.destroyed=!0}removeStats(){const e=this._device.statsManager.getStats("Resource Counts"),t=this[Symbol.toStringTag];e.get(`${t}s Active`).decrementCount()}trackAllocatedMemory(e,t){void 0===t&&(t=this[Symbol.toStringTag]);const n=this._device.statsManager.getStats("Resource Counts");n.get("GPU Memory").addCount(e),n.get(`${t} Memory`).addCount(e),this.allocatedBytes=e}trackDeallocatedMemory(e){void 0===e&&(e=this[Symbol.toStringTag]);const t=this._device.statsManager.getStats("Resource Counts");t.get("GPU Memory").subtractCount(this.allocatedBytes),t.get(`${e} Memory`).subtractCount(this.allocatedBytes),this.allocatedBytes=0}addStats(){const e=this._device.statsManager.getStats("Resource Counts"),t=this[Symbol.toStringTag];e.get("Resources Created").incrementCount(),e.get(`${t}s Created`).incrementCount(),e.get(`${t}s Active`).incrementCount()}}},9532:(e,t,n)=>{n.d(t,{L:()=>r});var i=n(8314);class r extends i.F{static defaultProps={...i.F.defaultProps,type:"color-sampler",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge",addressModeW:"clamp-to-edge",magFilter:"nearest",minFilter:"nearest",mipmapFilter:"none",lodMinClamp:0,lodMaxClamp:32,compare:"less-equal",maxAnisotropy:1};get[Symbol.toStringTag](){return"Sampler"}constructor(e,t){super(e,t,r.defaultProps)}}},349:(e,t,n)=>{n.d(t,{M:()=>a});var i=n(8314),r=n(1010);function o(e,t,n,i){if(i?.inlineSource){const i=function(e,t,n){let i="";for(let r=t-2;r<=t;r++){const o=e[r-1];void 0!==o&&(i+=s(o,t,n))}return i}(t,n);return`\n${i}${e.linePos>0?`${" ".repeat(e.linePos+5)}^^^\n`:""}${e.type.toUpperCase()}: ${e.message}\n\n`}const r="error"===e.type?"red":"#8B4000";return i?.html?`<div class='luma-compiler-log-error' style="color:${r};"><b> ${e.type.toUpperCase()}: ${e.message}</b></div>`:`${e.type.toUpperCase()}: ${e.message}`}function s(e,t,n){const i=n?.html?e.replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;").replaceAll('"',"&quot;").replaceAll("'","&#039;"):e;return`${function(e,t){let n="";for(let i=e.length;i<t;++i)n+=" ";return n+e}(String(t),4)}: ${i}${n?.html?"<br/>":"\n"}`}class a extends i.F{static defaultProps=(()=>({...i.F.defaultProps,language:"auto",stage:void 0,source:"",sourceMap:null,entryPoint:"main",debugShaders:void 0}))();get[Symbol.toStringTag](){return"Shader"}compilationStatus="pending";constructor(e,t){super(e,{id:l(t={...t,debugShaders:t.debugShaders||e.props.debugShaders||"errors"}),...t},a.defaultProps),this.stage=this.props.stage,this.source=this.props.source}getCompilationInfoSync(){return null}getTranslatedSource(){return null}async debugShader(){const e=this.props.debugShaders;switch(e){case"never":return;case"errors":if("success"===this.compilationStatus)return}const t=await this.getCompilationInfo();"warnings"===e&&0===t?.length||this._displayShaderLog(t)}_displayShaderLog(e){if("undefined"==typeof document||!document?.createElement)return;const t=c(this.source),n=`${this.stage} ${t}`;let i=function(e,t,n){let i="";const r=t.split(/\r?\n/),a=e.slice().sort(((e,t)=>e.lineNum-t.lineNum));switch(n?.showSourceCode||"no"){case"all":let t=0;for(let e=1;e<=r.length;e++)for(i+=s(r[e-1],e,n);a.length>t&&a[t].lineNum===e;){const e=a[t++];i+=o(e,r,e.lineNum,{...n,inlineSource:!1})}return i;case"issues":case"no":for(const s of e)i+=o(s,r,s.lineNum,{inlineSource:"no"!==n?.showSourceCode});return i}}(e,this.source,{showSourceCode:"all",html:!0});const r=this.getTranslatedSource();r&&(i+=`<br /><br /><h1>Translated Source</h1><br /><br /><code style="user-select:text;"><pre>${r}</pre></code>`);const a=document.createElement("Button");a.innerHTML=`\n<h1>Shader Compilation Error in ${n}</h1><br /><br />\n<code style="user-select:text;"><pre>\n${i}\n</pre></code>`,a.style.top="10px",a.style.left="10px",a.style.position="absolute",a.style.zIndex="9999",a.style.width="100%",a.style.textAlign="left",document.body.appendChild(a);const l=document.getElementsByClassName("luma-compiler-log-error");l[0]?.scrollIntoView(),a.onclick=()=>{const e=`data:text/plain,${encodeURIComponent(this.source)}`;navigator.clipboard.writeText(e)}}}function l(e){return c(e.source)||e.id||(0,r.L)(`unnamed ${e.stage}-shader`)}function c(e,t){void 0===t&&(t="unnamed");const n=/#define[\s*]SHADER_NAME[\s*]([A-Za-z0-9_-]+)[\s*]/.exec(e);return n?n[1]:t}},1213:(e,t,n)=>{n.d(t,{X:()=>r});var i=n(8314);class r extends i.F{static defaultProps=(()=>({...i.F.defaultProps,format:void 0,dimension:void 0,aspect:"all",baseMipLevel:0,mipLevelCount:void 0,baseArrayLayer:0,arrayLayerCount:void 0}))();get[Symbol.toStringTag](){return"TextureView"}constructor(e,t){super(e,t,r.defaultProps)}}},5839:(e,t,n)=>{n.d(t,{g:()=>r});var i=n(8314);class r extends i.F{static COPY_SRC=1;static COPY_DST=2;static TEXTURE=4;static STORAGE=8;static RENDER_ATTACHMENT=16;static CubeFaces=["+X","-X","+Y","-Y","+Z","-Z"];static defaultProps=(()=>({...i.F.defaultProps,data:null,dimension:"2d",format:"rgba8unorm",width:void 0,height:void 0,depth:1,mipmaps:!0,compressed:!1,usage:0,mipLevels:void 0,samples:void 0,sampler:{},view:void 0,flipY:void 0}))();get[Symbol.toStringTag](){return"Texture"}static isExternalImage(e){return"undefined"!=typeof ImageData&&e instanceof ImageData||"undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap||"undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement||"undefined"!=typeof HTMLVideoElement&&e instanceof HTMLVideoElement||"undefined"!=typeof VideoFrame&&e instanceof VideoFrame||"undefined"!=typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&e instanceof OffscreenCanvas}static getExternalImageSize(e){if("undefined"!=typeof ImageData&&e instanceof ImageData||"undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap||"undefined"!=typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&e instanceof OffscreenCanvas)return{width:e.width,height:e.height};if("undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement)return{width:e.naturalWidth,height:e.naturalHeight};if("undefined"!=typeof HTMLVideoElement&&e instanceof HTMLVideoElement)return{width:e.videoWidth,height:e.videoHeight};if("undefined"!=typeof VideoFrame&&e instanceof VideoFrame)return{width:e.displayWidth,height:e.displayHeight};throw new Error("Unknown image type")}static isTextureLevelData(e){const t=e?.data;return ArrayBuffer.isView(t)}static getTextureDataSize(e){if(!e)return null;if(ArrayBuffer.isView(e))return null;if(Array.isArray(e))return r.getTextureDataSize(e[0]);if(r.isExternalImage(e))return r.getExternalImageSize(e);if(e&&"object"==typeof e&&e.constructor===Object){const t=Object.values(e)[0];return{width:t.width,height:t.height}}throw new Error("texture size deduction failed")}static getMipLevelCount(e,t){return Math.floor(Math.log2(Math.max(e,t)))+1}static getCubeFaceDepth(e){switch(e){case"+X":return 0;case"-X":return 1;case"+Y":return 2;case"-Y":return 3;case"+Z":return 4;case"-Z":return 5;default:throw new Error(e)}}constructor(e,t){if(super(e,t,r.defaultProps),this.dimension=this.props.dimension,this.format=this.props.format,this.width=this.props.width,this.height=this.props.height,this.depth=this.props.depth,void 0===this.props.width||void 0===this.props.height){const e=r.getTextureDataSize(this.props.data);this.width=e?.width||1,this.height=e?.height||1}this.props.mipmaps&&void 0===this.props.mipLevels&&(this.props.mipLevels="pyramid"),this.mipLevels="pyramid"===this.props.mipLevels?r.getMipLevelCount(this.width,this.height):this.props.mipLevels||1,this.updateTimestamp=e.incrementTimestamp()}clone(e){return this.device.createTexture({...this.props,...e})}static defaultCopyExternalImageOptions={image:void 0,sourceX:0,sourceY:0,width:void 0,height:void 0,depth:1,mipLevel:0,x:0,y:0,z:0,aspect:"all",colorSpace:"srgb",premultipliedAlpha:!1,flipY:!1};static _fixProps(e){const t={...e},{width:n,height:i}=t;return"number"==typeof n&&(t.width=Math.max(1,Math.ceil(n))),"number"==typeof i&&(t.height=Math.max(1,Math.ceil(i))),t}}},6700:(e,t,n)=>{function i(e){const t=function(e){const t=o[e];return t}(r[e]),n=e.includes("norm"),i=!n&&!e.startsWith("float"),s=e.startsWith("s");return{dataType:r[e],byteLength:t,integer:i,signed:s,normalized:n}}n.d(t,{l:()=>i});const r={uint8:"uint8",sint8:"sint8",unorm8:"uint8",snorm8:"sint8",uint16:"uint16",sint16:"sint16",unorm16:"uint16",snorm16:"sint16",float16:"float16",float32:"float32",uint32:"uint32",sint32:"sint32"},o={uint8:1,sint8:1,uint16:2,sint16:2,float16:2,float32:4,uint32:4,sint32:4}},8337:(e,t,n)=>{n.d(t,{w:()=>r});var i=n(6700);function r(e){let t;e.endsWith("-webgl")&&(e.replace("-webgl",""),t=!0);const[n,r]=e.split("x"),o=n,s=r?parseInt(r):1,a=(0,i.l)(o),l={type:o,components:s,byteLength:a.byteLength*s,integer:a.integer,signed:a.signed,normalized:a.normalized};return t&&(l.webglOnly=!0),l}},1384:(e,t,n)=>{n.d(t,{K:()=>d});var i=n(8564),r=n(8862);function o(e){return Array.isArray(e)?0===e.length||"number"==typeof e[0]:function(e){return ArrayBuffer.isView(e)&&!(e instanceof DataView)}(e)}class s{uniforms={};modifiedUniforms={};modified=!0;bindingLayout={};needsRedraw="initialized";constructor(e){if(this.name=e?.name||"unnamed",e?.name&&e?.shaderLayout){const t=e?.shaderLayout.bindings?.find((t=>"uniform"===t.type&&t.name===e?.name));if(!t)throw new Error(e?.name);const n=t;for(const e of n.uniforms||[])this.bindingLayout[e.name]=e}}setUniforms(e){for(const[t,n]of Object.entries(e))this._setUniform(t,n),this.needsRedraw||this.setNeedsRedraw(`${this.name}.${t}=${n}`)}setNeedsRedraw(e){this.needsRedraw=this.needsRedraw||e}getAllUniforms(){return this.modifiedUniforms={},this.needsRedraw=!1,this.uniforms||{}}_setUniform(e,t){var n;(function(e,t,n){if(void 0===n&&(n=16),e!==t)return!1;const i=e,r=t;if(!o(i))return!1;if(o(r)&&i.length===r.length)for(let o=0;o<i.length;++o)if(r[o]!==i[o])return!1;return!0})(this.uniforms[e],t)||(this.uniforms[e]=o(n=t)?n.slice():n,this.modifiedUniforms[e]=!0,this.modified=!0)}}const a={f32:{type:"f32",components:1},i32:{type:"i32",components:1},u32:{type:"u32",components:1},"vec2<f32>":{type:"f32",components:2},"vec3<f32>":{type:"f32",components:3},"vec4<f32>":{type:"f32",components:4},"vec2<i32>":{type:"i32",components:2},"vec3<i32>":{type:"i32",components:3},"vec4<i32>":{type:"i32",components:4},"vec2<u32>":{type:"u32",components:2},"vec3<u32>":{type:"u32",components:3},"vec4<u32>":{type:"u32",components:4},"mat2x2<f32>":{type:"f32",components:4},"mat2x3<f32>":{type:"f32",components:6},"mat2x4<f32>":{type:"f32",components:8},"mat3x2<f32>":{type:"f32",components:6},"mat3x3<f32>":{type:"f32",components:9},"mat3x4<f32>":{type:"f32",components:12},"mat4x2<f32>":{type:"f32",components:8},"mat4x3<f32>":{type:"f32",components:12},"mat4x4<f32>":{type:"f32",components:16}};function l(e,t){switch(t){case 1:return e;case 2:return e+e%2;default:return e+(4-e%4)%4}}var c=n(8397);class u{layout={};constructor(e){let t=0;for(const[i,r]of Object.entries(e)){const e=a[r],{type:n,components:o}=e;t=l(t,o);const s=t;t+=o,this.layout[i]={type:n,size:o,offset:s}}t+=(4-t%4)%4;const n=4*t;this.byteLength=Math.max(n,1024)}getData(e){const t=Math.max(this.byteLength,1024),n=(0,c.o)(t),i={i32:new Int32Array(n),u32:new Uint32Array(n),f32:new Float32Array(n),f16:new Uint16Array(n)};for(const[s,a]of Object.entries(e)){const e=this.layout[s];if(!e){r.R.warn(`Supplied uniform value ${s} not present in uniform block layout`)();continue}const{type:t,size:n,offset:l}=e,c=i[t];if(1===n){if("number"!=typeof a&&"boolean"!=typeof a){r.R.warn(`Supplied value for single component uniform ${s} is not a number: ${a}`)();continue}c[l]=Number(a)}else{if(!o(a)){r.R.warn(`Supplied value for multi component / array uniform ${s} is not a numeric array: ${a}`)();continue}c.set(a,l)}}return new Uint8Array(n)}has(e){return Boolean(this.layout[e])}get(e){return this.layout[e]}}class d{uniformBlocks=(()=>new Map)();uniformBufferLayouts=(()=>new Map)();uniformBuffers=(()=>new Map)();constructor(e){for(const[t,n]of Object.entries(e)){const e=t,i=new u(n.uniformTypes||{});this.uniformBufferLayouts.set(e,i);const r=new s({name:t});r.setUniforms(n.defaultUniforms||{}),this.uniformBlocks.set(e,r)}}destroy(){for(const e of this.uniformBuffers.values())e.destroy()}setUniforms(e){for(const[t,n]of Object.entries(e))this.uniformBlocks.get(t)?.setUniforms(n);this.updateUniformBuffers()}getUniformBufferByteLength(e){return this.uniformBufferLayouts.get(e)?.byteLength||0}getUniformBufferData(e){const t=this.uniformBlocks.get(e)?.getAllUniforms()||{};return this.uniformBufferLayouts.get(e)?.getData(t)}createUniformBuffer(e,t,n){n&&this.setUniforms(n);const r=this.getUniformBufferByteLength(t),o=e.createBuffer({usage:i.h.UNIFORM|i.h.COPY_DST,byteLength:r}),s=this.getUniformBufferData(t);return o.write(s),o}getManagedUniformBuffer(e,t){if(!this.uniformBuffers.get(t)){const n=this.getUniformBufferByteLength(t),r=e.createBuffer({usage:i.h.UNIFORM|i.h.COPY_DST,byteLength:n});this.uniformBuffers.set(t,r)}return this.uniformBuffers.get(t)}updateUniformBuffers(){let e=!1;for(const t of this.uniformBlocks.keys()){const n=this.updateUniformBuffer(t);e||=n}return e&&r.R.log(3,`UniformStore.updateUniformBuffers(): ${e}`)(),e}updateUniformBuffer(e){const t=this.uniformBlocks.get(e);let n=this.uniformBuffers.get(e),i=!1;if(n&&t?.needsRedraw){i||=t.needsRedraw;const o=this.getUniformBufferData(e);n=this.uniformBuffers.get(e),n?.write(o);const s=this.uniformBlocks.get(e)?.getAllUniforms();r.R.log(4,`Writing to uniform buffer ${String(e)}`,o,s)()}return i}}},8397:(e,t,n)=>{let i;function r(e){return(!i||i.byteLength<e)&&(i=new ArrayBuffer(e)),i}function o(e,t){return new e(r(e.BYTES_PER_ELEMENT*t),0,t)}n.d(t,{X:()=>o,o:()=>r})},8862:(e,t,n)=>{n.d(t,{R:()=>i});const i=new(n(5593).t)({id:"luma.gl"})},1010:(e,t,n)=>{n.d(t,{L:()=>r});const i={};function r(e){void 0===e&&(e="id"),i[e]=i[e]||1;return`${e}-${i[e]++}`}},147:(e,t,n)=>{n.d(t,{Dt:()=>o,Qj:()=>r});let i="";function r(e){i=e}async function o(e,t){const n=new Image;return n.crossOrigin=t?.crossOrigin||"anonymous",n.src=e.startsWith("http")?e:i+e,await n.decode(),t?await createImageBitmap(n,t):await createImageBitmap(n)}},6864:(e,t,n)=>{n.d(t,{i:()=>r});var i=n(147);class r{isReady=!1;destroyed=!1;resolveReady=()=>{};rejectReady=()=>{};constructor(e,t){this.device=e,"string"==typeof t?.data&&"2d"===t.dimension&&(t={...t,data:(0,i.Dt)(t.data)}),this.ready=new Promise(((e,t)=>{this.resolveReady=()=>{this.isReady=!0,e()},this.rejectReady=t})),this.initAsync(t)}async initAsync(e){const t=e.data,n=await o(t).then(undefined,undefined);if(this.destroyed)return;const i={...e,data:n};this.texture=this.device.createTexture(i),this.sampler=this.texture.sampler,this.view=this.texture.view,this.isReady=!0}destroy(){this.texture&&(this.texture.destroy(),this.texture=null),this.destroyed=!0}resize(e){if(!this.isReady)throw new Error("Cannot resize texture before it is ready");if(e.width===this.texture.width&&e.height===this.texture.height)return!1;if(this.texture){const t=this.texture;this.texture=t.clone(e),t.destroy()}return!0}}async function o(e){if(e=await e,Array.isArray(e))return await Promise.all(e.map(o));if(e&&"object"==typeof e&&e.constructor===Object){const t=e,n=await Promise.all(Object.values(t)),i=Object.keys(t),r={};for(let e=0;e<i.length;e++)r[i[e]]=n[e];return r}return e}},3042:(e,t,n)=>{n.d(t,{V:()=>r});var i=n(3267);class r{userData={};constructor(e){const{attributes:t={},indices:n=null,vertexCount:r=null}=e;this.id=e.id||(0,i.L)("geometry"),this.topology=e.topology,n&&(this.indices=ArrayBuffer.isView(n)?{value:n,size:1}:n),this.attributes={};for(const[i,o]of Object.entries(t)){const e=ArrayBuffer.isView(o)?{value:o}:o;if(!ArrayBuffer.isView(e.value))throw new Error(`${this._print(i)}: must be typed array or object with value as typed array`);if("POSITION"!==i&&"positions"!==i||e.size||(e.size=3),"indices"===i){if(this.indices)throw new Error("Multiple indices detected");this.indices=e}else this.attributes[i]=e}this.indices&&void 0!==this.indices.isIndexed&&(this.indices=Object.assign({},this.indices),delete this.indices.isIndexed),this.vertexCount=r||this._calculateVertexCount(this.attributes,this.indices)}getVertexCount(){return this.vertexCount}getAttributes(){return this.indices?{indices:this.indices,...this.attributes}:this.attributes}_print(e){return`Geometry ${this.id} attribute ${e}`}_setAttributes(e,t){return this}_calculateVertexCount(e,t){if(t)return t.value.length;let n=1/0;for(const i of Object.values(e)){const{value:e,size:t,constant:r}=i;!r&&e&&void 0!==t&&t>=1&&(n=Math.min(n,e.length/t))}return n}}},7460:(e,t,n)=>{n.d(t,{K:()=>P});var i=n(9853),r=n(1384),o=n(8862),s=n(1213),a=n(8564),l=n(5839),c=n(9532),u=n(9647);function d(e,t,n){if(!t||t>4)throw new Error(`size ${t}`);const i=t;let r=function(e){const t=ArrayBuffer.isView(e)?e.constructor:e;switch(t){case Float32Array:return"float32";case Uint16Array:return"uint16";case Uint32Array:return"uint32";case Uint8Array:case Uint8ClampedArray:return"uint8";case Int8Array:return"sint8";case Int16Array:return"sint16";case Int32Array:return"sint32";default:throw new Error(t.constructor.name)}}(e);if("uint8"===r&&n&&1===i)return"unorm8-webgl";if("uint8"===r&&n&&3===i)return"unorm8x3-webgl";if("uint8"===r||"sint8"===r){if(1===i||3===i)throw new Error(`size: ${t}`);return n&&(r=r.replace("int","norm")),`${r}x${i}`}if("uint16"===r||"sint16"===r){if(1===i||3===i)throw new Error(`size: ${t}`);return n&&(r=r.replace("int","norm")),`${r}x${i}`}return 1===i?r:`${r}x${i}`}var f=n(6791),_=n(1448),h=n(3267);class p{userData={};bufferLayout=[];constructor(e){if(this.id=e.id||(0,h.L)("geometry"),this.topology=e.topology,this.indices=e.indices||null,this.attributes=e.attributes,this.vertexCount=e.vertexCount,this.bufferLayout=e.bufferLayout||[],this.indices&&!(this.indices.usage&a.h.INDEX))throw new Error("Index buffer must have INDEX usage")}destroy(){this.indices?.destroy();for(const e of Object.values(this.attributes))e.destroy()}getVertexCount(){return this.vertexCount}getAttributes(){return this.attributes}getIndexes(){return this.indices||null}_calculateVertexCount(e){return e.byteLength/12}}function m(e,t){if(t instanceof p)return t;const n=function(e,t){if(!t.indices)return;const n=t.indices.value;return e.createBuffer({usage:a.h.INDEX,data:n})}(e,t),{attributes:i,bufferLayout:r}=function(e,t){const n=[],i={};for(const[o,s]of Object.entries(t.attributes)){let t=o;switch(o){case"POSITION":t="positions";break;case"NORMAL":t="normals";break;case"TEXCOORD_0":t="texCoords";break;case"COLOR_0":t="colors"}if(s){i[t]=e.createBuffer({data:s.value,id:`${o}-buffer`});const{value:r,size:a,normalized:l}=s;n.push({name:t,format:d(r,a,l)})}}const r=t._calculateVertexCount(t.attributes,t.indices);return{attributes:i,bufferLayout:n,vertexCount:r}}(e,t);return new p({topology:t.topology||"triangle-list",bufferLayout:r,vertexCount:t.vertexCount,indices:n,attributes:i})}var g=n(5128);class E{static defaultProps={...i.r.defaultProps};static getDefaultPipelineFactory(e){return e._lumaData.defaultPipelineFactory=e._lumaData.defaultPipelineFactory||new E(e),e._lumaData.defaultPipelineFactory}_hashCounter=0;_hashes={};_renderPipelineCache={};_computePipelineCache={};constructor(e){this.device=e,this.destroyPolicy=e.props._factoryDestroyPolicy}createRenderPipeline(e){const t={...i.r.defaultProps,...e},n=this._hashRenderPipeline(t);if(!this._renderPipelineCache[n]){const e=this.device.createRenderPipeline({...t,id:t.id?`${t.id}-cached`:void 0});e.hash=n,this._renderPipelineCache[n]={pipeline:e,useCount:0}}return this._renderPipelineCache[n].useCount++,this._renderPipelineCache[n].pipeline}createComputePipeline(e){const t={...g.C.defaultProps,...e},n=this._hashComputePipeline(t);if(!this._computePipelineCache[n]){const e=this.device.createComputePipeline({...t,id:t.id?`${t.id}-cached`:void 0});e.hash=n,this._computePipelineCache[n]={pipeline:e,useCount:0}}return this._computePipelineCache[n].useCount++,this._computePipelineCache[n].pipeline}release(e){const t=e.hash,n=e instanceof g.C?this._computePipelineCache:this._renderPipelineCache;n[t].useCount--,0===n[t].useCount&&"unused"===this.destroyPolicy&&(n[t].pipeline.destroy(),delete n[t])}_hashComputePipeline(e){return`${this._getHash(e.shader.source)}`}_hashRenderPipeline(e){const t=e.vs?this._getHash(e.vs.source):0,n=e.fs?this._getHash(e.fs.source):0,i=this._getHash(JSON.stringify(e.bufferLayout));if("webgl"===this.device.type)return`${t}/${n}V-BL${i}`;{const r=this._getHash(JSON.stringify(e.parameters));return`${t}/${n}V-T${e.topology}P${r}BL${i}`}}_getHash(e){return void 0===this._hashes[e]&&(this._hashes[e]=this._hashCounter++),this._hashes[e]}}var A=n(349);class v{static defaultProps={...A.M.defaultProps};static getDefaultShaderFactory(e){return e._lumaData.defaultShaderFactory||=new v(e),e._lumaData.defaultShaderFactory}_cache={};constructor(e){this.device=e,this.destroyPolicy=e.props._factoryDestroyPolicy}createShader(e){const t=this._hashShader(e);let n=this._cache[t];if(!n){const i=this.device.createShader({...e,id:e.id?`${e.id}-cached`:void 0});this._cache[t]=n={shader:i,useCount:0}}return n.useCount++,n.shader}release(e){const t=this._hashShader(e),n=this._cache[t];n&&(n.useCount--,0===n.useCount&&"unused"===this.destroyPolicy&&(delete this._cache[t],n.shader.destroy()))}_hashShader(e){return`${e.stage}:${e.source}`}}let T=null,R=null;function b(e,t,n){if(e===t)return!0;if(!n||!e||!t)return!1;if(Array.isArray(e)){if(!Array.isArray(t)||e.length!==t.length)return!1;for(let i=0;i<e.length;i++)if(!b(e[i],t[i],n-1))return!1;return!0}if(Array.isArray(t))return!1;if("object"==typeof e&&"object"==typeof t){const i=Object.keys(e),r=Object.keys(t);if(i.length!==r.length)return!1;for(const o of i){if(!t.hasOwnProperty(o))return!1;if(!b(e[o],t[o],n-1))return!1}return!0}return!1}var S=n(2290),C=n(7390),I=n(6864);class P{static defaultProps=(()=>({...i.r.defaultProps,source:void 0,vs:null,fs:null,id:"unnamed",handle:void 0,userData:{},defines:{},modules:[],moduleSettings:void 0,geometry:null,indexBuffer:null,attributes:{},constantAttributes:{},varyings:[],isInstanced:void 0,instanceCount:0,vertexCount:0,shaderInputs:void 0,pipelineFactory:void 0,shaderFactory:void 0,transformFeedback:void 0,shaderAssembler:f._.getDefaultShaderAssembler(),debugShaders:void 0,disableWarnings:void 0}))();userData={};isInstanced=void 0;instanceCount=0;indexBuffer=null;bufferAttributes={};constantAttributes={};bindings={};uniforms={};transformFeedback=null;_attributeInfos={};_gpuGeometry=null;_pipelineNeedsUpdate="newly created";_needsRedraw="initializing";_destroyed=!1;_lastDrawTimestamp=-1;constructor(e,t){this.props={...P.defaultProps,...t},t=this.props,this.id=t.id||(0,h.L)("model"),this.device=e,Object.assign(this.userData,t.userData);const n=Object.fromEntries(this.props.modules?.map((e=>[e.name,e]))||[]);this.setShaderInputs(t.shaderInputs||new C.l(n));const i=function(e){return{type:e.type,shaderLanguage:e.info.shadingLanguage,shaderLanguageVersion:e.info.shadingLanguageVersion,gpu:e.info.gpu,features:e.features}}(e),r=(this.props.modules?.length>0?this.props.modules:this.shaderInputs?.getModules())||[];if("webgpu"===this.device.type&&this.props.source){this.props.shaderLayout||=(0,_.$)(this.props.source);const{source:e,getUniforms:t}=this.props.shaderAssembler.assembleWGSLShader({platformInfo:i,...this.props,modules:r});this.source=e,this._getModuleUniforms=t}else{const{vs:e,fs:t,getUniforms:n}=this.props.shaderAssembler.assembleGLSLShaderPair({platformInfo:i,...this.props,modules:r});this.vs=e,this.fs=t,this._getModuleUniforms=n}this.vertexCount=this.props.vertexCount,this.instanceCount=this.props.instanceCount,this.topology=this.props.topology,this.bufferLayout=this.props.bufferLayout,this.parameters=this.props.parameters,t.geometry&&this.setGeometry(t.geometry),this.pipelineFactory=t.pipelineFactory||E.getDefaultPipelineFactory(this.device),this.shaderFactory=t.shaderFactory||v.getDefaultShaderFactory(this.device),this.pipeline=this._updatePipeline(),this.vertexArray=e.createVertexArray({renderPipeline:this.pipeline}),this._gpuGeometry&&this._setGeometryAttributes(this._gpuGeometry),"isInstanced"in t&&(this.isInstanced=t.isInstanced),t.instanceCount&&this.setInstanceCount(t.instanceCount),t.vertexCount&&this.setVertexCount(t.vertexCount),t.indexBuffer&&this.setIndexBuffer(t.indexBuffer),t.attributes&&this.setAttributes(t.attributes),t.constantAttributes&&this.setConstantAttributes(t.constantAttributes),t.bindings&&this.setBindings(t.bindings),t.uniforms&&this.setUniforms(t.uniforms),t.moduleSettings&&this.updateModuleSettings(t.moduleSettings),t.transformFeedback&&(this.transformFeedback=t.transformFeedback),Object.seal(this)}destroy(){this._destroyed||(this.pipelineFactory.release(this.pipeline),this.shaderFactory.release(this.pipeline.vs),this.pipeline.fs&&this.shaderFactory.release(this.pipeline.fs),this._uniformStore.destroy(),this._gpuGeometry?.destroy(),this._destroyed=!0)}needsRedraw(){this._getBindingsUpdateTimestamp()>this._lastDrawTimestamp&&this.setNeedsRedraw("contents of bound textures or buffers updated");const e=this._needsRedraw;return this._needsRedraw=!1,e}setNeedsRedraw(e){this._needsRedraw||=e}predraw(){this.updateShaderInputs(),this.pipeline=this._updatePipeline()}draw(e){let t;this.predraw();try{this._logDrawCallStart(),this.pipeline=this._updatePipeline();const n=this._getBindings();this.pipeline.setBindings(n,{disableWarnings:this.props.disableWarnings}),F(this.uniforms)||this.pipeline.setUniformsWebGL(this.uniforms);const{indexBuffer:i}=this.vertexArray,r=i?i.byteLength/("uint32"===i.indexType?4:2):void 0;t=this.pipeline.draw({renderPass:e,vertexArray:this.vertexArray,isInstanced:this.isInstanced,vertexCount:this.vertexCount,instanceCount:this.instanceCount,indexCount:r,transformFeedback:this.transformFeedback||void 0,parameters:this.parameters,topology:this.topology})}finally{this._logDrawCallEnd()}return this._logFramebuffer(e),t?(this._lastDrawTimestamp=this.device.timestamp,this._needsRedraw=!1):this._needsRedraw="waiting for resource initialization",t}setGeometry(e){this._gpuGeometry?.destroy();const t=e&&m(this.device,e);t&&(this.setTopology(t.topology||"triangle-list"),this.bufferLayout=N(t.bufferLayout,this.bufferLayout),this.vertexArray&&this._setGeometryAttributes(t)),this._gpuGeometry=t}setTopology(e){e!==this.topology&&(this.topology=e,this._setPipelineNeedsUpdate("topology"))}setBufferLayout(e){this.bufferLayout=this._gpuGeometry?N(e,this._gpuGeometry.bufferLayout):e,this._setPipelineNeedsUpdate("bufferLayout"),this.pipeline=this._updatePipeline(),this.vertexArray=this.device.createVertexArray({renderPipeline:this.pipeline}),this._gpuGeometry&&this._setGeometryAttributes(this._gpuGeometry)}setParameters(e){b(e,this.parameters,2)||(this.parameters=e,this._setPipelineNeedsUpdate("parameters"))}setInstanceCount(e){this.instanceCount=e,void 0===this.isInstanced&&e>0&&(this.isInstanced=!0),this.setNeedsRedraw("instanceCount")}setVertexCount(e){this.vertexCount=e,this.setNeedsRedraw("vertexCount")}setShaderInputs(e){this.shaderInputs=e,this._uniformStore=new r.K(this.shaderInputs.modules);for(const[t,n]of Object.entries(this.shaderInputs.modules))if(x(n)){const e=this._uniformStore.getManagedUniformBuffer(this.device,t);this.bindings[`${t}Uniforms`]=e}this.setNeedsRedraw("shaderInputs")}updateShaderInputs(){this._uniformStore.setUniforms(this.shaderInputs.getUniformValues()),this.setBindings(this.shaderInputs.getBindingValues()),this.setNeedsRedraw("shaderInputs")}setBindings(e){Object.assign(this.bindings,e),this.setNeedsRedraw("bindings")}setTransformFeedback(e){this.transformFeedback=e,this.setNeedsRedraw("transformFeedback")}setIndexBuffer(e){this.vertexArray.setIndexBuffer(e),this.setNeedsRedraw("indexBuffer")}setAttributes(e,t){e.indices&&o.R.warn(`Model:${this.id} setAttributes() - indexBuffer should be set using setIndexBuffer()`)();for(const[n,i]of Object.entries(e)){const e=this.bufferLayout.find((e=>L(e).includes(n)));if(!e){o.R.warn(`Model(${this.id}): Missing layout for buffer "${n}".`)();continue}const r=L(e);let s=!1;for(const t of r){const e=this._attributeInfos[t];e&&(this.vertexArray.setBuffer(e.location,i),s=!0)}s||(t?.disableWarnings??this.props.disableWarnings)||o.R.warn(`Model(${this.id}): Ignoring buffer "${i.id}" for unknown attribute "${n}"`)()}this.setNeedsRedraw("attributes")}setConstantAttributes(e,t){for(const[n,i]of Object.entries(e)){const e=this._attributeInfos[n];e?this.vertexArray.setConstantWebGL(e.location,i):(t?.disableWarnings??this.props.disableWarnings)||o.R.warn(`Model "${this.id}: Ignoring constant supplied for unknown attribute "${n}"`)()}this.setNeedsRedraw("constants")}setUniforms(e){F(e)||(this.pipeline.setUniformsWebGL(e),Object.assign(this.uniforms,e)),this.setNeedsRedraw("uniforms")}updateModuleSettings(e){const{bindings:t,uniforms:n}=(0,S.l)(this._getModuleUniforms(e));Object.assign(this.bindings,t),Object.assign(this.uniforms,n),this.setNeedsRedraw("moduleSettings")}_getBindings(){return Object.entries(this.bindings).reduce(((e,t)=>{let[n,i]=t;return i instanceof I.i?i.isReady&&(e[n]=i.texture):e[n]=i,e}),{})}_getBindingsUpdateTimestamp(){let e=0;for(const t of Object.values(this.bindings))t instanceof s.X?e=Math.max(e,t.texture.updateTimestamp):t instanceof a.h||t instanceof l.g?e=Math.max(e,t.updateTimestamp):t instanceof I.i?e=t.texture?Math.max(e,t.texture.updateTimestamp):1/0:t instanceof c.L||(e=Math.max(e,t.buffer.updateTimestamp));return e}_setGeometryAttributes(e){const t={...e.attributes};for(const[n]of Object.entries(t))this.pipeline.shaderLayout.attributes.find((e=>e.name===n))||"positions"===n||delete t[n];this.vertexCount=e.vertexCount,this.setIndexBuffer(e.indices||null),this.setAttributes(e.attributes,{disableWarnings:!0}),this.setAttributes(t,{disableWarnings:this.props.disableWarnings}),this.setNeedsRedraw("geometry attributes")}_setPipelineNeedsUpdate(e){this._pipelineNeedsUpdate||=e,this.setNeedsRedraw(e)}_updatePipeline(){if(this._pipelineNeedsUpdate){let e=null,t=null;this.pipeline&&(o.R.log(1,`Model ${this.id}: Recreating pipeline because "${this._pipelineNeedsUpdate}".`)(),e=this.pipeline.vs,t=this.pipeline.fs),this._pipelineNeedsUpdate=!1;const n=this.shaderFactory.createShader({id:`${this.id}-vertex`,stage:"vertex",source:this.source||this.vs,debugShaders:this.props.debugShaders});let i=null;this.source?i=n:this.fs&&(i=this.shaderFactory.createShader({id:`${this.id}-fragment`,stage:"fragment",source:this.source||this.fs,debugShaders:this.props.debugShaders})),this.pipeline=this.pipelineFactory.createRenderPipeline({...this.props,bufferLayout:this.bufferLayout,topology:this.topology,parameters:this.parameters,bindings:this._getBindings(),vs:n,fs:i}),this._attributeInfos=(0,u.P)(this.pipeline.shaderLayout,this.bufferLayout),e&&this.shaderFactory.release(e),t&&this.shaderFactory.release(t)}return this.pipeline}_lastLogTime=0;_logOpen=!1;_logDrawCallStart(){const e=o.R.level>3?0:1e4;o.R.level<2||Date.now()-this._lastLogTime<e||(this._lastLogTime=Date.now(),this._logOpen=!0,o.R.group(2,`>>> DRAWING MODEL ${this.id}`,{collapsed:o.R.level<=2})())}_logDrawCallEnd(){if(this._logOpen){const e=function(e,t){const n={},i="Values";if(0===e.attributes.length&&!e.varyings?.length)return{"No attributes or varyings":{[i]:"N/A"}};for(const r of e.attributes)r&&(n[`in ${r.location} ${r.name}: ${r.type}`]={[i]:r.stepMode||"vertex"});for(const r of e.varyings||[])n[`out ${r.location} ${r.name}`]={[i]:JSON.stringify(r)};return n}(this.pipeline.shaderLayout,this.id);o.R.table(2,e)();const t=this.shaderInputs.getDebugTable();for(const[i,r]of Object.entries(this.uniforms))t[i]={value:r};o.R.table(2,t)();const n=this._getAttributeDebugTable();o.R.table(2,this._attributeInfos)(),o.R.table(2,n)(),o.R.groupEnd(2)(),this._logOpen=!1}}_drawCount=0;_logFramebuffer(e){const t=this.device.props.debugFramebuffers;if(this._drawCount++,!t)return;const n=e.props.framebuffer;n&&function(e,t){let{id:n,minimap:i,opaque:r,top:o="0",left:s="0",rgbaScale:a=1}=t;T||(T=document.createElement("canvas"),T.id=n,T.title=n,T.style.zIndex="100",T.style.position="absolute",T.style.top=o,T.style.left=s,T.style.border="blue 5px solid",T.style.transform="scaleY(-1)",document.body.appendChild(T),R=T.getContext("2d")),T.width===e.width&&T.height===e.height||(T.width=e.width/2,T.height=e.height/2,T.style.width="400px",T.style.height="400px");const l=e.device.readPixelsToArrayWebGL(e),c=R?.createImageData(e.width,e.height);if(c){const e=0;for(let t=0;t<l.length;t+=4)c.data[e+t+0]=l[t+0]*a,c.data[e+t+1]=l[t+1]*a,c.data[e+t+2]=l[t+2]*a,c.data[e+t+3]=r?255:l[t+3]*a;R?.putImageData(c,0,0)}}(n,{id:n.id,minimap:!0})}_getAttributeDebugTable(){const e={};for(const[t,n]of Object.entries(this._attributeInfos)){const i=this.vertexArray.attributes[n.location];e[n.location]={name:t,type:n.shaderType,values:i?this._getBufferOrConstantValues(i,n.bufferDataType):"null"}}if(this.vertexArray.indexBuffer){const{indexBuffer:t}=this.vertexArray,n="uint32"===t.indexType?new Uint32Array(t.debugData):new Uint16Array(t.debugData);e.indices={name:"indices",type:t.indexType,values:n.toString()}}return e}_getBufferOrConstantValues(e,t){const n=function(e){switch(e){case"float32":return Float32Array;case"uint32":return Uint32Array;case"sint32":return Int32Array;case"uint16":case"unorm16":return Uint16Array;case"sint16":case"snorm16":return Int16Array;case"uint8":case"unorm8":return Uint8Array;case"sint8":case"snorm8":return Int8Array;default:throw new Error(e)}}(t);return(e instanceof a.h?new n(e.debugData):e).toString()}}function x(e){return Boolean(e.uniformTypes&&!F(e.uniformTypes))}function N(e,t){const n=[...e];for(const i of t){const e=n.findIndex((e=>e.name===i.name));e<0?n.push(i):n[e]=i}return n}function L(e){return e.attributes?e.attributes?.map((e=>e.attribute)):[e.name]}function F(e){for(const t in e)return!1;return!0}},2290:(e,t,n)=>{n.d(t,{l:()=>r});var i=n(6282);function r(e){const t={bindings:{},uniforms:{}};return Object.keys(e).forEach((n=>{const r=e[n];var o;o=r,(0,i.H9)(o)||"number"==typeof o||"boolean"==typeof o?t.uniforms[n]=r:t.bindings[n]=r})),t}},3736:(e,t,n)=>{n.d(t,{o:()=>a});var i=n(7909),r=n(6213),o=n(8862),s=n(4083);class a extends s.V{constructor(e){void 0===e&&(e={}),e=Array.isArray(e)?{children:e}:e;const{children:t=[]}=e;o.R.assert(t.every((e=>e instanceof s.V)),"every child must an instance of ScenegraphNode"),super(e),this.children=t}getBounds(){const e=[[1/0,1/0,1/0],[-1/0,-1/0,-1/0]];return this.traverse(((t,n)=>{let{worldMatrix:r}=n;const o=t.getBounds();if(!o)return;const[s,a]=o,l=new i.P(s).add(a).divide([2,2,2]);r.transformAsPoint(l,l);const c=new i.P(a).subtract(s).divide([2,2,2]);r.transformAsVector(c,c);for(let u=0;u<8;u++){const t=new i.P(1&u?-1:1,2&u?-1:1,4&u?-1:1).multiply(c).add(l);for(let n=0;n<3;n++)e[0][n]=Math.min(e[0][n],t[n]),e[1][n]=Math.max(e[1][n],t[n])}})),Number.isFinite(e[0][0])?e:null}destroy(){this.children.forEach((e=>e.destroy())),this.removeAll(),super.destroy()}add(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];for(const i of t)Array.isArray(i)?this.add(...i):this.children.push(i);return this}remove(e){const t=this.children,n=t.indexOf(e);return n>-1&&t.splice(n,1),this}removeAll(){return this.children=[],this}traverse(e,t){let{worldMatrix:n=new r.k}=void 0===t?{}:t;const i=new r.k(n).multiplyRight(this.matrix);for(const r of this.children)r instanceof a?r.traverse(e,{worldMatrix:i}):e(r,{worldMatrix:i})}}},642:(e,t,n)=>{n.d(t,{s:()=>r});var i=n(4083);class r extends i.V{bounds=null;constructor(e){super(e),this.model=e.model,this.managedResources=e.managedResources||[],this.bounds=e.bounds||null,this.setProps(e)}destroy(){this.model&&(this.model.destroy(),this.model=null),this.managedResources.forEach((e=>e.destroy())),this.managedResources=[]}getBounds(){return this.bounds}draw(e){return this.model.draw(e)}}},4083:(e,t,n)=>{n.d(t,{V:()=>s});var i=n(6213),r=n(7909),o=n(3267);class s{matrix=(()=>new i.k)();display=!0;position=(()=>new r.P)();rotation=(()=>new r.P)();scale=(()=>new r.P(1,1,1))();userData={};props={};constructor(e){void 0===e&&(e={});const{id:t}=e;this.id=t||(0,o.L)(this.constructor.name),this._setScenegraphNodeProps(e)}getBounds(){return null}destroy(){}delete(){this.destroy()}setProps(e){return this._setScenegraphNodeProps(e),this}toString(){return`{type: ScenegraphNode, id: ${this.id})}`}setPosition(e){return this.position=e,this}setRotation(e){return this.rotation=e,this}setScale(e){return this.scale=e,this}setMatrix(e,t){void 0===t&&(t=!0),t?this.matrix.copy(e):this.matrix=e}setMatrixComponents(e){const{position:t,rotation:n,scale:i,update:r=!0}=e;return t&&this.setPosition(t),n&&this.setRotation(n),i&&this.setScale(i),r&&this.updateMatrix(),this}updateMatrix(){const e=this.position,t=this.rotation,n=this.scale;return this.matrix.identity(),this.matrix.translate(e),this.matrix.rotateXYZ(t),this.matrix.scale(n),this}update(e){void 0===e&&(e={});const{position:t,rotation:n,scale:i}=e;return t&&this.setPosition(t),n&&this.setRotation(n),i&&this.setScale(i),this.updateMatrix(),this}getCoordinateUniforms(e,t){t=t||this.matrix;const n=new i.k(e).multiplyRight(t),r=n.invert(),o=r.transpose();return{viewMatrix:e,modelMatrix:t,objectMatrix:t,worldMatrix:n,worldInverseMatrix:r,worldInverseTransposeMatrix:o}}_setScenegraphNodeProps(e){"position"in e&&this.setPosition(e.position),"rotation"in e&&this.setRotation(e.rotation),"scale"in e&&this.setScale(e.scale),"matrix"in e&&this.setMatrix(e.matrix),Object.assign(this.props,e)}}},7390:(e,t,n)=>{n.d(t,{l:()=>s});var i=n(8862),r=n(2558),o=n(2290);class s{constructor(e){const t=(0,r.$Q)(Object.values(e).filter((e=>e.dependencies)));for(const n of t)e[n.name]=n;i.R.log(1,"Creating ShaderInputs with modules",Object.keys(e))(),this.modules=e,this.moduleUniforms={},this.moduleBindings={};for(const[n,r]of Object.entries(e))this._addModule(r),r.name&&n!==r.name&&i.R.warn(`Module name: ${n} vs ${r.name}`)()}destroy(){}setProps(e){for(const t of Object.keys(e)){const n=t,r=e[n]||{},s=this.modules[n];if(!s){i.R.warn(`Module ${t} not found`)();continue}const a=this.moduleUniforms[n],l=this.moduleBindings[n],c=s.getUniforms?.(r,a)||r,{uniforms:u,bindings:d}=(0,o.l)(c);this.moduleUniforms[n]={...a,...u},this.moduleBindings[n]={...l,...d}}}getModules(){return Object.values(this.modules)}getUniformValues(){return this.moduleUniforms}getBindingValues(){const e={};for(const t of Object.values(this.moduleBindings))Object.assign(e,t);return e}getDebugTable(){const e={};for(const[t,n]of Object.entries(this.moduleUniforms))for(const[i,r]of Object.entries(n))e[`${t}.${i}`]={type:this.modules[t].uniformTypes?.[i],value:String(r)};return e}_addModule(e){const t=e.name;this.moduleUniforms[t]=e.defaultUniforms||{},this.moduleBindings[t]={}}}},3267:(e,t,n)=>{n.d(t,{L:()=>r});const i={};function r(e){void 0===e&&(e="id"),i[e]=i[e]||1;return`${e}-${i[e]++}`}},5463:(e,t,n)=>{function i(e,t){return{name:r(e,t),language:"glsl",version:o(e)}}function r(e,t){void 0===t&&(t="unnamed");const n=/#define[^\S\r\n]*SHADER_NAME[^\S\r\n]*([A-Za-z0-9_-]+)\s*/.exec(e);return n?n[1]:t}function o(e){let t=100;const n=e.match(/[^\s]+/g);if(n&&n.length>=2&&"#version"===n[0]){const e=parseInt(n[1],10);Number.isFinite(e)&&(t=e)}if(100!==t&&300!==t)throw new Error(`Invalid GLSL version ${t}`);return t}n.d(t,{i:()=>i})},7234:(e,t,n)=>{n.d(t,{v:()=>o});const i=/^\s*\#\s*ifdef\s*([a-zA-Z_]+)\s*$/,r=/^\s*\#\s*endif\s*$/;function o(e,t){const n=e.split("\n"),o=[];let s=!0,a=null;for(const l of n){const e=l.match(i),n=l.match(r);e?(a=e[1],s=Boolean(t?.defines?.[a])):n?s=!0:s&&o.push(l)}return o.join("\n")}},6791:(e,t,n)=>{n.d(t,{_:()=>s});var i=n(2375),r=n(7611),o=n(7234);class s{_hookFunctions=[];_defaultModules=[];static getDefaultShaderAssembler(){return s.defaultShaderAssembler=s.defaultShaderAssembler||new s,s.defaultShaderAssembler}addDefaultModule(e){this._defaultModules.find((t=>t.name===("string"==typeof e?e:e.name)))||this._defaultModules.push(e)}removeDefaultModule(e){const t="string"==typeof e?e:e.name;this._defaultModules=this._defaultModules.filter((e=>e.name!==t))}addShaderHook(e,t){t&&(e=Object.assign(t,{hook:e})),this._hookFunctions.push(e)}assembleWGSLShader(e){const t=this._getModuleList(e.modules),n=this._hookFunctions,{source:i,getUniforms:s}=(0,r.l4)({...e,source:e.source,modules:t,hookFunctions:n});return{source:"wgsl"===e.platformInfo.shaderLanguage?(0,o.v)(i):i,getUniforms:s,modules:t}}assembleGLSLShaderPair(e){const t=this._getModuleList(e.modules),n=this._hookFunctions;return{...(0,r.uO)({...e,vs:e.vs,fs:e.fs,modules:t,hookFunctions:n}),modules:t}}_getModuleList(e){void 0===e&&(e=[]);const t=new Array(this._defaultModules.length+e.length),n={};let r=0;for(let i=0,o=this._defaultModules.length;i<o;++i){const e=this._defaultModules[i],o=e.name;t[r++]=e,n[o]=!0}for(let i=0,o=e.length;i<o;++i){const o=e[i],s=o.name;n[s]||(t[r++]=o,n[s]=!0)}return t.length=r,(0,i.$g)(t),t}}},7611:(e,t,n)=>{n.d(t,{uO:()=>E,l4:()=>g,R1:()=>R});var i=n(2558);var r=n(9315);const o=[[/^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/,"#version 300 es\n"],[/\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g,"textureLod("],[/\btexture(2D|2DProj|Cube)(EXT)?\(/g,"texture("]],s=[...o,[c("attribute"),"in $1"],[c("varying"),"out $1"]],a=[...o,[c("varying"),"in $1"]];function l(e,t){for(const[n,i]of t)e=e.replace(n,i);return e}function c(e){return new RegExp(`\\b${e}[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)`,"g")}var u=n(2375);function d(e,t){let n="";for(const i in e){const r=e[i];if(n+=`void ${r.signature} {\n`,r.header&&(n+=`  ${r.header}`),t[i]){const e=t[i];e.sort(((e,t)=>e.order-t.order));for(const t of e)n+=`  ${t.injection}\n`}r.footer&&(n+=`  ${r.footer}`),n+="}\n"}return n}function f(e){const t={vertex:{},fragment:{}};for(const n of e){let e,i;"string"!=typeof n?(e=n,i=e.hook):(e={},i=n),i=i.trim();const[r,o]=i.split(":"),s=i.replace(/\(.+/,""),a=Object.assign(e,{signature:o});switch(r){case"vs":t.vertex[s]=a;break;case"fs":t.fragment[s]=a;break;default:throw new Error(r)}}return t}var _=n(6849),h=n(5463);const p=`\n\n${r.O_}\n`,m="precision highp float;\n";function g(e){const t=(0,i.$Q)(e.modules||[]);return{source:A(e.platformInfo,{...e,source:e.source,stage:"vertex",modules:t}),getUniforms:T(t)}}function E(e){const{vs:t,fs:n}=e,r=(0,i.$Q)(e.modules||[]);return{vs:v(e.platformInfo,{...e,source:t,stage:"vertex",modules:r}),fs:v(e.platformInfo,{...e,source:n,stage:"fragment",modules:r}),getUniforms:T(r)}}function A(e,t){const{source:n,stage:i,modules:o,hookFunctions:s=[],inject:a={},log:l}=t;(0,_.v)("string"==typeof n,"shader source must be a string");const c=n;let h="";const m=f(s),g={},E={},A={};for(const r in a){const e="string"==typeof a[r]?{injection:a[r],order:0}:a[r],t=/^(v|f)s:(#)?([\w-]+)$/.exec(r);if(t){const n=t[2],i=t[3];n?"decl"===i?E[r]=[e]:A[r]=[e]:g[r]=[e]}else A[r]=[e]}const v=o;for(const r of v){l&&(0,u.ZG)(r,c,l);h+=R(r,"wgsl");const e=r.injections?.[i]||{};for(const t in e){const n=/^(v|f)s:#([\w-]+)$/.exec(t);if(n){const i="decl"===n[2]?E:A;i[t]=i[t]||[],i[t].push(e[t])}else g[t]=g[t]||[],g[t].push(e[t])}}return h+=p,h=(0,r.bv)(h,i,E),h+=d(m[i],g),h+=c,h=(0,r.bv)(h,i,A),h}function v(e,t){const{id:n,source:i,stage:o,language:c="glsl",modules:g,defines:E={},hookFunctions:A=[],inject:v={},prologue:T=!0,log:b}=t;(0,_.v)("string"==typeof i,"shader source must be a string");const S="glsl"===c?(0,h.i)(i).version:-1,C=e.shaderLanguageVersion,I=100===S?"#version 100":"#version 300 es",P=i.split("\n").slice(1).join("\n"),x={};g.forEach((e=>{Object.assign(x,e.defines)})),Object.assign(x,E);let N="";switch(c){case"wgsl":break;case"glsl":N=T?`${I}\n\n// ----- PROLOGUE -------------------------\n${function(e){const{id:t,source:n,stage:i}=e,r=t&&-1===n.indexOf("SHADER_NAME");return r?`\n#define SHADER_NAME ${t}_${i}`:""}({id:n,source:i,stage:o})}\n#define SHADER_TYPE_${o.toUpperCase()}\n\n${function(e){switch(e?.gpu.toLowerCase()){case"apple":return"#define APPLE_GPU\n// Apple optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n";case"nvidia":return"#define NVIDIA_GPU\n// Nvidia optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n";case"intel":return"#define INTEL_GPU\n// Intel optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n";case"amd":return"#define AMD_GPU\n";default:return"#define DEFAULT_GPU\n// Prevent driver from optimizing away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Headless Chrome's software shader 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// If the GPU doesn't have full 32 bits precision, will causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n"}}(e)}\n${"fragment"===o?m:""}\n\n// ----- APPLICATION DEFINES -------------------------\n\n${function(e){void 0===e&&(e={});let t="";for(const n in e){const i=e[n];(i||Number.isFinite(i))&&(t+=`#define ${n.toUpperCase()} ${e[n]}\n`)}return t}(x)}\n\n`:`${I}\n`}const L=f(A),F={},y={},M={};for(const r in v){const e="string"==typeof v[r]?{injection:v[r],order:0}:v[r],t=/^(v|f)s:(#)?([\w-]+)$/.exec(r);if(t){const n=t[2],i=t[3];n?"decl"===i?y[r]=[e]:M[r]=[e]:F[r]=[e]}else M[r]=[e]}for(const r of g){b&&(0,u.ZG)(r,P,b);N+=R(r,o);const e=r.instance?.normalizedInjections[o]||{};for(const t in e){const n=/^(v|f)s:#([\w-]+)$/.exec(t);if(n){const i="decl"===n[2]?y:M;i[t]=i[t]||[],i[t].push(e[t])}else F[t]=F[t]||[],F[t].push(e[t])}}return N+="// ----- MAIN SHADER SOURCE -------------------------",N+=p,N=(0,r.bv)(N,o,y),N+=d(L[o],F),N+=P,N=(0,r.bv)(N,o,M),"glsl"===c&&S!==C&&(N=function(e,t){if(300!==Number(e.match(/^#version[ \t]+(\d+)/m)?.[1]||100))throw new Error("luma.gl v9 only supports GLSL 3.00 shader sources");switch(t){case"vertex":return l(e,s);case"fragment":return l(e,a);default:throw new Error(t)}}(N,o)),N.trim()}function T(e){return function(t){const n={};for(const i of e){const e=i.getUniforms?.(t,n);Object.assign(n,e)}return n}}function R(e,t){let n;switch(t){case"vertex":n=e.vs||"";break;case"fragment":n=e.fs||"";break;case"wgsl":n=e.source||"";break;default:(0,_.v)(!1)}if(!e.name)throw new Error("Shader module must have a name");const i=e.name.toUpperCase().replace(/[^0-9a-z]/gi,"_");let r=`// ----- MODULE ${e.name} ---------------\n\n`;return"wgsl"!==t&&(r+=`#define MODULE_${i}\n`),r+=`${n}\n`,r}},9315:(e,t,n)=>{n.d(t,{O_:()=>l,Qt:()=>f,bv:()=>d,Uu:()=>c});var i=n(6849);const r={vertex:"#ifdef MODULE_LOGDEPTH\n  logdepth_adjustPosition(gl_Position);\n#endif\n",fragment:"#ifdef MODULE_MATERIAL\n  fragColor = material_filterColor(fragColor);\n#endif\n\n#ifdef MODULE_LIGHTING\n  fragColor = lighting_filterColor(fragColor);\n#endif\n\n#ifdef MODULE_FOG\n  fragColor = fog_filterColor(fragColor);\n#endif\n\n#ifdef MODULE_PICKING\n  fragColor = picking_filterHighlightColor(fragColor);\n  fragColor = picking_filterPickingColor(fragColor);\n#endif\n\n#ifdef MODULE_LOGDEPTH\n  logdepth_setFragDepth();\n#endif\n"},o=/void\s+main\s*\([^)]*\)\s*\{\n?/,s=/}\n?[^{}]*$/,a=[],l="__LUMA_INJECT_DECLARATIONS__";function c(e){const t={vertex:{},fragment:{}};for(const n in e){let i=e[n];"string"==typeof i&&(i={order:0,injection:i}),t[u(n)][n]=i}return t}function u(e){const t=e.slice(0,2);switch(t){case"vs":return"vertex";case"fs":return"fragment";default:throw new Error(t)}}function d(e,t,n,i){void 0===i&&(i=!1);const c="vertex"===t;for(const r in n){const t=n[r];t.sort(((e,t)=>e.order-t.order)),a.length=t.length;for(let e=0,n=t.length;e<n;++e)a[e]=t[e].injection;const i=`${a.join("\n")}\n`;switch(r){case"vs:#decl":c&&(e=e.replace(l,i));break;case"vs:#main-start":c&&(e=e.replace(o,(e=>e+i)));break;case"vs:#main-end":c&&(e=e.replace(s,(e=>i+e)));break;case"fs:#decl":c||(e=e.replace(l,i));break;case"fs:#main-start":c||(e=e.replace(o,(e=>e+i)));break;case"fs:#main-end":c||(e=e.replace(s,(e=>i+e)));break;default:e=e.replace(r,(e=>e+i))}}return e=e.replace(l,""),i&&(e=e.replace(/\}\s*$/,(e=>e+r[t]))),e}function f(e){const t={};return(0,i.v)(Array.isArray(e)&&e.length>1),e.forEach((e=>{for(const n in e)t[n]=t[n]?`${t[n]}\n${e[n]}`:e[n]})),t}},2558:(e,t,n)=>{n.d(t,{$Q:()=>r,KC:()=>s,uV:()=>o});var i=n(2375);function r(e){(0,i.$g)(e);const t={},n={};o({modules:e,level:0,moduleMap:t,moduleDepth:n});const r=Object.keys(n).sort(((e,t)=>n[t]-n[e])).map((e=>t[e]));return(0,i.$g)(r),r}function o(e){const{modules:t,level:n,moduleMap:i,moduleDepth:r}=e;if(n>=5)throw new Error("Possible loop in shader dependency graph");for(const o of t)i[o.name]=o,(void 0===r[o.name]||r[o.name]<n)&&(r[o.name]=n);for(const s of t)s.dependencies&&o({modules:s.dependencies,level:n+1,moduleMap:i,moduleDepth:r})}function s(e){return function(e){(0,i.$g)(e);const t={},n={};return o({modules:e,level:0,moduleMap:t,moduleDepth:n}),e=Object.keys(n).sort(((e,t)=>n[t]-n[e])).map((e=>t[e])),(0,i.$g)(e),e}(e)}},2375:(e,t,n)=>{n.d(t,{ZG:()=>d,Pm:()=>u,UK:()=>c,$g:()=>l});var i=n(6849);const r={number:{type:"number",validate:(e,t)=>Number.isFinite(e)&&"object"==typeof t&&(void 0===t.max||e<=t.max)&&(void 0===t.min||e>=t.min)},array:{type:"array",validate:(e,t)=>Array.isArray(e)||ArrayBuffer.isView(e)}};function o(e){let t=s(e);if("object"!==t)return{value:e,...r[t],type:t};if("object"==typeof e)return e?void 0!==e.type?{...e,...r[e.type],type:e.type}:void 0===e.value?{type:"object",value:e}:(t=s(e.value),{...e,...r[t],type:t}):{type:"object",value:null};throw new Error("props")}function s(e){return Array.isArray(e)||ArrayBuffer.isView(e)?"array":typeof e}var a=n(9315);function l(e){e.map((e=>c(e)))}function c(e){if(e.instance)return;l(e.dependencies||[]);const{propTypes:t={},deprecations:n=[],inject:i={}}=e,r={normalizedInjections:(0,a.Uu)(i),parsedDeprecations:f(n)};t&&(r.propValidators=function(e){const t={};for(const[n,i]of Object.entries(e))t[n]=o(i);return t}(t)),e.instance=r;let s={};t&&(s=Object.entries(t).reduce(((e,t)=>{let[n,i]=t;const r=i?.value;return r&&(e[n]=r),e}),{})),e.defaultUniforms={...e.defaultUniforms,...s}}function u(e,t,n){c(e);const r=n||{...e.defaultUniforms};return t&&e.getUniforms?e.getUniforms(t,r):function(e,t,n){const r={};for(const[o,s]of Object.entries(t))e&&o in e&&!s.private?(s.validate&&(0,i.v)(s.validate(e[o],s),`${n}: invalid ${o}`),r[o]=e[o]):r[o]=s.value;return r}(t,e.instance?.propValidators,e.name)}function d(e,t,n){e.deprecations?.forEach((e=>{e.regex?.test(t)&&(e.deprecated?n.deprecated(e.old,e.new)():n.removed(e.old,e.new)())}))}function f(e){return e.forEach((e=>{if("function"===e.type)e.regex=new RegExp(`\\b${e.old}\\(`);else e.regex=new RegExp(`${e.type} ${e.old};`)})),e}},6849:(e,t,n)=>{function i(e,t){if(!e)throw new Error(t||"shadertools: assertion failed.")}n.d(t,{v:()=>i})},1448:(e,t,n)=>{n.d(t,{$:()=>o});var i=n(8862),r=n(2973);function o(e){const t={attributes:[],bindings:[]};let n;try{n=function(e){try{return new r.$X(e)}catch(t){if(t instanceof Error)throw t;let e="WGSL parse error";throw"object"==typeof t&&t?.message&&(e+=`: ${t.message} `),"object"==typeof t&&t?.token&&(e+=t.token.line||""),new Error(e,{cause:t})}}(e)}catch(l){return i.R.error(l.message)(),t}for(const i of n.uniforms){const e=[];for(const t of i.type?.members||[])e.push({name:t.name,type:s(t.type)});t.bindings.push({type:"uniform",name:i.name,location:i.binding,group:i.group,members:e})}const o=n.entry.vertex[0],a=o?.inputs.length||0;for(let i=0;i<a;i++){const e=o.inputs[i];if("location"===e.locationType){const n=s(e.type);t.attributes.push({name:e.name,location:Number(e.location),type:n})}}return t}function s(e){return e.format?`${e.name}<${e.format.name}>`:e.name}},291:(e,t,n)=>{n.d(t,{_:()=>s});const i="#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\n\nstruct AmbientLight {\n vec3 color;\n};\n\nstruct PointLight {\n vec3 color;\n vec3 position;\n\n // Constant-Linear-Exponential\n vec3 attenuation;\n};\n\nstruct DirectionalLight {\n  vec3 color;\n  vec3 direction;\n};\n\nuniform AmbientLight lighting_uAmbientLight;\nuniform PointLight lighting_uPointLight[MAX_LIGHTS];\nuniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];\nuniform int lighting_uPointLightCount;\nuniform int lighting_uDirectionalLightCount;\n\nuniform bool lighting_uEnabled;\n\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n\n#endif\n",r={lightSources:{}};function o(e){void 0===e&&(e={});const{color:t=[0,0,0],intensity:n=1}=e;return t.map((e=>e*n/255))}const s={name:"lights",vs:i,fs:i,getUniforms:function e(t){if(void 0===t&&(t=r),"lightSources"in t){const{ambientLight:e,pointLights:n,directionalLights:i}=t.lightSources||{};return e||n&&n.length>0||i&&i.length>0?Object.assign({},function(e){let{ambientLight:t,pointLights:n=[],directionalLights:i=[]}=e;const r={};return r["lighting_uAmbientLight.color"]=t?o(t):[0,0,0],n.forEach(((e,t)=>{r[`lighting_uPointLight[${t}].color`]=o(e),r[`lighting_uPointLight[${t}].position`]=e.position,r[`lighting_uPointLight[${t}].attenuation`]=e.attenuation||[1,0,0]})),r.lighting_uPointLightCount=n.length,i.forEach(((e,t)=>{r[`lighting_uDirectionalLight[${t}].color`]=o(e),r[`lighting_uDirectionalLight[${t}].direction`]=e.direction})),r.lighting_uDirectionalLightCount=i.length,r}({ambientLight:e,pointLights:n,directionalLights:i}),{lighting_uEnabled:!0}):{lighting_uEnabled:!1}}if("lights"in t){const n={pointLights:[],directionalLights:[]};for(const e of t.lights||[])switch(e.type){case"ambient":n.ambientLight=e;break;case"directional":n.directionalLights?.push(e);break;case"point":n.pointLights?.push(e)}return e({lightSources:n})}return{}},defines:{MAX_LIGHTS:3}}},9345:(e,t,n)=>{n.d(t,{R:()=>i});const i={name:"pbr",vs:"uniform mat4 u_MVPMatrix;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_NormalMatrix;\n\nout vec3 pbr_vPosition;\nout vec2 pbr_vUV;\n\n#ifdef HAS_NORMALS\n# ifdef HAS_TANGENTS\nout mat3 pbr_vTBN;\n# else\nout vec3 pbr_vNormal;\n# endif\n#endif\n\nvoid pbr_setPositionNormalTangentUV(vec4 position, vec4 normal, vec4 tangent, vec2 uv)\n{\n  vec4 pos = u_ModelMatrix * position;\n  pbr_vPosition = vec3(pos.xyz) / pos.w;\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\n  vec3 normalW = normalize(vec3(u_NormalMatrix * vec4(normal.xyz, 0.0)));\n  vec3 tangentW = normalize(vec3(u_ModelMatrix * vec4(tangent.xyz, 0.0)));\n  vec3 bitangentW = cross(normalW, tangentW) * tangent.w;\n  pbr_vTBN = mat3(tangentW, bitangentW, normalW);\n#else // HAS_TANGENTS != 1\n  pbr_vNormal = normalize(vec3(u_ModelMatrix * vec4(normal.xyz, 0.0)));\n#endif\n#endif\n\n#ifdef HAS_UV\n  pbr_vUV = uv;\n#else\n  pbr_vUV = vec2(0.,0.);\n#endif\n}\n",fs:"precision highp float;\n\nuniform bool pbr_uUnlit;\n\n#ifdef USE_IBL\nuniform samplerCube u_DiffuseEnvSampler;\nuniform samplerCube u_SpecularEnvSampler;\nuniform sampler2D u_brdfLUT;\nuniform vec2 u_ScaleIBLAmbient;\n#endif\n\n#ifdef HAS_BASECOLORMAP\nuniform sampler2D u_BaseColorSampler;\n#endif\n#ifdef HAS_NORMALMAP\nuniform sampler2D u_NormalSampler;\nuniform float u_NormalScale;\n#endif\n#ifdef HAS_EMISSIVEMAP\nuniform sampler2D u_EmissiveSampler;\nuniform vec3 u_EmissiveFactor;\n#endif\n#ifdef HAS_METALROUGHNESSMAP\nuniform sampler2D u_MetallicRoughnessSampler;\n#endif\n#ifdef HAS_OCCLUSIONMAP\nuniform sampler2D u_OcclusionSampler;\nuniform float u_OcclusionStrength;\n#endif\n\n#ifdef ALPHA_CUTOFF\nuniform float u_AlphaCutoff;\n#endif\n\nuniform vec2 u_MetallicRoughnessValues;\nuniform vec4 u_BaseColorFactor;\n\nuniform vec3 u_Camera;\n\n// debugging flags used for shader output of intermediate PBR variables\n#ifdef PBR_DEBUG\nuniform vec4 u_ScaleDiffBaseMR;\nuniform vec4 u_ScaleFGDSpec;\n#endif\n\nin vec3 pbr_vPosition;\n\nin vec2 pbr_vUV;\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\nin mat3 pbr_vTBN;\n#else\nin vec3 pbr_vNormal;\n#endif\n#endif\n\n// Encapsulate the various inputs used by the various functions in the shading equation\n// We store values in this struct to simplify the integration of alternative implementations\n// of the shading terms, outlined in the Readme.MD Appendix.\nstruct PBRInfo\n{\n  float NdotL;                  // cos angle between normal and light direction\n  float NdotV;                  // cos angle between normal and view direction\n  float NdotH;                  // cos angle between normal and half vector\n  float LdotH;                  // cos angle between light direction and half vector\n  float VdotH;                  // cos angle between view direction and half vector\n  float perceptualRoughness;    // roughness value, as authored by the model creator (input to shader)\n  float metalness;              // metallic value at the surface\n  vec3 reflectance0;            // full reflectance color (normal incidence angle)\n  vec3 reflectance90;           // reflectance color at grazing angle\n  float alphaRoughness;         // roughness mapped to a more linear change in the roughness (proposed by [2])\n  vec3 diffuseColor;            // color contribution from diffuse lighting\n  vec3 specularColor;           // color contribution from specular lighting\n  vec3 n;                       // normal at surface point\n  vec3 v;                       // vector from surface point to camera\n};\n\nconst float M_PI = 3.141592653589793;\nconst float c_MinRoughness = 0.04;\n\nvec4 SRGBtoLINEAR(vec4 srgbIn)\n{\n#ifdef MANUAL_SRGB\n#ifdef SRGB_FAST_APPROXIMATION\n  vec3 linOut = pow(srgbIn.xyz,vec3(2.2));\n#else //SRGB_FAST_APPROXIMATION\n  vec3 bLess = step(vec3(0.04045),srgbIn.xyz);\n  vec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );\n#endif //SRGB_FAST_APPROXIMATION\n  return vec4(linOut,srgbIn.w);;\n#else //MANUAL_SRGB\n  return srgbIn;\n#endif //MANUAL_SRGB\n}\n\n// Find the normal for this fragment, pulling either from a predefined normal map\n// or from the interpolated mesh normal and tangent attributes.\nvec3 getNormal()\n{\n  // Retrieve the tangent space matrix\n#ifndef HAS_TANGENTS\n  vec3 pos_dx = dFdx(pbr_vPosition);\n  vec3 pos_dy = dFdy(pbr_vPosition);\n  vec3 tex_dx = dFdx(vec3(pbr_vUV, 0.0));\n  vec3 tex_dy = dFdy(vec3(pbr_vUV, 0.0));\n  vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n\n#ifdef HAS_NORMALS\n  vec3 ng = normalize(pbr_vNormal);\n#else\n  vec3 ng = cross(pos_dx, pos_dy);\n#endif\n\n  t = normalize(t - ng * dot(ng, t));\n  vec3 b = normalize(cross(ng, t));\n  mat3 tbn = mat3(t, b, ng);\n#else // HAS_TANGENTS\n  mat3 tbn = pbr_vTBN;\n#endif\n\n#ifdef HAS_NORMALMAP\n  vec3 n = texture(u_NormalSampler, pbr_vUV).rgb;\n  n = normalize(tbn * ((2.0 * n - 1.0) * vec3(u_NormalScale, u_NormalScale, 1.0)));\n#else\n  // The tbn matrix is linearly interpolated, so we need to re-normalize\n  vec3 n = normalize(tbn[2].xyz);\n#endif\n\n  return n;\n}\n\n// Calculation of the lighting contribution from an optional Image Based Light source.\n// Precomputed Environment Maps are required uniform inputs and are computed as outlined in [1].\n// See our README.md on Environment Maps [3] for additional discussion.\n#ifdef USE_IBL\nvec3 getIBLContribution(PBRInfo pbrInputs, vec3 n, vec3 reflection)\n{\n  float mipCount = 9.0; // resolution of 512x512\n  float lod = (pbrInputs.perceptualRoughness * mipCount);\n  // retrieve a scale and bias to F0. See [1], Figure 3\n  vec3 brdf = SRGBtoLINEAR(texture(u_brdfLUT,\n    vec2(pbrInputs.NdotV, 1.0 - pbrInputs.perceptualRoughness))).rgb;\n  vec3 diffuseLight = SRGBtoLINEAR(textureCube(u_DiffuseEnvSampler, n)).rgb;\n\n#ifdef USE_TEX_LOD\n  vec3 specularLight = SRGBtoLINEAR(textureCubeLod(u_SpecularEnvSampler, reflection, lod)).rgb;\n#else\n  vec3 specularLight = SRGBtoLINEAR(textureCube(u_SpecularEnvSampler, reflection)).rgb;\n#endif\n\n  vec3 diffuse = diffuseLight * pbrInputs.diffuseColor;\n  vec3 specular = specularLight * (pbrInputs.specularColor * brdf.x + brdf.y);\n\n  // For presentation, this allows us to disable IBL terms\n  diffuse *= u_ScaleIBLAmbient.x;\n  specular *= u_ScaleIBLAmbient.y;\n\n  return diffuse + specular;\n}\n#endif\n\n// Basic Lambertian diffuse\n// Implementation from Lambert's Photometria https://archive.org/details/lambertsphotome00lambgoog\n// See also [1], Equation 1\nvec3 diffuse(PBRInfo pbrInputs)\n{\n  return pbrInputs.diffuseColor / M_PI;\n}\n\n// The following equation models the Fresnel reflectance term of the spec equation (aka F())\n// Implementation of fresnel from [4], Equation 15\nvec3 specularReflection(PBRInfo pbrInputs)\n{\n  return pbrInputs.reflectance0 +\n    (pbrInputs.reflectance90 - pbrInputs.reflectance0) *\n    pow(clamp(1.0 - pbrInputs.VdotH, 0.0, 1.0), 5.0);\n}\n\n// This calculates the specular geometric attenuation (aka G()),\n// where rougher material will reflect less light back to the viewer.\n// This implementation is based on [1] Equation 4, and we adopt their modifications to\n// alphaRoughness as input as originally proposed in [2].\nfloat geometricOcclusion(PBRInfo pbrInputs)\n{\n  float NdotL = pbrInputs.NdotL;\n  float NdotV = pbrInputs.NdotV;\n  float r = pbrInputs.alphaRoughness;\n\n  float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));\n  float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));\n  return attenuationL * attenuationV;\n}\n\n// The following equation(s) model the distribution of microfacet normals across\n// the area being drawn (aka D())\n// Implementation from \"Average Irregularity Representation of a Roughened Surface\n// for Ray Reflection\" by T. S. Trowbridge, and K. P. Reitz\n// Follows the distribution function recommended in the SIGGRAPH 2013 course notes\n// from EPIC Games [1], Equation 3.\nfloat microfacetDistribution(PBRInfo pbrInputs)\n{\n  float roughnessSq = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;\n  float f = (pbrInputs.NdotH * roughnessSq - pbrInputs.NdotH) * pbrInputs.NdotH + 1.0;\n  return roughnessSq / (M_PI * f * f);\n}\n\nvoid PBRInfo_setAmbientLight(inout PBRInfo pbrInputs) {\n  pbrInputs.NdotL = 1.0;\n  pbrInputs.NdotH = 0.0;\n  pbrInputs.LdotH = 0.0;\n  pbrInputs.VdotH = 1.0;\n}\n\nvoid PBRInfo_setDirectionalLight(inout PBRInfo pbrInputs, vec3 lightDirection) {\n  vec3 n = pbrInputs.n;\n  vec3 v = pbrInputs.v;\n  vec3 l = normalize(lightDirection);             // Vector from surface point to light\n  vec3 h = normalize(l+v);                        // Half vector between both l and v\n\n  pbrInputs.NdotL = clamp(dot(n, l), 0.001, 1.0);\n  pbrInputs.NdotH = clamp(dot(n, h), 0.0, 1.0);\n  pbrInputs.LdotH = clamp(dot(l, h), 0.0, 1.0);\n  pbrInputs.VdotH = clamp(dot(v, h), 0.0, 1.0);\n}\n\nvoid PBRInfo_setPointLight(inout PBRInfo pbrInputs, PointLight pointLight) {\n  vec3 light_direction = normalize(pointLight.position - pbr_vPosition);\n  PBRInfo_setDirectionalLight(pbrInputs, light_direction);\n}\n\nvec3 calculateFinalColor(PBRInfo pbrInputs, vec3 lightColor) {\n  // Calculate the shading terms for the microfacet specular shading model\n  vec3 F = specularReflection(pbrInputs);\n  float G = geometricOcclusion(pbrInputs);\n  float D = microfacetDistribution(pbrInputs);\n\n  // Calculation of analytical lighting contribution\n  vec3 diffuseContrib = (1.0 - F) * diffuse(pbrInputs);\n  vec3 specContrib = F * G * D / (4.0 * pbrInputs.NdotL * pbrInputs.NdotV);\n  // Obtain final intensity as reflectance (BRDF) scaled by the energy of the light (cosine law)\n  return pbrInputs.NdotL * lightColor * (diffuseContrib + specContrib);\n}\n\nvec4 pbr_filterColor(vec4 colorUnused)\n{\n  // The albedo may be defined from a base texture or a flat color\n#ifdef HAS_BASECOLORMAP\n  vec4 baseColor = SRGBtoLINEAR(texture(u_BaseColorSampler, pbr_vUV)) * u_BaseColorFactor;\n#else\n  vec4 baseColor = u_BaseColorFactor;\n#endif\n\n#ifdef ALPHA_CUTOFF\n  if (baseColor.a < u_AlphaCutoff) {\n    discard;\n  }\n#endif\n\n  vec3 color = vec3(0, 0, 0);\n\n  if(pbr_uUnlit){\n    color.rgb = baseColor.rgb;\n  }\n  else{\n    // Metallic and Roughness material properties are packed together\n    // In glTF, these factors can be specified by fixed scalar values\n    // or from a metallic-roughness map\n    float perceptualRoughness = u_MetallicRoughnessValues.y;\n    float metallic = u_MetallicRoughnessValues.x;\n#ifdef HAS_METALROUGHNESSMAP\n    // Roughness is stored in the 'g' channel, metallic is stored in the 'b' channel.\n    // This layout intentionally reserves the 'r' channel for (optional) occlusion map data\n    vec4 mrSample = texture(u_MetallicRoughnessSampler, pbr_vUV);\n    perceptualRoughness = mrSample.g * perceptualRoughness;\n    metallic = mrSample.b * metallic;\n#endif\n    perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);\n    metallic = clamp(metallic, 0.0, 1.0);\n    // Roughness is authored as perceptual roughness; as is convention,\n    // convert to material roughness by squaring the perceptual roughness [2].\n    float alphaRoughness = perceptualRoughness * perceptualRoughness;\n\n    vec3 f0 = vec3(0.04);\n    vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0);\n    diffuseColor *= 1.0 - metallic;\n    vec3 specularColor = mix(f0, baseColor.rgb, metallic);\n\n    // Compute reflectance.\n    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\n\n    // For typical incident reflectance range (between 4% to 100%) set the grazing\n    // reflectance to 100% for typical fresnel effect.\n    // For very low reflectance range on highly diffuse objects (below 4%),\n    // incrementally reduce grazing reflecance to 0%.\n    float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);\n    vec3 specularEnvironmentR0 = specularColor.rgb;\n    vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;\n\n    vec3 n = getNormal();                          // normal at surface point\n    vec3 v = normalize(u_Camera - pbr_vPosition);  // Vector from surface point to camera\n\n    float NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);\n    vec3 reflection = -normalize(reflect(v, n));\n\n    PBRInfo pbrInputs = PBRInfo(\n      0.0, // NdotL\n      NdotV,\n      0.0, // NdotH\n      0.0, // LdotH\n      0.0, // VdotH\n      perceptualRoughness,\n      metallic,\n      specularEnvironmentR0,\n      specularEnvironmentR90,\n      alphaRoughness,\n      diffuseColor,\n      specularColor,\n      n,\n      v\n    );\n\n#ifdef USE_LIGHTS\n    // Apply ambient light\n    PBRInfo_setAmbientLight(pbrInputs);\n    color += calculateFinalColor(pbrInputs, lighting_uAmbientLight.color);\n\n    // Apply directional light\n    for(int i = 0; i < lighting_uDirectionalLightCount; i++) {\n      if (i < lighting_uDirectionalLightCount) {\n        PBRInfo_setDirectionalLight(pbrInputs, lighting_uDirectionalLight[i].direction);\n        color += calculateFinalColor(pbrInputs, lighting_uDirectionalLight[i].color);\n      }\n    }\n\n    // Apply point light\n    for(int i = 0; i < lighting_uPointLightCount; i++) {\n      if (i < lighting_uPointLightCount) {\n        PBRInfo_setPointLight(pbrInputs, lighting_uPointLight[i]);\n        float attenuation = getPointLightAttenuation(lighting_uPointLight[i], distance(lighting_uPointLight[i].position, pbr_vPosition));\n        color += calculateFinalColor(pbrInputs, lighting_uPointLight[i].color / attenuation);\n      }\n    }\n#endif\n\n    // Calculate lighting contribution from image based lighting source (IBL)\n#ifdef USE_IBL\n    color += getIBLContribution(pbrInputs, n, reflection);\n#endif\n\n    // Apply optional PBR terms for additional (optional) shading\n#ifdef HAS_OCCLUSIONMAP\n    float ao = texture(u_OcclusionSampler, pbr_vUV).r;\n    color = mix(color, color * ao, u_OcclusionStrength);\n#endif\n\n#ifdef HAS_EMISSIVEMAP\n    vec3 emissive = SRGBtoLINEAR(texture(u_EmissiveSampler, pbr_vUV)).rgb * u_EmissiveFactor;\n    color += emissive;\n#endif\n\n    // This section uses mix to override final color for reference app visualization\n    // of various parameters in the lighting equation.\n#ifdef PBR_DEBUG\n    // TODO: Figure out how to debug multiple lights\n\n    // color = mix(color, F, u_ScaleFGDSpec.x);\n    // color = mix(color, vec3(G), u_ScaleFGDSpec.y);\n    // color = mix(color, vec3(D), u_ScaleFGDSpec.z);\n    // color = mix(color, specContrib, u_ScaleFGDSpec.w);\n\n    // color = mix(color, diffuseContrib, u_ScaleDiffBaseMR.x);\n    color = mix(color, baseColor.rgb, u_ScaleDiffBaseMR.y);\n    color = mix(color, vec3(metallic), u_ScaleDiffBaseMR.z);\n    color = mix(color, vec3(perceptualRoughness), u_ScaleDiffBaseMR.w);\n#endif\n\n  }\n\n  return vec4(pow(color,vec3(1.0/2.2)), baseColor.a);\n}\n",defines:{LIGHTING_FRAGMENT:1},dependencies:[n(291)._],getUniforms:e=>e}},6041:(e,t,n)=>{n.d(t,{BA:()=>i.BA,Jh:()=>i.Jh,LL:()=>i.LL,MV:()=>i.MV,PZ:()=>i.PZ,YE:()=>i.YE,YI:()=>i.YI,Z5:()=>i.Z5,ZM:()=>i.ZM,_j:()=>i._j,gl:()=>i.gl,k9:()=>i.k9,n5:()=>i.n5,rq:()=>i.rq,yr:()=>i.yr,yt:()=>i.yt,z6:()=>i.z6,zW:()=>i.zW});var i=n(2258)},2258:(e,t,n)=>{n.d(t,{PZ:()=>Wn,gl:()=>Yn,MV:()=>$n,k9:()=>ei,zW:()=>qn,Jh:()=>Zn,z6:()=>oi,yr:()=>si,LL:()=>Kn,BA:()=>Jn,_j:()=>jn,YI:()=>Qn,YE:()=>ti,ZM:()=>ni,Z5:()=>zn,rq:()=>ri,yt:()=>ii,n5:()=>ai});var i={};n.r(i),n.d(i,{ShaderAssembler:()=>Fe._,_getDependencyGraph:()=>Ne.uV,_resolveModules:()=>Ne.KC,_warp:()=>wt,assembleGLSLShaderPair:()=>Le.uO,brightnessContrast:()=>Tt,bulgePinch:()=>Ut,capitalize:()=>Ge,checkShaderModuleDeprecations:()=>be.ZG,colorHalftone:()=>Ft,combineInjects:()=>Ye.Qt,convertToVec4:()=>Ue,denoise:()=>Rt,dirlight:()=>I,dirlight1:()=>qt,dotScreen:()=>yt,edgeWork:()=>Mt,fp32:()=>rt,fp64:()=>kt,fp64LowPart:()=>tt,fp64arithmetic:()=>Vt,fp64ify:()=>et,fp64ifyMatrix4:()=>nt,fromHalfFloat:()=>Ze,fxaa:()=>Ht,generateShaderForModule:()=>ke,geometry1:()=>Wt,getPassthroughFS:()=>Be,getQualifierDetails:()=>Oe,getShaderInfo:()=>ye.i,getShaderLayoutFromWGSL:()=>ze.$,getShaderModuleDependencies:()=>Ne.$Q,getShaderModuleSource:()=>Le.R1,getShaderModuleUniforms:()=>be.Pm,gouraudLighting:()=>tn,gouraudMaterial:()=>gt,hexagonalPixelate:()=>Ot,hueSaturation:()=>bt,initializeShaderModule:()=>be.UK,initializeShaderModules:()=>be.$g,ink:()=>Bt,lighting:()=>dt,lights1:()=>Qt._,magnify:()=>Dt,noise:()=>St,pbr:()=>rn.R,pbrMaterial:()=>vt,phongLighting:()=>nn,phongMaterial:()=>Et,picking:()=>ot,preprocess:()=>We.v,project1:()=>jt,random:()=>it,sepia:()=>Ct,swirl:()=>Gt,tiltShift:()=>xt,toHalfFloat:()=>qe,triangleBlur:()=>Nt,typeToChannelCount:()=>we,typeToChannelSuffix:()=>De,vibrance:()=>It,vignette:()=>Pt,zoomBlur:()=>Lt});var r=n(6540),o=n(5783),s=n(1384);function a(){let e=1,t=1;return()=>{return e=Math.sin(17.23*t),t=Math.cos(27.92*e),(n=1432.71*Math.abs(e*t))-Math.floor(n);var n}}class l{constructor(e){}async onInitialize(e){return null}}let c=1,u=1;class d{time=0;channels=(()=>new Map)();animations=(()=>new Map)();playing=!1;lastEngineTime=-1;constructor(){}addChannel(e){const{delay:t=0,duration:n=Number.POSITIVE_INFINITY,rate:i=1,repeat:r=1}=e,o=c++,s={time:0,delay:t,duration:n,rate:i,repeat:r};return this._setChannelTime(s,this.time),this.channels.set(o,s),o}removeChannel(e){this.channels.delete(e);for(const[t,n]of this.animations)n.channel===e&&this.detachAnimation(t)}isFinished(e){const t=this.channels.get(e);return void 0!==t&&this.time>=t.delay+t.duration*t.repeat}getTime(e){if(void 0===e)return this.time;const t=this.channels.get(e);return void 0===t?-1:t.time}setTime(e){this.time=Math.max(0,e);const t=this.channels.values();for(const i of t)this._setChannelTime(i,this.time);const n=this.animations.values();for(const i of n){const{animation:e,channel:t}=i;e.setTime(this.getTime(t))}}play(){this.playing=!0}pause(){this.playing=!1,this.lastEngineTime=-1}reset(){this.setTime(0)}attachAnimation(e,t){const n=u++;return this.animations.set(n,{animation:e,channel:t}),e.setTime(this.getTime(t)),n}detachAnimation(e){this.animations.delete(e)}update(e){this.playing&&(-1===this.lastEngineTime&&(this.lastEngineTime=e),this.setTime(this.time+(e-this.lastEngineTime)),this.lastEngineTime=e)}_setChannelTime(e,t){const n=t-e.delay;n>=e.duration*e.repeat?e.time=e.duration*e.rate:(e.time=Math.max(0,n)%e.duration,e.time*=e.rate)}}class f{startIndex=-1;endIndex=-1;factor=0;times=[];values=[];_lastTime=-1;constructor(e){this.setKeyFrames(e),this.setTime(0)}setKeyFrames(e){const t=e.length;this.times.length=t,this.values.length=t;for(let n=0;n<t;++n)this.times[n]=e[n][0],this.values[n]=e[n][1];this._calculateKeys(this._lastTime)}setTime(e){(e=Math.max(0,e))!==this._lastTime&&(this._calculateKeys(e),this._lastTime=e)}getStartTime(){return this.times[this.startIndex]}getEndTime(){return this.times[this.endIndex]}getStartData(){return this.values[this.startIndex]}getEndData(){return this.values[this.endIndex]}_calculateKeys(e){let t=0;const n=this.times.length;for(t=0;t<n-2&&!(this.times[t+1]>e);++t);this.startIndex=t,this.endIndex=t+1;const i=this.times[this.startIndex],r=this.times[this.endIndex];this.factor=Math.min(Math.max(0,(e-i)/(r-i)),1)}}var _=n(7460),h=n(3042),p=n(3267);class m extends h.V{constructor(e){void 0===e&&(e={});const{id:t=(0,p.L)("cube-geometry"),indices:n=!0}=e;super(n?{...e,id:t,topology:"triangle-list",indices:{size:1,value:g},attributes:{...S,...e.attributes}}:{...e,id:t,topology:"triangle-list",indices:void 0,attributes:{...C,...e.attributes}})}}const g=new Uint16Array([0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23]),E=new Float32Array([-1,-1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,-1,-1,1,-1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,1,-1,-1,-1,-1,1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,1,-1,1,-1]),A=new Float32Array([0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0]),v=new Float32Array([0,0,1,0,1,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,1,0,1,1,1,1,0,1,0,0,1,0,1,0,1,1,0,1,0,0,0,0,1,0,1,1,0,1]),T=new Float32Array([1,-1,1,-1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,-1,-1,-1,1,1,1,1,1,1,1,-1,-1,1,-1,-1,1,1,1,1,-1,-1,-1,1,-1,1,1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,1,1,-1,1,1,-1,-1,1,-1,-1,1,1,-1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,1,-1,1,-1,-1,-1,1,-1]),R=new Float32Array([1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,0,1,0,1,1,0,0]),b=new Float32Array([1,0,1,1,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,1,1,0,1,1,1,1,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,0,0,1,1,0,1,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,1,1,1,0,1,1,0,0,1,0,1,0,1]),S={POSITION:{size:3,value:E},NORMAL:{size:3,value:A},TEXCOORD_0:{size:2,value:v}},C={POSITION:{size:3,value:T},TEXCOORD_0:{size:2,value:R},COLOR_0:{size:3,value:b}},I={props:{},uniforms:{},name:"dirlight",dependencies:[],source:"  \nstruct dirlightUniforms {\n  lightDirection: vec3<f32>,\n};\n\nalias DirlightNormal = vec3<f32>;\n\nstruct DirlightInputs {\n  normal: DirlightNormal,\n};\n\n@binding(1) @group(0) var<uniform> dirlight : dirlightUniforms;\n\n// For vertex\nfn dirlight_setNormal(normal: vec3<f32>) -> DirlightNormal {\n  return normalize(normal);\n}\n\n// Returns color attenuated by angle from light source\nfn dirlight_filterColor(color: vec4<f32>, inputs: DirlightInputs) -> vec4<f32> {\n  // TODO - fix default light direction\n  // let lightDirection = dirlight.lightDirection;\n  let lightDirection = vec3<f32>(1, 1, 1);\n  let d: f32 = abs(dot(inputs.normal, normalize(lightDirection)));\n  return vec4<f32>(color.rgb * d, color.a);\n}\n",vs:"out vec3 dirlight_vNormal;\n\nvoid dirlight_setNormal(vec3 normal) {\n  dirlight_vNormal = normalize(normal);\n}\n",fs:"uniform dirlightUniforms {\n  vec3 lightDirection;\n} dirlight;\n\nin vec3 dirlight_vNormal;\n\n// Returns color attenuated by angle from light source\nvec4 dirlight_filterColor(vec4 color) {\n  float d = abs(dot(dirlight_vNormal, normalize(dirlight.lightDirection)));\n  return vec4(color.rgb * d, color.a);\n}\n",uniformTypes:{lightDirection:"vec3<f32>"},defaultUniforms:{lightDirection:[1,1,2]},getUniforms:function(e){void 0===e&&(e=I.defaultUniforms);const t={};e.lightDirection&&(t.dirlight_uLightDirection=e.lightDirection);return t}};var P=n(6213),x=n(4901);const N=a(),L={uniformTypes:{uColor:"vec3<f32>",uModel:"mat4x4<f32>",uView:"mat4x4<f32>",uProjection:"mat4x4<f32>"}};class F extends l{static info='Key frame animation based on multiple hierarchical timelines.\n<button id="play">Play</button>\n<button id="pause">Pause</button><BR>\nTime: <input type="range" id="time" min="0" max="30000" step="1"><BR>\n';translations=[[2,-2,0],[2,2,0],[-2,2,0],[-2,-2,0]];rotations=(()=>[[N(),N(),N()],[N(),N(),N()],[N(),N(),N()],[N(),N(),N()]])();colors=[[1,0,0],[0,1,0],[0,0,1],[1,1,0]];keyFrameData=(()=>[[0,0],[1e3,2*Math.PI],[2e3,Math.PI],[3e3,2*Math.PI],[4e3,0]])();globalUniformStore=(()=>new s.K({dirlight:I}))();constructor(e){let{device:t,aspect:n,animationLoop:i}=e;super();const r=document.getElementById("play"),o=document.getElementById("pause");this.timeSlider=document.getElementById("time"),r&&o&&(r.addEventListener("click",(()=>this.timeline.play())),o.addEventListener("click",(()=>this.timeline.pause())),this.timeSlider.addEventListener("input",(e=>this.timeline.setTime(parseFloat(e.target.value))))),this.timeline=new d,i.attachTimeline(this.timeline),this.timeline.play();const a=[this.timeline.addChannel({delay:2e3,rate:.5,duration:8e3,repeat:2}),this.timeline.addChannel({delay:1e4,rate:.2,duration:2e4,repeat:1}),this.timeline.addChannel({delay:7e3,rate:1,duration:4e3,repeat:8}),this.timeline.addChannel({delay:0,rate:.8,duration:5e3,repeat:Number.POSITIVE_INFINITY})];this.cubes=new Array(4);const l=[new f(this.keyFrameData),new f(this.keyFrameData),new f(this.keyFrameData),new f(this.keyFrameData)];for(let c=0;c<4;++c){this.timeline.attachAnimation(l[c],a[c]);const e=new s.K({app:L});e.setUniforms({app:{uProjection:(new P.k).perspective({fovy:(0,x.F2)(60),aspect:n,near:1,far:20}),uView:(new P.k).lookAt({center:[0,0,0],eye:[0,0,-8]}),uColor:this.colors[c]}}),this.cubes[c]={uniformStore:e,translation:this.translations[c],rotation:this.rotations[c],keyFrames:l[c],model:new _.K(t,{id:`cube-${c}`,source:"struct Uniforms {\n  uColor : vec3<f32>,\n  uModel : mat4x4<f32>,\n  uView : mat4x4<f32>,\n  uProjection : mat4x4<f32>,\n};\n\n@binding(0) @group(0) var<uniform> app : Uniforms;\n\nstruct VertexInputs {\n  // CUBE GEOMETRY\n  @location(0) positions : vec4<f32>,\n  @location(1) normals : vec3<f32>\n};\n\nstruct FragmentInputs {\n  @builtin(position) Position : vec4<f32>,\n  @location(0) color : vec3<f32>,\n  @location(1) dirlightNormal: DirlightNormal,\n}\n\n@vertex\nfn vertexMain(inputs: VertexInputs) -> FragmentInputs {\n  var outputs : FragmentInputs;\n  // gl_Position = app.uProjection * app.uView * app.uModel * vec4(positions, 1.0);\n  outputs.Position = app.uProjection * app.uView * app.uModel * inputs.positions;\n  outputs.color = app.uColor;\n\n  let normal: vec3<f32> = (app.uModel * vec4<f32>(inputs.normals, 0.0)).xyz;\n  outputs.dirlightNormal = dirlight_setNormal(normal);\n  return outputs;\n}\n\n@fragment\nfn fragmentMain(inputs: FragmentInputs) -> @location(0) vec4<f32> {\n  var fragColor = vec4(inputs.color, 1.);\n  fragColor = dirlight_filterColor(fragColor, DirlightInputs(inputs.dirlightNormal));\n  return fragColor;\n}\n",vs:"#version 300 es\n\nin vec3 positions;\nin vec3 normals;\n\nuniform appUniforms {\n  vec3 uColor;\n  mat4 uModel;\n  mat4 uView;\n  mat4 uProjection;\n} app;\n\nout vec3 color;\n\nvoid main(void) {\n  vec3 normal = vec3(app.uModel * vec4(normals, 0.0));\n\n  // Set up data for modules\n  color = app.uColor;\n  dirlight_setNormal(normal);\n  gl_Position = app.uProjection * app.uView * app.uModel * vec4(positions, 1.0);\n}\n",fs:"#version 300 es\n\nprecision highp float;\n\nin vec3 color;\nout vec4 fragColor;\n\nvoid main(void) {\n  fragColor = vec4(color, 1.);\n  fragColor = dirlight_filterColor(fragColor);\n}\n",instanceCount:1,modules:[I],geometry:new m,parameters:{depthWriteEnabled:!0,depthCompare:"less-equal"},bindings:{app:e.getManagedUniformBuffer(t,"app"),dirlight:this.globalUniformStore.getManagedUniformBuffer(t,"dirlight")}})}}}onFinalize(){for(const e of this.cubes)e.model.destroy()}onRender(e){let{device:t}=e;this.timeSlider&&(this.timeSlider.value=this.timeline.getTime());const n=new P.k;for(const r of this.cubes){const e=r.keyFrames.getStartData(),t=r.keyFrames.getEndData(),i=e+r.keyFrames.factor*(t-e),o=r.rotation[0]+i,s=r.rotation[1]+i,a=r.rotation[2];n.identity().translate(r.translation).rotateXYZ([o,s,a]),r.model.setUniforms({}),r.uniformStore.setUniforms({app:{uModel:n}}),r.uniformStore.updateUniformBuffers()}const i=t.beginRenderPass({clearColor:[0,0,0,1],clearDepth:!0});for(const r of this.cubes)r.model.draw(i);i.end()}}var y=n(7390),M=n(6864),O=n(147);const B={name:"app",uniformTypes:{modelMatrix:"mat4x4<f32>",viewMatrix:"mat4x4<f32>",projectionMatrix:"vec3<f32>",eyePosition:"vec3<f32>"}};class D extends _.K{constructor(e,t){super(e,{...t,id:"room-cube",geometry:new m,vs:D.vs,fs:D.fs})}static vs="#version 300 es\nin vec3 positions;\n\nuniform appUniforms {\n  mat4 modelMatrix;\n  mat4 viewMatrix;\n  mat4 projectionMatrix;\n} app;\n\nout vec3 vPosition;\n\nvoid main(void) {\n  gl_Position = app.projectionMatrix * app.viewMatrix * app.modelMatrix * vec4(positions, 1.0);\n  vPosition = positions;\n}\n  ";static fs="#version 300 es\nprecision highp float;\n\nuniform appUniforms {\n  mat4 modelMatrix;\n  mat4 viewMatrix;\n  mat4 projectionMatrix;\n} app;\n\nuniform samplerCube uTextureCube;\n\nin vec3 vPosition;\nout vec4 fragColor;\n\nvoid main(void) {\n  // The outer cube just samples the texture cube directly\n  fragColor = texture(uTextureCube, normalize(vPosition));\n}\n  "}class w extends _.K{constructor(e,t){super(e,{...t,id:"prism",geometry:new m({indices:!0}),vs:w.vs,fs:w.fs})}static vs="#version 300 es\nin vec3 positions;\nin vec3 normals;\nin vec2 texCoords;\n\nout vec3 vPosition;\nout vec3 vNormal;\nout vec2 vUV;\n\nuniform appUniforms {\n  mat4 modelMatrix;\n  mat4 viewMatrix;\n  mat4 projectionMatrix;\n  vec3 eyePosition;\n} app;\n\nvoid main(void) {\n  gl_Position = app.projectionMatrix * app.viewMatrix * app.modelMatrix * vec4(positions, 1.0);\n  vPosition = vec3(app.modelMatrix * vec4(positions, 1.0));\n  vNormal = normalize(vec3(app.modelMatrix * vec4(normals, 0.0)));\n  vUV = texCoords;\n}\n  ";static fs="#version 300 es\nprecision highp float;\n\nin vec3 vPosition;\nin vec3 vNormal;\nin vec2 vUV;\n\nout vec4 fragColor;\n\nuniform appUniforms {\n  mat4 modelMatrix;\n  mat4 viewMatrix;\n  mat4 projectionMatrix;\n  vec3 eyePosition;\n} app;\n\nuniform sampler2D uTexture;\nuniform samplerCube uTextureCube;\n\nvoid main(void) {\n  vec4 color = texture(uTexture, vec2(vUV.x, 1.0 - vUV.y));\n  vec3 reflectedDir = reflect(normalize(vPosition - app.eyePosition), vNormal);\n  vec4 reflectedColor = texture(uTextureCube, reflectedDir);\n\n  fragColor = mix(color, reflectedColor, 0.8);\n}\n  "}class U extends l{static info="\n<p>\nUses a luma.gl <code>TextureCube</code> to simulate a reflective\nsurface\n</p>\n";roomShaderInputs=(()=>new y.l({app:B}))();prismShaderInputs=(()=>new y.l({app:B}))();constructor(e){let{device:t}=e;super();const n=new M.i(t,{dimension:"cube",mipmaps:!0,data:(async()=>({"+X":await(0,O.Dt)("sky-posx.png"),"-X":await(0,O.Dt)("sky-negx.png"),"+Y":await(0,O.Dt)("sky-posy.png"),"-Y":await(0,O.Dt)("sky-negy.png"),"+Z":await(0,O.Dt)("sky-posz.png"),"-Z":await(0,O.Dt)("sky-negz.png")}))(),sampler:{magFilter:"linear",minFilter:"linear",mipmapFilter:"nearest"}}),i=new M.i(t,{data:(0,O.Dt)("vis-logo.png"),mipmaps:!0,sampler:{magFilter:"linear",minFilter:"linear",mipmapFilter:"nearest"}});this.cube=new D(t,{shaderInputs:this.roomShaderInputs,bindings:{uTextureCube:n},parameters:{depthWriteEnabled:!0,depthCompare:"less-equal"}}),this.prism=new w(t,{shaderInputs:this.prismShaderInputs,bindings:{uTexture:i,uTextureCube:n},parameters:{depthWriteEnabled:!0,depthCompare:"less-equal"}})}onFinalize(){this.prism.destroy(),this.cube.destroy()}onRender(e){let{device:t,aspect:n,tick:i}=e;const r=[5,-3,5],o=(new P.k).lookAt({eye:r}),s=(new P.k).perspective({fovy:(0,x.F2)(45),aspect:n,near:.001,far:1e3}),a=t.beginRenderPass({clearColor:[0,0,0,1],clearDepth:!0});this.roomShaderInputs.setProps({app:{viewMatrix:o,projectionMatrix:s,modelMatrix:(new P.k).scale([20,20,20])}}),this.cube.draw(a),this.prismShaderInputs.setProps({app:{eyePosition:r,viewMatrix:o,projectionMatrix:s,modelMatrix:(new P.k).rotateX(.01*i).rotateY(.013*i)}}),this.prism.draw(a),a.end()}}function G(e,t,n){return e+n*(t-e)}function H(e,t){for(var n=[],i=e;i<=t;i++)n.push(i);return n}function X(e,t){for(var n,i=e.length,r=0;i;)n=Math.floor(t()*i),r=e[i-=1],e[i]=e[n],e[n]=r;return e}var V=function(e){return e*e*e*(e*(6*e-15)+10)},k=function(e,t,n,i){var r=15&e,o=r<8?t:n,s=r<4?n:12==r||14==r?t:i;return(1&r?-o:o)+(2&r?-s:s)};const W=a(),Y={name:"app",uniformTypes:{mvpMatrix:"mat4x4<f32>",time:"f32"}};class z extends l{static info="\n<p>\nVolumetric 3D noise visualized using a <b>3D texture</b>.\n<p>\nUses the luma.gl <code>Texture3D</code> class.\n";static props={useDevicePixels:!0};mvpMatrix=(()=>new P.k)();viewMat=(()=>(new P.k).lookAt({eye:[1,1,1]}))();shaderInputs=(()=>new y.l({app:Y}))();constructor(e){let{device:t}=e;super();const n=function(e){const t=1/e,n=new Float32Array(e**3*3);let i=0,r=-.5;for(let o=0;o<e;++o){let o=-.5;for(let s=0;s<e;++s){let s=-.5;for(let a=0;a<e;++a)n[i++]=r,n[i++]=o,n[i++]=s,s+=t;o+=t}r+=t}return n}(128),i=t.createBuffer(n),r=function(e){const t=function(e){if("object"!=typeof e)throw new TypeError("params is not an object");if("function"!=typeof e.interpolation)throw new TypeError("params.interpolation is not a function");if(!Array.isArray(e.permutation))throw new TypeError("params.permutation is not an array");if(256!=e.permutation.length)throw new Error("params.permutation must have 256 items");for(var t=e.interpolation,n=e.permutation.slice(0),i=0;i<256;i++)n[256+i]=n[i];return function(e,i,r){var o=Math.floor(e),s=Math.floor(i),a=Math.floor(r),l=255&o,c=255&s,u=255&a;i-=s,r-=a;var d=V(e-=o),f=V(i),_=V(r),h=n[l]+c,p=n[h]+u,m=n[h+1]+u,g=n[l+1]+c,E=n[g]+u,A=n[g+1]+u;return t(t(t(k(n[p],e,i,r),k(n[E],e-1,i,r),d),t(k(n[m],e,i-1,r),k(n[A],e-1,i-1,r),d),f),t(t(k(n[p+1],e,i,r-1),k(n[E+1],e-1,i,r-1),d),t(k(n[m+1],e,i-1,r-1),k(n[A+1],e-1,i-1,r-1),d),f),_)}}({interpolation:G,permutation:X(H(0,255),W)}),n=.07*e,i=new Uint8Array(e**3);let r=0;for(let o=0;o<e;++o)for(let s=0;s<e;++s)for(let a=0;a<e;++a){const e=t(o/n,s/n,a/n);i[r++]=255*(.5+.5*e)}return i}(16);this.texture3d=t.createTexture({dimension:"3d",data:r,width:16,height:16,depth:16,format:"r8unorm",mipmaps:!0,sampler:{magFilter:"nearest",minFilter:"nearest",mipmapFilter:"nearest"}}),this.cloud=new _.K(t,{vs:"#version 300 es\nin vec3 position;\n\nuniform appUniforms {\n  mat4 mvpMatrix;\n  float time;\n} app;\n\nout vec3 vUVW;\nvoid main() {\n  vUVW = position.xyz + 0.5;\n  gl_Position = app.mvpMatrix * vec4(position, 1.0);\n  gl_PointSize = 2.0;\n}",fs:"#version 300 es\nprecision highp float;\nprecision lowp sampler3D;\n\nuniform appUniforms {\n  mat4 mvpMatrix;\n  float time;\n} app;\n\nuniform sampler3D uTexture;\n\nin vec3 vUVW;\nout vec4 fragColor;\n\nvoid main() {\n  vec4 sampleColor = texture(uTexture, vUVW + vec3(0.0, 0.0, app.time));\n  float alpha = sampleColor.r * 0.1;\n  fragColor = vec4(fract(vUVW) * alpha, alpha);\n}",topology:"point-list",vertexCount:n.length/3,bufferLayout:[{name:"position",format:"float32x3"}],attributes:{position:i},bindings:{uTexture:this.texture3d},shaderInputs:this.shaderInputs,parameters:{depthWriteEnabled:!0,depthCompare:"less-equal",blend:!0,blendColorOperation:"add",blendAlphaOperation:"add",blendColorSrcFactor:"one",blendColorDstFactor:"one-minus-src-color",blendAlphaSrcFactor:"one",blendAlphaDstFactor:"one-minus-src-alpha"}})}onFinalize(){this.cloud.destroy()}onRender(e){let{device:t,tick:n,aspect:i}=e;this.mvpMatrix.perspective({fovy:(0,x.F2)(75),aspect:i,near:.1,far:10}).multiplyRight(this.viewMat),this.shaderInputs.setProps({app:{time:n/100,mvpMatrix:this.mvpMatrix}}),this.cloud.updateShaderInputs();const r=t.beginRenderPass({clearColor:[0,0,0,1],clearDepth:!0});this.cloud.draw(r),r.end()}}const K=-1,j="precision highp float;\nprecision highp int;\n\nuniform pickingUniforms {\n  int isActive;\n  int indexMode;\n  int batchIndex;\n\n  int isHighlightActive;\n  int highlightedBatchIndex;\n  int highlightedObjectIndex;\n  vec4 highlightColor;\n} picking;\n";const Q={...{props:{},uniforms:{},name:"picking",uniformTypes:{isActive:"i32",indexMode:"i32",batchIndex:"i32",isHighlightActive:"i32",highlightedBatchIndex:"i32",highlightedObjectIndex:"i32",highlightColor:"vec4<f32>"},defaultUniforms:{isActive:!1,indexMode:0,batchIndex:0,isHighlightActive:!0,highlightedBatchIndex:K,highlightedObjectIndex:K,highlightColor:[0,1,1,1]},getUniforms:function(e,t){void 0===e&&(e={});const n={...t};switch(void 0!==e.isActive&&(n.isActive=Boolean(e.isActive)),e.indexMode){case"instance":n.indexMode=0;break;case"custom":n.indexMode=1}switch(e.highlightedObjectIndex){case void 0:break;case null:n.isHighlightActive=!1,n.highlightedObjectIndex=K;break;default:n.isHighlightActive=!0,n.highlightedObjectIndex=e.highlightedObjectIndex}return"number"==typeof e.highlightedBatchIndex&&(n.highlightedBatchIndex=e.highlightedBatchIndex),e.highlightColor&&(n.highlightColor=e.highlightColor),n}},name:"picking",source:"struct pickingUniforms {\n  isActive: int32;\n  indexMode: int32;\n  batchIndex: int32;\n\n  isHighlightActive: int32;\n  highlightedBatchIndex: int32;\n  highlightedObjectIndex: int32;\n  highlightColor: vec4<f32>;\n} picking;\n\n\nconst INDEX_PICKING_MODE_INSTANCE = 0;\nconst INDEX_PICKING_MODE_CUSTOM = 1;\nconst INDEX_PICKING_INVALID_INDEX = -1; // 2^32 - 1\n\nstruct indexPickingFragmentInputs = {\n  objectIndex: int32;\n};\n\nlet indexPickingFragmentInputs: indexPickingFragmentInputs;\n\n/**\n * Vertex shaders should call this function to set the object index.\n * If using instance or vertex mode, argument will be ignored, 0 can be supplied.\n */\nfn picking_setObjectIndex(objectIndex: int32) {\n  switch (picking.indexMode) {\n    case INDEX_PICKING_MODE_INSTANCE, default: {\n      picking_objectIndex = instance_index;\n    };\n    case INDEX_PICKING_MODE_CUSTOM: {\n      picking_objectIndex = objectIndex;\n    };\n  }\n}\n\n",vs:`${j}\n\nconst int INDEX_PICKING_MODE_INSTANCE = 0;\nconst int INDEX_PICKING_MODE_CUSTOM = 1;\n\nconst int INDEX_PICKING_INVALID_INDEX = -1; // 2^32 - 1\n\nflat out int picking_objectIndex;\n\n/**\n * Vertex shaders should call this function to set the object index.\n * If using instance or vertex mode, argument will be ignored, 0 can be supplied.\n */\nvoid picking_setObjectIndex(int objectIndex) {\n  switch (picking.indexMode) {\n    case INDEX_PICKING_MODE_INSTANCE:\n      picking_objectIndex = gl_InstanceID;\n      break;\n    case INDEX_PICKING_MODE_CUSTOM:\n      picking_objectIndex = objectIndex;\n      break;\n  }\n}\n`,fs:`${j}\n\nconst int INDEX_PICKING_INVALID_INDEX = -1; // 2^32 - 1\n\nflat in int picking_objectIndex;\n\n/**\n * Check if this vertex is highlighted (part of the selected batch and object)\n */ \nbool picking_isFragmentHighlighted() {\n  return \n    bool(picking.isHighlightActive) &&\n    picking.highlightedBatchIndex == picking.batchIndex &&\n    picking.highlightedObjectIndex == picking_objectIndex\n    ;\n}\n\n/**\n * Returns highlight color if this item is selected.\n */\nvec4 picking_filterHighlightColor(vec4 color) {\n  // If we are still picking, we don't highlight\n  if (bool(picking.isActive)) {\n    return color;\n  }\n\n  // If we are not highlighted, return color as is\n  if (!picking_isFragmentHighlighted()) {\n    return color;\n  }\n   \n  // Blend in highlight color based on its alpha value\n  float highLightAlpha = picking.highlightColor.a;\n  float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n  float highLightRatio = highLightAlpha / blendedAlpha;\n\n  vec3 blendedRGB = mix(color.rgb, picking.highlightColor.rgb, highLightRatio);\n  return vec4(blendedRGB, blendedAlpha);\n}\n\n/*\n * Returns picking color if picking enabled else unmodified argument.\n */\nivec4 picking_getPickingColor() {\n  // Assumes that colorAttachment0 is rg32int\n  // TODO? - we could render indices into a second color attachment and not mess with fragColor\n  return ivec4(picking_objectIndex, picking.batchIndex, 0u, 0u);  \n}\n\nvec4 picking_filterPickingColor(vec4 color) {\n  if (bool(picking.isActive)) {\n    if (picking_objectIndex == INDEX_PICKING_INVALID_INDEX) {\n      discard;\n    }\n  }\n  return color;\n}\n\n/*\n * Returns picking color if picking is enabled if not\n * highlight color if this item is selected, otherwise unmodified argument.\n */\nvec4 picking_filterColor(vec4 color) {\n  vec4 outColor = color;\n  outColor = picking_filterHighlightColor(outColor);\n  outColor = picking_filterPickingColor(outColor);\n  return outColor;\n}\n`};class ${pickInfo={batchIndex:null,objectIndex:null};framebuffer=null;static defaultProps={shaderInputs:void 0,onObjectPicked:()=>{}};constructor(e,t){this.device=e,this.props={...$.defaultProps,...t}}destroy(){this.framebuffer?.destroy()}getFramebuffer(){return this.framebuffer||(this.framebuffer=this.device.createFramebuffer({colorAttachments:["rgba8unorm","rg32sint"],depthStencilAttachment:"depth24plus"})),this.framebuffer}clearPickState(){this.props.shaderInputs.setProps({picking:{highlightedObjectIndex:null}})}beginRenderPass(){const e=this.getFramebuffer();e.resize(this.device.getDefaultCanvasContext().getPixelSize()),this.props.shaderInputs?.setProps({picking:{isActive:!0}});return this.device.beginRenderPass({framebuffer:e,clearColors:[new Float32Array([0,0,0,0]),new Int32Array([-1,-1,0,0])],clearDepth:!0})}getPickInfo(e){const t=this.getFramebuffer(),[n,i]=this.getPickPosition(e),r=this.device.readPixelsToArrayWebGL(t,{sourceX:n,sourceY:i,sourceWidth:1,sourceHeight:1,sourceAttachment:1});if(!r)return null;const o={objectIndex:r[0]===K?null:r[0],batchIndex:r[1]===K?null:r[1]};return o.objectIndex===this.pickInfo.objectIndex&&o.batchIndex===this.pickInfo.batchIndex||(this.pickInfo=o,this.props.onObjectPicked(o)),this.props.shaderInputs?.setProps({picking:{isActive:!1,highlightedBatchIndex:o.batchIndex,highlightedObjectIndex:o.objectIndex}}),this.pickInfo}getPickPosition(e){const t=this.device.getDefaultCanvasContext().cssToDevicePixels(e);return[t.x+Math.floor(t.width/2),t.y+Math.floor(t.height/2)]}}const q=a(),Z=256;class J extends _.K{constructor(e,t){const n=[];for(let c=0;c<Z;c++){const e=3*c-382.5;for(let t=0;t<Z;t++){const i=3*t-382.5;n.push(e,i)}}const i=new Float32Array(n),r=new Uint8Array(262144).map(((e,t)=>255*(.75*q()+.25)));for(let c=0;c<r.length;c+=4)r[c+3]=255;const o=new Int32Array(65536).fill(0).map(((e,t)=>t)),s=e.createBuffer(i),a=e.createBuffer(r),l=e.createBuffer(o);super(e,{...t,source:"\n// APPLICATION\n\nstruct AppUniforms {\n  modelMatrix: mat4x4<f32>,\n  viewMatrix: mat4x4<f32>,\n  projectionMatrix: mat4x4<f32>,\n  time: f32,\n};\n\n@group(0) @binding(0) var<uniform> app : AppUniforms;\n\nstruct VertexInputs {\n  // CUBE GEOMETRY\n  @location(0) positions : vec4<f32>,\n  @location(1) normals : vec3<f32>,\n  // INSTANCED ATTRIBUTES\n  @location(2) instanceOffsets : vec2<f32>,\n  @location(3) instanceColors : vec4<f32>,\n  @location(4) instanceIndexes : vec2<f32>,\n}\n\nstruct FragmentInputs {\n  @builtin(position) Position : vec4<f32>,\n  @location(0) normal : vec3<f32>,\n  @location(1) color : vec4<f32>,\n}\n\n@vertex\nfn vertexMain(inputs: VertexInputs) -> FragmentInputs {\n  var outputs: FragmentInputs;\n\n  // Vertex position (z coordinate undulates with time), and model rotates around center\n  let delta = length(inputs.instanceOffsets);\n  let offset = vec4<f32>(inputs.instanceOffsets, sin((app.time + delta) * 0.1) * 16.0, 0);\n  outputs.Position = app.projectionMatrix * app.viewMatrix * (app.modelMatrix * inputs.positions + offset);\n  \n  outputs.normal = dirlight_setNormal((app.modelMatrix * vec4<f32>(inputs.normals, 0.0)).xyz);\n  outputs.color = inputs.instanceColors;\n\n  // vec4 pickColor = vec4(0., instanceIndexes, 1.0);\n  picking_setPickingColor(0);\n  \n  return outputs;\n}\n\n@fragment\nfn fragmentMain(inputs: FragmentInputs) -> @location(0) vec4<f32> {\n  var fragColor = inputs.color; \n  fragColor = dirlight_filterColor(fragColor, DirlightInputs(inputs.normal)); \n  return fragColor;\n}\n",vs:"#version 300 es\nprecision highp float;\nprecision highp int;\n\nin vec3 positions;\nin vec3 normals;\n\nin vec2 instanceOffsets;\nin vec3 instanceColors;\nin int instanceIndexes;\n\nuniform appUniforms {\n  mat4 modelMatrix;\n  mat4 viewMatrix;\n  mat4 projectionMatrix;\n  float time;\n} app;\n\nout vec3 color;\n\nvoid main(void) {\n  color = instanceColors;\n\n  vec3 normal = vec3(app.modelMatrix * vec4(normals, 1.0));\n  dirlight_setNormal(normal);\n  picking_setObjectIndex(instanceIndexes);\n\n  // Vertex position (z coordinate undulates with time), and model rotates around center\n  float delta = length(instanceOffsets);\n  vec4 offset = vec4(instanceOffsets, sin((app.time + delta) * 0.1) * 16.0, 0);\n  gl_Position = app.projectionMatrix * app.viewMatrix * (app.modelMatrix * vec4(positions * 1., 1.0) + offset);\n}\n",fs:"#version 300 es\nprecision highp float;\nprecision highp int;\n\nin vec3 color;\nlayout(location=0) out vec4 fragColor;\nlayout(location=1) out ivec4 pickingColor;\n\nvoid main(void) {\n  pickingColor = picking_getPickingColor();\n\n  fragColor = vec4(color, 1.);\n  fragColor = dirlight_filterColor(fragColor);\n  fragColor = picking_filterColor(fragColor);\n}\n",modules:"webgpu"!==e.info.type?[I,Q]:[I],instanceCount:65536,geometry:new m({indices:!0}),bufferLayout:[{name:"instanceOffsets",format:"float32x2"},{name:"instanceColors",format:"unorm8x4"},{name:"instanceIndexes",format:"sint32"}],attributes:{instanceOffsets:s,instanceColors:a,instanceIndexes:l},parameters:{depthWriteEnabled:!0,depthCompare:"less-equal"}})}}const ee={name:"app",uniformTypes:{modelMatrix:"mat4x4<f32>",viewMatrix:"mat4x4<f32>",projectionMatrix:"mat4x4<f32>",time:"f32"}};class te extends l{static info="\n<p>\nCube drawn with <b>instanced rendering</b>.\n<p>\nA luma.gl <code>Cube</code>, rendering 65,536 instances in a\nsingle GPU draw call using instanced vertex attributes.\n";static props={createFramebuffer:!0,debug:!0};shaderInputs=(()=>new y.l({app:ee,dirlight:I,picking:Q}))();constructor(e){let{device:t,animationLoop:n}=e;super(),this.timeline=new d,n.attachTimeline(this.timeline),this.timeline.play(),this.timelineChannels={timeChannel:this.timeline.addChannel({rate:.01}),eyeXChannel:this.timeline.addChannel({rate:3e-4}),eyeYChannel:this.timeline.addChannel({rate:4e-4}),eyeZChannel:this.timeline.addChannel({rate:2e-4})},this.cube=new J(t,{shaderInputs:this.shaderInputs}),this.picker=new $(t,{shaderInputs:this.shaderInputs})}onRender(e){const{device:t,aspect:n,tick:i}=e,{_mousePosition:r}=e,{timeChannel:o,eyeXChannel:s,eyeYChannel:a,eyeZChannel:l}=this.timelineChannels;this.shaderInputs.setProps({app:{time:this.timeline.getTime(o),projectionMatrix:(new P.k).perspective({fovy:(0,x.F2)(60),aspect:n,near:1,far:2048}),viewMatrix:(new P.k).lookAt({center:[0,0,0],eye:[Math.cos(this.timeline.getTime(s))*Z/2,Math.sin(this.timeline.getTime(a))*Z/2,(Math.sin(this.timeline.getTime(l))+1)*Z/4+32]}),modelMatrix:(new P.k).rotateX(.01*i).rotateY(.013*i)}}),this.pickInstance(r);const c=t.beginRenderPass({clearColor:[0,0,0,1],clearDepth:!0});this.cube.draw(c),c.end()}onFinalize(e){this.cube.destroy()}pickInstance(e){if("webgl"!==this.picker.device.type)return;if(!e)return void this.picker.clearPickState();const t=this.picker.beginRenderPass();this.cube.draw(t),t.end(),this.picker.getPickInfo(e)}}const ne="struct VertexInput {\n  aClipSpacePosition: vec2<f32>;\n  aTexCoord: vec2<f32>;\n  aCoordinate: vec2<f32>;  \n}\n\nstruct FragmentInput {\n  @builtin(position) Position : vec4<f32>;\n  @location(0) position : vec2<f32>;\n  @location(1) coordinate : vec2<f32>;\n  @location(2) uv : vec2<f32>;\n};\n\n@stage(vertex)\nfn vertexMain(input: VertexInput) -> FragmentInput {\n  var output: FragmentInput;\n  output.Position = vec4(aClipSpacePosition, 0., 1.);\n  output.position = input.aClipSpacePosition;\n  output.coordinate = input.aCoordinate;\n  output.uv = aTexCoord;\n}\n",ie=[-1,-1,1,-1,-1,1,1,1];class re extends _.K{constructor(e,t){const n=ie.map((e=>-1===e?0:e));t.source&&(t={...t,source:`${ne}m${t.source}`}),super(e,{...t,source:ne,vs:"#version 300 es\nin vec2 aClipSpacePosition;\nin vec2 aTexCoord;\nin vec2 aCoordinate;\n\nout vec2 position;\nout vec2 coordinate;\nout vec2 uv;\n\nvoid main(void) {\n  gl_Position = vec4(aClipSpacePosition, 0., 1.);\n  position = aClipSpacePosition;\n  coordinate = aCoordinate;\n  uv = aTexCoord;\n}\n",vertexCount:4,geometry:new h.V({topology:"triangle-strip",vertexCount:4,attributes:{aClipSpacePosition:{size:2,value:new Float32Array(ie)},aTexCoord:{size:2,value:new Float32Array(n)},aCoordinate:{size:2,value:new Float32Array(n)}}})})}}class oe extends re{constructor(e,t){super(e,{id:t.id||"background-texture-model",fs:"#version 300 es\n\nprecision highp float;\nuniform sampler2D backgroundTexture;\nout vec4 fragColor;\n\nvec2 billboardTexture_getTextureUV() {\n  ivec2 iTexSize = textureSize(backgroundTexture, 0) * 2;\n  vec2 texSize = vec2(float(iTexSize.x), float(iTexSize.y));\n  vec2 position = gl_FragCoord.xy / texSize;\n  return position;\n}\n\nvoid main(void) {\n  vec2 position = billboardTexture_getTextureUV();\n  fragColor = texture(backgroundTexture, position);\n}\n",parameters:{depthWriteEnabled:!1,depthCompare:"always",...t.blend?{blend:!0,blendColorOperation:"add",blendAlphaOperation:"add",blendColorSrcFactor:"one",blendColorDstFactor:"one-minus-src-color",blendAlphaSrcFactor:"one",blendAlphaDstFactor:"one-minus-src-alpha"}:{}}}),this.setTexture(t.backgroundTexture)}setTexture(e){this.setBindings({backgroundTexture:e})}predraw(){this.shaderInputs.setProps({}),super.predraw()}}class se extends h.V{constructor(e){void 0===e&&(e={});const{id:t=(0,p.L)("sphere-geometry")}=e,{indices:n,attributes:i}=function(e){const{nlat:t=10,nlong:n=10}=e,i=0,r=Math.PI-i,o=0,s=2*Math.PI-o,a=(t+1)*(n+1),l=(t,n,i,r,o)=>e.radius||1,c=new Float32Array(3*a),u=new Float32Array(3*a),d=new Float32Array(2*a),f=new(a>65535?Uint32Array:Uint16Array)(t*n*6);for(let h=0;h<=t;h++)for(let e=0;e<=n;e++){const i=e/n,o=h/t,a=e+h*(n+1),f=2*a,_=3*a,p=s*i,m=r*o,g=Math.sin(p),E=Math.cos(p),A=Math.sin(m),v=E*A,T=Math.cos(m),R=g*A,b=l(v,T,R,i,o);c[_+0]=b*v,c[_+1]=b*T,c[_+2]=b*R,u[_+0]=v,u[_+1]=T,u[_+2]=R,d[f+0]=i,d[f+1]=1-o}const _=n+1;for(let h=0;h<n;h++)for(let e=0;e<t;e++){const n=6*(h*t+e);f[n+0]=e*_+h,f[n+1]=e*_+h+1,f[n+2]=(e+1)*_+h,f[n+3]=(e+1)*_+h,f[n+4]=e*_+h+1,f[n+5]=(e+1)*_+h+1}return{indices:{size:1,value:f},attributes:{POSITION:{size:3,value:c},NORMAL:{size:3,value:u},TEXCOORD_0:{size:2,value:d}}}}(e);super({...e,id:t,topology:"triangle-list",indices:n,attributes:{...i,...e.attributes}})}}var ae=n(7909);const le={uniformTypes:{color:"vec3<f32>",lighting:"f32",modelViewMatrix:"mat4x4<f32>",projectionMatrix:"mat4x3<f32>"}},ce="#version 300 es\n\nstruct VertexInputs {\n  positions: vec3<f32>;\n  normals: vec3<f32>;\n}\n\nstruct FragmentInputs {\n  @builtin(position) position: vec4<f32>;\n  normal: vec3<f32>;\n}\n\nuniform sphereUniforms {\n  // fragment shader\n  color: vec3<f32>;\n  lighting: bool;\n  // vertex shader\n  modelViewMatrix: mat4<f32>;\n  projectionMatrix: mat4<f32>;\n} sphere;\n\n@vertex\nfn vertexMain(inputs: VertexInputs) -> FragmentInputs {\n  const outputs: VertexOutputs;\n  gl_Position = sphere.projectionMatrix * sphere.modelViewMatrix * vec4(inputs.positions, 1.0);\n  outputs.normal = vec3((sphere.modelViewMatrix * vec4(inputs.normals, 0.0)));\n  return outputs;\n}\n\n@fragment\nfn fragmentMain(inputs: FragmentInputs) -> [[location(0)]] vec4<f32> {\n  let attenuation = 1.0;\n  if (sphere.lighting) {\n    light = normalize(vec3(1,1,2));\n    attenuation = dot(normal, light);\n  }\n  return vec4(sphere.color * attenuation, 1);\n}\n",ue="#version 300 es\n\nin vec3 positions;\nin vec3 normals;\n\nuniform sphereUniforms {\n  // fragment shader\n  vec3 color;\n  bool lighting;\n  // vertex shader\n  mat4 modelViewMatrix;\n  mat4 projectionMatrix;\n} sphere;\n\nout vec3 normal;\n\nvoid main(void) {\n  gl_Position = sphere.projectionMatrix * sphere.modelViewMatrix * vec4(positions, 1.0);\n  normal = vec3((sphere.modelViewMatrix * vec4(normals, 0.0)));\n}\n",de="#version 300 es\n\nprecision highp float;\n\nuniform sphereUniforms {\n  // fragment\n  vec3 color;\n  bool lighting;\n  // vertex\n  mat4 modelViewMatrix;\n  mat4 projectionMatrix;\n} sphere;\n\nin vec3 normal;\nout vec4 fragColor;\n\nvoid main(void) {\n  float attenuation = 1.0;\n  if (sphere.lighting) {\n    vec3 light = normalize(vec3(1,1,2));\n    attenuation = dot(normal, light);\n  }\n  fragColor = vec4(sphere.color * attenuation, 1);\n}\n",fe={uniformTypes:{resolution:"vec2<f32>"}},_e="fn getQuadVertex(vertexIndex : u32) -> vec2f {\n  // SCREEN QUAD\n  let positions = array(\n    // 1st triangle\n    vec2f( 0.0,  0.0),  // center\n    vec2f( 1.0,  0.0),  // right, center\n    vec2f( 0.0,  1.0),  // center, top\n    // 2st triangle\n    vec2f( 0.0,  1.0),  // center, top\n    vec2f( 1.0,  0.0),  // right, center\n    vec2f( 1.0,  1.0),  // right, top\n  );\n  return positions[vertexIndex];\n}\n",he=`\n${_e}\n\nstruct FragmentInputs {\n  @builtin(position) position: vec4f,\n  @location(0) texcoord: vec2f,\n};\n\n@vertex fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> FragmentInputs {\n  var outputs: FragmentInputs;\n  let xy = getQuadVertex(vertexIndex);\n  outputs.position = vec4f(xy, 0.0, 1.0);\n  outputs.texcoord = xy;\n  return outputs;\n}\n\n@group(0) @binding(0) var texture : texture_2d<f32>;\n@group(0) @binding(1) var sampler : sampler;\n\n@fragment fn fragmentMain(inputs: FragmentInputs) -> @location(0) vec4f {\n  return textureSample(texture, sampler, inputs.texcoord);\n}\n`,pe="#version 300 es\n\nin vec2 aPosition;\n\nvoid main(void) {\n  gl_Position = vec4(aPosition, 0, 1);\n}\n",me={uniformTypes:{resolution:"vec2<f32>"}},ge=`\n${_e}\n\nstruct FragmentInputs {\n  @builtin(position) position: vec4f,\n  @location(0) texcoord: vec2f,\n};\n\n@vertex fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> FragmentInputs {\n  var outputs: FragmentInputs;\n  let xy = getQuadVertex(vertexIndex);\n  outputs.position = vec4f(xy, 0.0, 1.0);\n  outputs.texcoord = xy;\n  return outputs;\n}\n\n@group(0) @binding(0) var sceneTexture : texture_2d<f32>;\n@group(0) @binding(1) var persistenceTexture : texture_2d<f32>;\n@group(0) @binding(2) var sampler : sampler;\n\n@fragment \nfn fragmentMain(inputs: FragmentInputs) -> @location(0) vec4f {\n  let sceneColor = textureSample(sceneTexture, sampler, inputs.texcoord);\n  let persistenceColor = textureSample(persistenceTexture, sampler, inputs.texcoord);\n  return mix(sceneColor * 4.0, persistenceColor, 0.9);\n}\n`,Ee=a(),Ae=[],ve=[],Te=[];class Re extends l{static info="\n<p>\n  Electron trails renderings persist across multiple frames.\n<p>\n  Uses multiple luma.gl <code>Framebuffer</code>s to hold previously rendered data between frames.\n</p>\n";uniformStore=(()=>new s.K({sphere:le,screenQuad:fe,persistenceQuad:me}))();constructor(e){let{device:t,width:n,height:i}=e;super(),this.backgroundTextureModel=new oe(t,{backgroundTexture:new M.i(t,{data:(0,O.Dt)("background.png")}),blend:!0}),this.electron=new _.K(t,{id:"electron",source:ce,vs:ue,fs:de,geometry:new se({nlat:20,nlong:30}),bindings:{sphere:this.uniformStore.getManagedUniformBuffer(t,"sphere")},parameters:{depthWriteEnabled:!0,depthCompare:"less",cullMode:"back"}}),this.nucleon=new _.K(t,{id:"nucleon",source:ce,vs:ue,fs:de,geometry:new se({nlat:20,nlong:30}),parameters:{depthWriteEnabled:!0,depthCompare:"less-equal",cullMode:"back"},bindings:{sphere:this.uniformStore.getManagedUniformBuffer(t,"sphere")}}),this.mainFramebuffer=t.createFramebuffer({width:n,height:i,colorAttachments:["rgba8unorm"],depthStencilAttachment:"depth24plus"}),this.pingpongFramebuffers=[t.createFramebuffer({width:n,height:i,colorAttachments:["rgba8unorm"],depthStencilAttachment:"depth24plus"}),t.createFramebuffer({width:n,height:i,colorAttachments:["rgba8unorm"],depthStencilAttachment:"depth24plus"})];const r=new h.V({topology:"triangle-list",attributes:{aPosition:{value:new Float32Array([-1,-1,1,-1,1,1,-1,-1,1,1,-1,1]),size:2}},vertexCount:6});this.screenQuad=new _.K(t,{id:"quad",source:he,vs:pe,fs:"#version 300 es\n\nprecision highp float;\n\nuniform sampler2D uTexture;\n\nuniform screenQuadUniforms {\n  vec2 resolution;\n} screenQuad;\n\nout vec4 fragColor;\n\nvoid main(void) {\n  vec2 p = gl_FragCoord.xy/screenQuad.resolution.xy;\n  fragColor = texture(uTexture, p);\n}\n",geometry:r,bindings:{screenQuad:this.uniformStore.getManagedUniformBuffer(t,"screenQuad")},parameters:{depthWriteEnabled:!0,depthCompare:"less-equal",cullMode:"back"}}),this.persistenceQuad=new _.K(t,{id:"persistence-quad",source:ge,vs:pe,fs:"#version 300 es\n\nprecision highp float;\n\nuniform sampler2D uScene;\nuniform sampler2D uPersistence;\n\nuniform persistenceQuadUniforms {\n  vec2 resolution;\n} persistence;\n\nout vec4 fragColor;\n\nvoid main(void) {\n  vec2 p = gl_FragCoord.xy / persistence.resolution.xy;\n  vec4 cS = texture(uScene, p);\n  vec4 cP = texture(uPersistence, p);\n  fragColor = mix(cS*4.0, cP, 0.9);\n}\n",geometry:r,bindings:{persistenceQuad:this.uniformStore.getManagedUniformBuffer(t,"persistenceQuad")},parameters:{depthWriteEnabled:!0,depthCompare:"less-equal",cullMode:"back"}});for(let o=0;o<64;o++){const e=new ae.P(Ee()-.5,Ee()-.5,Ee()-.5),t=Ee()+1;e.normalize().scale(t);const n=1.25;e.scale(n),Ae.push(e);const i=new ae.P(Ee()-.5,Ee()-.5,Ee()-.5),r=e.clone().cross(i).normalize(),o=4/t*.0125,s=(new P.k).rotateAxis(o,r);ve.push(s)}for(let o=0;o<64;o++){let e=new ae.P(Ee()-.5,Ee()-.5,Ee()-.5);e=e.normalize().scale(.5),Te.push(e)}}onFinalize(e){this.electron.destroy(),this.nucleon.destroy(),this.mainFramebuffer.destroy(),this.pingpongFramebuffers[0].destroy(),this.pingpongFramebuffers[1].destroy(),this.screenQuad.destroy(),this.persistenceQuad.destroy()}onRender(e){let{device:t,tick:n,width:i,height:r,aspect:o}=e;this.mainFramebuffer.resize({width:i,height:r}),this.pingpongFramebuffers[0].resize({width:i,height:r}),this.pingpongFramebuffers[1].resize({width:i,height:r});const s=(new P.k).perspective({fovy:(0,x.F2)(75),aspect:o}),a=(new P.k).lookAt({eye:[0,0,4]}),l=t.beginRenderPass({framebuffer:this.mainFramebuffer,clearColor:[0,0,0,0],clearDepth:!0});this.uniformStore.setUniforms({sphere:{color:[0,.5,1],lighting:!1}});for(let h=0;h<64;h++){Ae[h]=ve[h].transformVector(Ae[h]);const e=(new P.k).translate(Ae[h]).scale([.06125,.06125,.06125]);this.uniformStore.setUniforms({sphere:{modelViewMatrix:a.clone().multiplyRight(e),projectionMatrix:s}}),this.uniformStore.updateUniformBuffers(),this.electron.draw(l)}this.uniformStore.setUniforms({sphere:{color:[1,.25,.25],lighting:!0}});for(let h=0;h<64;h++){const e=(new P.k).rotateXYZ([.013*n,0,0]).rotateXYZ([0,.021*n,0]).translate(Te[h]),t=[e[12],e[13],e[14]];e.identity().translate(t).scale([.25,.25,.25]),this.uniformStore.setUniforms({sphere:{modelViewMatrix:a.clone().multiplyRight(e),projectionMatrix:s}}),this.uniformStore.updateUniformBuffers(),this.nucleon.draw(l)}l.end();const c=n%2,u=this.pingpongFramebuffers[c],d=this.pingpongFramebuffers[1-c],f=t.beginRenderPass({framebuffer:u,clearColor:[0,0,0,0]});this.persistenceQuad.setBindings({uScene:this.mainFramebuffer.colorAttachments[0],uPersistence:d.colorAttachments[0]}),this.uniformStore.setUniforms({persistenceQuad:{resolution:[i,r]}}),this.uniformStore.updateUniformBuffers(),this.persistenceQuad.draw(f),f.end();const _=t.beginRenderPass({clearColor:[0,0,0,1]});this.screenQuad.setBindings({uTexture:u.colorAttachments[0]}),this.uniformStore.setUniforms({screenQuad:{resolution:[i,r]}}),this.uniformStore.updateUniformBuffers(),this.screenQuad.draw(_),this.backgroundTextureModel.draw(_),_.end()}}var be=n(2375);class Se{constructor(e){this.current=e.current,this.next=e.next}destroy(){this.current?.destroy(),this.next?.destroy()}swap(){const e=this.current;this.current=this.next,this.next=e}}class Ce extends Se{constructor(e,t){super({current:e.createFramebuffer(t),next:e.createFramebuffer(t)})}resize(e){if(e.width===this.current.width&&e.height===this.current.height)return!1;const{current:t,next:n}=this;return this.current=t.clone(e),t.destroy(),this.next=n.clone(e),n.destroy(),!0}}class Ie{constructor(e,t){this.device=e,t.shaderPasses.map((e=>(0,be.UK)(e)));const n=t.shaderPasses.reduce(((e,t)=>({...e,[t.name]:t})),{});this.shaderInputs=t.shaderInputs||new y.l(n);const i=e.getCanvasContext().getPixelSize();this.swapFramebuffers=new Ce(e,{colorAttachments:["rgba8unorm"],width:i[0],height:i[1]}),this.textureModel=new oe(e,{backgroundTexture:this.swapFramebuffers.current.colorAttachments[0].texture}),this.clipSpace=new re(e,{fs:"#version 300 es\n\nuniform sampler2D sourceTexture;\nin vec2 uv;\nin vec2 coordinate;\nout vec4 fragColor;\n\nvoid main() {\n  vec2 texCoord = coordinate;\n  fragColor = texture(sourceTexture, coordinate);\n}\n"}),this.passRenderers=t.shaderPasses.map((t=>new Pe(e,t)))}destroy(){for(const e of this.passRenderers)e.destroy();this.swapFramebuffers.destroy(),this.clipSpace.destroy()}resize(e,t){this.swapFramebuffers.resize({width:e,height:t})}renderToScreen(e){const t=this.renderToTexture(e);if(!t)return!1;const n=this.device.beginRenderPass({clearColor:[0,0,0,1],clearDepth:1});return this.clipSpace.setBindings({sourceTexture:t}),this.clipSpace.draw(n),n.end(),!0}renderToTexture(e){const{sourceTexture:t}=e;if(!t.isReady)return null;this.textureModel.destroy(),this.textureModel=new oe(this.device,{backgroundTexture:t});const n=this.device.beginRenderPass({framebuffer:this.swapFramebuffers.current,clearColor:[0,0,0,1]});this.textureModel.draw(n),n.end();let i=!0;for(const r of this.passRenderers)for(const e of r.subPassRenderers){i||this.swapFramebuffers.swap(),i=!1;const t={sourceTexture:this.swapFramebuffers.current.colorAttachments[0].texture},n=this.device.beginRenderPass({framebuffer:this.swapFramebuffers.next,clearColor:[0,0,0,1],clearDepth:!0});e.render({renderPass:n,bindings:t}),n.end()}this.swapFramebuffers.swap();return this.swapFramebuffers.current.colorAttachments[0].texture}}class Pe{constructor(e,t,n){void 0===n&&(n={}),this.shaderPass=t;const i=t.passes||[];this.subPassRenderers=i.map((n=>new xe(e,t,n)))}destroy(){for(const e of this.subPassRenderers)e.destroy()}}class xe{constructor(e,t,n){this.shaderPass=t,this.subPass=n;const i=function(e){const{shaderPass:t,action:n,shadingLanguage:i}=e;switch(n){case"filter":const e=`${t.name}_filterColor_ext`;return"wgsl"===i?`// Binding 0:1 is reserved for shader passes\n@group(0) @binding(0) var<uniform> brightnessContrast : brightnessContrastUniforms;\n@group(0) @binding(1) var texture: texture_2d<f32>;\n@group(0) @binding(2) var sampler: sampler;\n\nstruct FragmentInputs = {\n  @location(0) fragUV: vec2f,\n  @location(1) fragPosition: vec4f,\n  @location(2) fragCoordinate: vec4f\n};\n\n@fragment\nfn fragmentMain(inputs: FragmentInputs) -> @location(0) vec4f {\n  let texSize = textureDimensions(texture, 0);\n  var fragColor = textureSample(texture, sampler, fragUV);\n  fragColor = ${e}(gl_FragColor, texSize, texCoord);\n  return fragColor;\n}\n`:`#version 300 es\n\nuniform sampler2D sourceTexture;\n\nin vec2 position;\nin vec2 coordinate;\nin vec2 uv;\n\nout vec4 fragColor;\n\nvoid main() {\n  vec2 texCoord = coordinate;\n  ivec2 iTexSize = textureSize(sourceTexture, 0);\n  vec2 texSize = vec2(float(iTexSize.x), float(iTexSize.y));\n\n  fragColor = texture(sourceTexture, texCoord);\n  fragColor = ${e}(fragColor, texSize, texCoord);\n}\n`;case"sample":const n=`${t.name}_sampleColor`;return"wgsl"===i?function(e){return`// Binding 0:1 is reserved for shader passes\n@group(0) @binding(0) var<uniform> brightnessContrast : brightnessContrastUniforms;\n@group(0) @binding(1) var texture: texture_2d<f32>;\n@group(0) @binding(2) var sampler: sampler;\n\nstruct FragmentInputs = {\n  @location(0) fragUV: vec2f,\n  @location(1) fragPosition: vec4f,\n  @location(2) fragCoordinate: vec4f\n};\n\n@fragment\nfn fragmentMain(inputs: FragmentInputs) -> @location(0) vec4f {\n  let texSize = textureDimensions(texture, 0);\n  var fragColor = textureSample(texture, sampler, fragUV);\n  fragColor = ${e}(gl_FragColor, texSize, texCoord);\n  return fragColor;\n}\n`}(n):function(e){return`#version 300 es\n\nuniform sampler2D sourceTexture;\n\nin vec2 position;\nin vec2 coordinate;\nin vec2 uv;\n\nout vec4 fragColor;\n\nvoid main() {\n  vec2 texCoord = coordinate;\n  ivec2 iTexSize = textureSize(sourceTexture, 0);\n  vec2 texSize = vec2(float(iTexSize.x), float(iTexSize.y));\n\n  fragColor = ${e}(sourceTexture, texSize, texCoord);\n}\n`}(n);default:throw new Error(`${t.name} no fragment shader generated for shader pass`)}}({shaderPass:t,action:n.action||n.filter&&"filter"||n.sampler&&"sample"||"filter",shadingLanguage:e.info.shadingLanguage});this.model=new re(e,{id:`${t.name}-subpass`,source:i,fs:i,modules:[t],parameters:{depthWriteEnabled:!1,depthCompare:"always"}})}destroy(){this.model.destroy()}render(e){const{renderPass:t,bindings:n}=e;this.model.shaderInputs.setProps({[this.shaderPass.name]:this.shaderPass.uniforms||{}}),this.model.shaderInputs.setProps({[this.shaderPass.name]:this.subPass.uniforms||{}}),this.model.setBindings(n||{}),this.model.draw(t)}}var Ne=n(2558),Le=n(7611),Fe=n(6791),ye=n(5463);const Me="#version 300 es\nout vec4 transform_output;\nvoid main() {\n  transform_output = vec4(0);\n}";function Oe(e,t){t=Array.isArray(t)?t:[t];const n=e.replace(/^\s+/,"").split(/\s+/),[i,r,o]=n;if(!t.includes(i)||!r||!o)return null;return{qualifier:i,type:r,name:o.split(";")[0]}}function Be(e){const{input:t,inputChannels:n,output:i}=e||{};if(!t)return Me;if(!n)throw new Error("inputChannels");return`#version 300 es\nin ${function(e){switch(e){case 1:return"float";case 2:return"vec2";case 3:return"vec3";case 4:return"vec4";default:throw new Error(`invalid channels: ${e}`)}}(n)} ${t};\nout vec4 ${i};\nvoid main() {\n  ${i} = ${Ue(t,n)};\n}`}function De(e){switch(e){case"float":return"x";case"vec2":return"xy";case"vec3":return"xyz";case"vec4":return"xyzw";default:throw new Error(e)}}function we(e){switch(e){case"float":return 1;case"vec2":return 2;case"vec3":return 3;case"vec4":return 4;default:throw new Error(e)}}function Ue(e,t){switch(t){case 1:return`vec4(${e}, 0.0, 0.0, 1.0)`;case 2:return`vec4(${e}, 0.0, 1.0)`;case 3:return`vec4(${e}, 1.0)`;case 4:return e;default:throw new Error(`invalid channels: ${t}`)}}function Ge(e){return"string"==typeof e?e.charAt(0).toUpperCase()+e.slice(1):e}function He(e,t){return function(e,t){const n=[];switch(t.uniforms){case"scoped-interface-blocks":case"unscoped-interface-blocks":n.push(`uniform ${Ge(e.name)} {`)}for(const[i,r]of Object.entries(e.uniformTypes||{})){const o=Xe(r);switch(t.uniforms){case"scoped-interface-blocks":n.push(`  ${o} ${i};`);break;case"unscoped-interface-blocks":n.push(`  ${o} ${e.name}_${i};`);break;case"uniforms":n.push(`uniform ${o} ${e.name}_${i};`)}}switch(t.uniforms){case"scoped-interface-blocks":n.push(`} ${e.name};`);break;case"unscoped-interface-blocks":n.push("};")}return n.push(""),n.join("\n")}(e,t)}function Xe(e){return{f32:"float",i32:"int",u32:"uint","vec2<f32>":"vec2","vec3<f32>":"vec3","vec4<f32>":"vec4","vec2<i32>":"ivec2","vec3<i32>":"ivec3","vec4<i32>":"ivec4","vec2<u32>":"uvec2","vec3<u32>":"uvec3","vec4<u32>":"uvec4","mat2x2<f32>":"mat2","mat2x3<f32>":"mat2x3","mat2x4<f32>":"mat2x4","mat3x2<f32>":"mat3x2","mat3x3<f32>":"mat3","mat3x4<f32>":"mat3x4","mat4x2<f32>":"mat4x2","mat4x3<f32>":"mat4x3","mat4x4<f32>":"mat4"}[e]}function Ve(e,t){return function(e,t){const n=[];n.push(`struct ${Ge(e.name)} {`);for(const[i,r]of Object.entries(e?.uniformTypes||{})){const e=r;n.push(`  ${i} : ${e};`)}return n.push("};"),n.push(`var<uniform> ${e.name} : ${Ge(e.name)};`),n.join("\n")}(e)}function ke(e,t){switch(t.shaderLanguage){case"glsl":return He(e,t);case"wgsl":return Ve(e)}}var We=n(7234),Ye=n(9315),ze=n(1448);let Ke=null;const je=new ArrayBuffer(4),Qe=new Float32Array(je),$e=new Uint32Array(je);function qe(e){Ke||=Je(),e=(0,x.qE)(e,-65504,65504),Qe[0]=e;const t=$e[0],n=t>>23&511;return Ke.baseTable[n]+((8388607&t)>>Ke.shiftTable[n])}function Ze(e){Ke||=Je();const t=e>>10;return $e[0]=Ke.mantissaTable[Ke.offsetTable[t]+(1023&e)]+Ke.exponentTable[t],Qe[0]}function Je(){const e=new Uint32Array(512),t=new Uint32Array(512);for(let o=0;o<256;++o){const n=o-127;n<-27?(e[o]=0,e[256|o]=32768,t[o]=24,t[256|o]=24):n<-14?(e[o]=1024>>-n-14,e[256|o]=1024>>-n-14|32768,t[o]=-n-1,t[256|o]=-n-1):n<=15?(e[o]=n+15<<10,e[256|o]=n+15<<10|32768,t[o]=13,t[256|o]=13):n<128?(e[o]=31744,e[256|o]=64512,t[o]=24,t[256|o]=24):(e[o]=31744,e[256|o]=64512,t[o]=13,t[256|o]=13)}const n=new Uint32Array(2048),i=new Uint32Array(64),r=new Uint32Array(64);for(let o=1;o<1024;++o){let e=o<<13,t=0;for(;0==(8388608&e);)e<<=1,t-=8388608;e&=-8388609,t+=947912704,n[o]=e|t}for(let o=1024;o<2048;++o)n[o]=939524096+(o-1024<<13);for(let o=1;o<31;++o)i[o]=o<<23;i[31]=1199570944,i[32]=2147483648;for(let o=33;o<63;++o)i[o]=2147483648+(o-32<<23);i[63]=3347054592;for(let o=1;o<64;++o)32!==o&&(r[o]=1024);return{baseTable:e,shiftTable:t,mantissaTable:n,exponentTable:i,offsetTable:r}}function et(e,t,n){void 0===t&&(t=[]),void 0===n&&(n=0);const i=Math.fround(e),r=e-i;return t[n]=i,t[n+1]=r,t}function tt(e){return e-Math.fround(e)}function nt(e){const t=new Float32Array(32);for(let n=0;n<4;++n)for(let i=0;i<4;++i){const r=4*n+i;et(e[4*i+n],t,2*r)}return t}const it={name:"random",fs:"float random(vec3 scale, float seed) {\n  /* use the fragment position for a different seed per-pixel */\n  return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n}\n"},rt={name:"fp32",vs:"#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\n\n// All these functions are for substituting tan() function from Intel GPU only\nconst float TWO_PI = 6.2831854820251465;\nconst float PI_2 = 1.5707963705062866;\nconst float PI_16 = 0.1963495463132858;\n\nconst float SIN_TABLE_0 = 0.19509032368659973;\nconst float SIN_TABLE_1 = 0.3826834261417389;\nconst float SIN_TABLE_2 = 0.5555702447891235;\nconst float SIN_TABLE_3 = 0.7071067690849304;\n\nconst float COS_TABLE_0 = 0.9807852506637573;\nconst float COS_TABLE_1 = 0.9238795042037964;\nconst float COS_TABLE_2 = 0.8314695954322815;\nconst float COS_TABLE_3 = 0.7071067690849304;\n\nconst float INVERSE_FACTORIAL_3 = 1.666666716337204e-01; // 1/3!\nconst float INVERSE_FACTORIAL_5 = 8.333333767950535e-03; // 1/5!\nconst float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04; // 1/7!\nconst float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06; // 1/9!\n\nfloat sin_taylor_fp32(float a) {\n  float r, s, t, x;\n\n  if (a == 0.0) {\n    return 0.0;\n  }\n\n  x = -a * a;\n  s = a;\n  r = a;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_3;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_5;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_7;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_9;\n  s = s + t;\n\n  return s;\n}\n\nvoid sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {\n  if (a == 0.0) {\n    sin_t = 0.0;\n    cos_t = 1.0;\n  }\n  sin_t = sin_taylor_fp32(a);\n  cos_t = sqrt(1.0 - sin_t * sin_t);\n}\n\nfloat tan_taylor_fp32(float a) {\n    float sin_a;\n    float cos_a;\n\n    if (a == 0.0) {\n        return 0.0;\n    }\n\n    // 2pi range reduction\n    float z = floor(a / TWO_PI);\n    float r = a - TWO_PI * z;\n\n    float t;\n    float q = floor(r / PI_2 + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return 1.0 / 0.0;\n    }\n\n    t = r - PI_2 * q;\n\n    q = floor(t / PI_16 + 0.5);\n    int k = int(q);\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return 1.0 / 0.0;\n    } else {\n        t = t - PI_16 * q;\n    }\n\n    float u = 0.0;\n    float v = 0.0;\n\n    float sin_t, cos_t;\n    float s, c;\n    sincos_taylor_fp32(t, sin_t, cos_t);\n\n    if (k == 0) {\n        s = sin_t;\n        c = cos_t;\n    } else {\n        if (abs(float(abs_k) - 1.0) < 0.5) {\n            u = COS_TABLE_0;\n            v = SIN_TABLE_0;\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\n            u = COS_TABLE_1;\n            v = SIN_TABLE_1;\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\n            u = COS_TABLE_2;\n            v = SIN_TABLE_2;\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\n            u = COS_TABLE_3;\n            v = SIN_TABLE_3;\n        }\n        if (k > 0) {\n            s = u * sin_t + v * cos_t;\n            c = u * cos_t - v * sin_t;\n        } else {\n            s = u * sin_t - v * cos_t;\n            c = u * cos_t + v * sin_t;\n        }\n    }\n\n    if (j == 0) {\n        sin_a = s;\n        cos_a = c;\n    } else if (j == 1) {\n        sin_a = c;\n        cos_a = -s;\n    } else if (j == -1) {\n        sin_a = -c;\n        cos_a = s;\n    } else {\n        sin_a = -s;\n        cos_a = -c;\n    }\n    return sin_a / cos_a;\n}\n#endif\n\nfloat tan_fp32(float a) {\n#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\n  return tan_taylor_fp32(a);\n#else\n  return tan(a);\n#endif\n}\n"},ot={props:{},uniforms:{},name:"picking",uniformTypes:{isActive:"f32",isAttribute:"f32",isHighlightActive:"f32",useFloatColors:"f32",highlightedObjectColor:"vec3<f32>",highlightColor:"vec4<f32>"},defaultUniforms:{isActive:!1,isAttribute:!1,isHighlightActive:!1,useFloatColors:!0,highlightedObjectColor:[0,0,0],highlightColor:[0,1,1,1]},vs:"uniform pickingUniforms {\n  float isActive;\n  float isAttribute;\n  float isHighlightActive;\n  float useFloatColors;\n  vec3 highlightedObjectColor;\n  vec4 highlightColor;\n} picking;\n\nout vec4 picking_vRGBcolor_Avalid;\n\n// Normalize unsigned byte color to 0-1 range\nvec3 picking_normalizeColor(vec3 color) {\n  return picking.useFloatColors > 0.5 ? color : color / 255.0;\n}\n\n// Normalize unsigned byte color to 0-1 range\nvec4 picking_normalizeColor(vec4 color) {\n  return picking.useFloatColors > 0.5 ? color : color / 255.0;\n}\n\nbool picking_isColorZero(vec3 color) {\n  return dot(color, vec3(1.0)) < 0.00001;\n}\n\nbool picking_isColorValid(vec3 color) {\n  return dot(color, vec3(1.0)) > 0.00001;\n}\n\n// Check if this vertex is highlighted \nbool isVertexHighlighted(vec3 vertexColor) {\n  vec3 highlightedObjectColor = picking_normalizeColor(picking.highlightedObjectColor);\n  return\n    bool(picking.isHighlightActive) && picking_isColorZero(abs(vertexColor - highlightedObjectColor));\n}\n\n// Set the current picking color\nvoid picking_setPickingColor(vec3 pickingColor) {\n  pickingColor = picking_normalizeColor(pickingColor);\n\n  if (bool(picking.isActive)) {\n    // Use alpha as the validity flag. If pickingColor is [0, 0, 0] fragment is non-pickable\n    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));\n\n    if (!bool(picking.isAttribute)) {\n      // Stores the picking color so that the fragment shader can render it during picking\n      picking_vRGBcolor_Avalid.rgb = pickingColor;\n    }\n  } else {\n    // Do the comparison with selected item color in vertex shader as it should mean fewer compares\n    picking_vRGBcolor_Avalid.a = float(isVertexHighlighted(pickingColor));\n  }\n}\n\nvoid picking_setObjectIndex(uint objectIndex) {\n  if (bool(picking.isActive)) {\n    uint index = objectIndex;\n    if (picking.indexMode == PICKING_INDEX_MODE_INSTANCE) {\n      index = uint(gl_InstanceID);\n    }\n    picking_vRGBcolor_Avalid.r = float(index % 255) / 255.0;\n    picking_vRGBcolor_Avalid.g = float((index / 255) % 255) / 255.0;\n    picking_vRGBcolor_Avalid.b = float((index / 255 / 255) %255) / 255.0;\n  }\n}\n\nvoid picking_setPickingAttribute(float value) {\n  if (bool(picking.isAttribute)) {\n    picking_vRGBcolor_Avalid.r = value;\n  }\n}\n\nvoid picking_setPickingAttribute(vec2 value) {\n  if (bool(picking.isAttribute)) {\n    picking_vRGBcolor_Avalid.rg = value;\n  }\n}\n\nvoid picking_setPickingAttribute(vec3 value) {\n  if (bool(picking.isAttribute)) {\n    picking_vRGBcolor_Avalid.rgb = value;\n  }\n}\n",fs:"uniform pickingUniforms {\n  float isActive;\n  float isAttribute;\n  float isHighlightActive;\n  float useFloatColors;\n  vec3 highlightedObjectColor;\n  vec4 highlightColor;\n} picking;\n\nin vec4 picking_vRGBcolor_Avalid;\n\n/*\n * Returns highlight color if this item is selected.\n */\nvec4 picking_filterHighlightColor(vec4 color) {\n  // If we are still picking, we don't highlight\n  if (picking.isActive > 0.5) {\n    return color;\n  }\n\n  bool selected = bool(picking_vRGBcolor_Avalid.a);\n\n  if (selected) {\n    // Blend in highlight color based on its alpha value\n    float highLightAlpha = picking.highlightColor.a;\n    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n    float highLightRatio = highLightAlpha / blendedAlpha;\n\n    vec3 blendedRGB = mix(color.rgb, picking.highlightColor.rgb, highLightRatio);\n    return vec4(blendedRGB, blendedAlpha);\n  } else {\n    return color;\n  }\n}\n\n/*\n * Returns picking color if picking enabled else unmodified argument.\n */\nvec4 picking_filterPickingColor(vec4 color) {\n  if (bool(picking.isActive)) {\n    if (picking_vRGBcolor_Avalid.a == 0.0) {\n      discard;\n    }\n    return picking_vRGBcolor_Avalid;\n  }\n  return color;\n}\n\n/*\n * Returns picking color if picking is enabled if not\n * highlight color if this item is selected, otherwise unmodified argument.\n */\nvec4 picking_filterColor(vec4 color) {\n  vec4 highlightColor = picking_filterHighlightColor(color);\n  return picking_filterPickingColor(highlightColor);\n}\n",getUniforms:function(e,t){void 0===e&&(e={});const n={};if(void 0===e.highlightedObjectColor);else if(null===e.highlightedObjectColor)n.isHighlightActive=!1;else{n.isHighlightActive=!0;const t=e.highlightedObjectColor.slice(0,3);n.highlightedObjectColor=t}if(e.highlightColor){const t=Array.from(e.highlightColor,(e=>e/255));Number.isFinite(t[3])||(t[3]=1),n.highlightColor=t}void 0!==e.isActive&&(n.isActive=Boolean(e.isActive),n.isAttribute=Boolean(e.isAttribute));void 0!==e.useFloatColors&&(n.useFloatColors=Boolean(e.useFloatColors));return n}};var st=n(8862);const at="precision highp int;\n\n// #if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\nstruct AmbientLight {\n  vec3 color;\n};\n\nstruct PointLight {\n  vec3 color;\n  vec3 position;\n  vec3 attenuation; // 2nd order x:Constant-y:Linear-z:Exponential\n};\n\nstruct DirectionalLight {\n  vec3 color;\n  vec3 direction;\n};\n\nuniform lightingUniforms {\n  int enabled;\n  int lightType;\n\n  int directionalLightCount;\n  int pointLightCount;\n\n  vec3 ambientColor;\n\n  vec3 lightColor0;\n  vec3 lightPosition0;\n  vec3 lightDirection0;\n  vec3 lightAttenuation0;\n\n  vec3 lightColor1;\n  vec3 lightPosition1;\n  vec3 lightDirection1;\n  vec3 lightAttenuation1;\n\n  vec3 lightColor2;\n  vec3 lightPosition2;\n  vec3 lightDirection2;\n  vec3 lightAttenuation2;\n} lighting;\n\nPointLight lighting_getPointLight(int index) {\n  switch (index) {\n    case 0:\n      return PointLight(lighting.lightColor0, lighting.lightPosition0, lighting.lightAttenuation0);\n    case 1:\n      return PointLight(lighting.lightColor1, lighting.lightPosition1, lighting.lightAttenuation1);\n    case 2:\n    default:  \n      return PointLight(lighting.lightColor2, lighting.lightPosition2, lighting.lightAttenuation2);\n  }\n}\n\nDirectionalLight lighting_getDirectionalLight(int index) {\n  switch (index) {\n    case 0:\n      return DirectionalLight(lighting.lightColor0, lighting.lightDirection0);\n    case 1:\n      return DirectionalLight(lighting.lightColor1, lighting.lightDirection1);\n    case 2:\n    default:   \n      return DirectionalLight(lighting.lightColor2, lighting.lightDirection2);\n  }\n} \n\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n\n// #endif\n",lt=3,ct=255;let ut=function(e){return e[e.POINT=0]="POINT",e[e.DIRECTIONAL=1]="DIRECTIONAL",e}({});const dt={props:{},uniforms:{},name:"lighting",defines:{MAX_LIGHTS:lt},uniformTypes:{enabled:"i32",lightType:"i32",directionalLightCount:"i32",pointLightCount:"i32",ambientLightColor:"vec3<f32>",lightColor0:"vec3<f32>",lightPosition0:"vec3<f32>",lightDirection0:"vec3<f32>",lightAttenuation0:"vec3<f32>",lightColor1:"vec3<f32>",lightPosition1:"vec3<f32>",lightDirection1:"vec3<f32>",lightAttenuation1:"vec3<f32>",lightColor2:"vec3<f32>",lightPosition2:"vec3<f32>",lightDirection2:"vec3<f32>",lightAttenuation2:"vec3<f32>"},defaultUniforms:{enabled:1,lightType:ut.POINT,directionalLightCount:0,pointLightCount:0,ambientLightColor:[.1,.1,.1],lightColor0:[1,1,1],lightPosition0:[1,1,2],lightDirection0:[1,1,1],lightAttenuation0:[1,0,0],lightColor1:[1,1,1],lightPosition1:[1,1,2],lightDirection1:[1,1,1],lightAttenuation1:[1,0,0],lightColor2:[1,1,1],lightPosition2:[1,1,2],lightDirection2:[1,1,1],lightAttenuation2:[1,0,0]},source:"// #if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\nstruct AmbientLight {\n  color: vec3<f32>,\n};\n\nstruct PointLight {\n  color: vec3<f32>,\n  position: vec3<f32>,\n  attenuation: vec3<f32>, // 2nd order x:Constant-y:Linear-z:Exponential\n};\n\nstruct DirectionalLight {\n  color: vec3<f32>,\n  direction: vec3<f32>,\n};\n\nstruct lightingUniforms {\n  enabled: i32,\n  poightCount: i32,\n  directionalLightCount: i32,\n\n  ambientColor: vec3<f32>,\n\n  // TODO - support multiple lights by uncommenting arrays below\n  lightType: i32,\n  lightColor: vec3<f32>,\n  lightDirection: vec3<f32>,\n  lightPosition: vec3<f32>,\n  lightAttenuation: vec3<f32>,\n\n  // AmbientLight ambientLight;\n  // PointLight pointLight[MAX_LIGHTS];\n  // DirectionalLight directionalLight[MAX_LIGHTS];\n};\n\n// Binding 0:1 is reserved for lighting (Note: could go into separate bind group as it is stable across draw calls)\n@binding(1) @group(0) var<uniform> lighting : lightingUniforms;\n\nfn lighting_getPointLight(index: i32) -> PointLight {\n  return PointLight(lighting.lightColor, lighting.lightPosition, lighting.lightAttenuation);\n}\n\nfn lighting_getDirectionalLight(index: i32) -> DirectionalLight {\n  return DirectionalLight(lighting.lightColor, lighting.lightDirection);\n} \n\nfn getPointLightAttenuation(pointLight: PointLight, distance: f32) -> f32 {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n",vs:at,fs:at,getUniforms:function(e,t){void 0===t&&(t={});if(!(e=e?{...e}:e))return{...dt.defaultUniforms};e.lights&&(e={...e,..._t(e.lights),lights:void 0});const{ambientLight:n,pointLights:i,directionalLights:r}=e||{};if(!(n||i&&i.length>0||r&&r.length>0))return{...dt.defaultUniforms,enabled:0};const o={...dt.defaultUniforms,...t,...ft({ambientLight:n,pointLights:i,directionalLights:r})};void 0!==e.enabled&&(o.enabled=e.enabled?1:0);return o}};function ft(e){let{ambientLight:t,pointLights:n=[],directionalLights:i=[]}=e;const r={};r.ambientLightColor=ht(t);let o=0;for(const s of n){r.lightType=ut.POINT;const e=o;r[`lightColor${e}`]=ht(s),r[`lightPosition${e}`]=s.position,r[`lightAttenuation${e}`]=s.attenuation||[1,0,0],o++}for(const s of i){r.lightType=ut.DIRECTIONAL;const e=o;r[`lightColor${e}`]=ht(s),r[`lightDirection${e}`]=s.direction,o++}return o>lt&&st.R.warn("MAX_LIGHTS exceeded")(),r.directionalLightCount=i.length,r.pointLightCount=n.length,r}function _t(e){const t={pointLights:[],directionalLights:[]};for(const n of e||[])switch(n.type){case"ambient":t.ambientLight=n;break;case"directional":t.directionalLights?.push(n);break;case"point":t.pointLights?.push(n)}return t}function ht(e){void 0===e&&(e={});const{color:t=[0,0,0],intensity:n=1}=e;return t.map((e=>e*n/ct))}const pt="uniform phongMaterialUniforms {\n  uniform float ambient;\n  uniform float diffuse;\n  uniform float shininess;\n  uniform vec3  specularColor;\n} material;\n",mt="uniform phongMaterialUniforms {\n  uniform float ambient;\n  uniform float diffuse;\n  uniform float shininess;\n  uniform vec3  specularColor;\n} material;\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\n  vec3 halfway_direction = normalize(light_direction + view_direction);\n  float lambertian = dot(light_direction, normal_worldspace);\n  float specular = 0.0;\n  if (lambertian > 0.0) {\n    float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n    specular = pow(specular_angle, material.shininess);\n  }\n  lambertian = max(lambertian, 0.0);\n  return (lambertian * material.diffuse * surfaceColor + specular * material.specularColor) * color;\n}\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = surfaceColor;\n\n  if (lighting.enabled == 0) {\n    return lightColor;\n  }\n\n  vec3 view_direction = normalize(cameraPosition - position_worldspace);\n  lightColor = material.ambient * surfaceColor * lighting.ambientColor;\n\n  for (int i = 0; i < lighting.pointLightCount; i++) {\n    PointLight pointLight = lighting_getPointLight(i);\n    vec3 light_position_worldspace = pointLight.position;\n    vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n    float light_attenuation = getPointLightAttenuation(pointLight, distance(light_position_worldspace, position_worldspace));\n    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color / light_attenuation);\n  }\n\n  int totalLights = min(MAX_LIGHTS, lighting.pointLightCount + lighting.directionalLightCount);\n  for (int i = lighting.pointLightCount; i < totalLights; i++) {\n    DirectionalLight directionalLight = lighting_getDirectionalLight(i);\n    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n  }\n  \n  return lightColor;\n}\n",gt={props:{},name:"gouraudMaterial",vs:mt.replace("phongMaterial","gouraudMaterial"),fs:pt.replace("phongMaterial","gouraudMaterial"),defines:{LIGHTING_VERTEX:1},dependencies:[dt],uniformTypes:{ambient:"f32",diffuse:"f32",shininess:"f32",specularColor:"vec3<f32>"},defaultUniforms:{ambient:.35,diffuse:.6,shininess:32,specularColor:[.15,.15,.15]},getUniforms(e){const t={...e};return t.specularColor&&(t.specularColor=t.specularColor.map((e=>e/255))),{...gt.defaultUniforms,...t}}},Et={name:"phongMaterial",dependencies:[dt],source:"struct phongMaterialUniforms {\n  ambient: f32,\n  diffuse: f32,\n  shininess: f32,\n  specularColor: vec3<f32>,\n};\n\n@binding(2) @group(0) var<uniform> material : phongMaterialUniforms;\n\nfn lighting_getLightColor(surfaceColor: vec3<f32>, light_direction: vec3<f32>, view_direction: vec3<f32>, normal_worldspace: vec3<f32>, color: vec3<f32>) -> vec3<f32> {\n  let halfway_direction: vec3<f32> = normalize(light_direction + view_direction);\n  var lambertian: f32 = dot(light_direction, normal_worldspace);\n  var specular: f32 = 0.0;\n  if (lambertian > 0.0) {\n    let specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n    specular = pow(specular_angle, material.shininess);\n  }\n  lambertian = max(lambertian, 0.0);\n  return (lambertian * material.diffuse * surfaceColor + specular * material.specularColor) * color;\n}\n\nfn lighting_getLightColor2(surfaceColor: vec3<f32>, cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32> {\n  var lightColor: vec3<f32> = surfaceColor;\n\n  if (lighting.enabled == 0) {\n    return lightColor;\n  }\n\n  let view_direction: vec3<f32> = normalize(cameraPosition - position_worldspace);\n  lightColor = material.ambient * surfaceColor * lighting.ambientColor;\n\n  if (lighting.lightType == 0) {\n    let pointLight: PointLight  = lighting_getPointLight(0);\n    let light_position_worldspace: vec3<f32> = pointLight.position;\n    let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);\n    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n  } else if (lighting.lightType == 1) {\n    var directionalLight: DirectionalLight = lighting_getDirectionalLight(0);\n    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n  }\n  \n  return lightColor;\n  /*\n  for (int i = 0; i < MAX_LIGHTS; i++) {\n    if (i >= lighting.pointLightCount) {\n      break;\n    }\n    PointLight pointLight = lighting.pointLight[i];\n    vec3 light_position_worldspace = pointLight.position;\n    vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n  }\n\n  for (int i = 0; i < MAX_LIGHTS; i++) {\n    if (i >= lighting.directionalLightCount) {\n      break;\n    }\n    DirectionalLight directionalLight = lighting.directionalLight[i];\n    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n  }\n  */\n}\n\nfn lighting_getSpecularLightColor(cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32>{\n  var lightColor = vec3<f32>(0, 0, 0);\n  let surfaceColor = vec3<f32>(0, 0, 0);\n\n  if (lighting.enabled == 0) {\n    let view_direction = normalize(cameraPosition - position_worldspace);\n\n    switch (lighting.lightType) {\n      case 0, default: {\n        let pointLight: PointLight = lighting_getPointLight(0);\n        let light_position_worldspace: vec3<f32> = pointLight.position;\n        let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);\n        lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n      }\n      case 1: {\n        let directionalLight: DirectionalLight = lighting_getDirectionalLight(0);\n        lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n      }\n    }\n  }\n  return lightColor;\n}\n",vs:pt,fs:mt,defines:{LIGHTING_FRAGMENT:1},uniformTypes:{ambient:"f32",diffuse:"f32",shininess:"f32",specularColor:"vec3<f32>"},defaultUniforms:{ambient:.35,diffuse:.6,shininess:32,specularColor:[.15,.15,.15]},getUniforms(e){const t={...e};return t.specularColor&&(t.specularColor=t.specularColor.map((e=>e/255))),{...Et.defaultUniforms,...t}}},At="uniform pbrProjectionUniforms {\n  mat4 modelViewProjectionMatrix;\n  mat4 modelMatrix;\n  mat4 normalMatrix;\n  vec3 camera;\n} pbrProjection;\n",vt={props:{},uniforms:{},name:"pbrMaterial",dependencies:[dt,{name:"pbrProjection",vs:At,fs:At,getUniforms:e=>e,uniformTypes:{modelViewProjectionMatrix:"mat4x4<f32>",modelMatrix:"mat4x4<f32>",normalMatrix:"mat4x4<f32>",camera:"vec3<i32>"}}],vs:"out vec3 pbr_vPosition;\nout vec2 pbr_vUV;\n\n#ifdef HAS_NORMALS\n# ifdef HAS_TANGENTS\nout mat3 pbr_vTBN;\n# else\nout vec3 pbr_vNormal;\n# endif\n#endif\n\nvoid pbr_setPositionNormalTangentUV(vec4 position, vec4 normal, vec4 tangent, vec2 uv)\n{\n  vec4 pos = pbrProjection.modelMatrix * position;\n  pbr_vPosition = vec3(pos.xyz) / pos.w;\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\n  vec3 normalW = normalize(vec3(pbrProjection.normalMatrix * vec4(normal.xyz, 0.0)));\n  vec3 tangentW = normalize(vec3(pbrProjection.modelMatrix * vec4(tangent.xyz, 0.0)));\n  vec3 bitangentW = cross(normalW, tangentW) * tangent.w;\n  pbr_vTBN = mat3(tangentW, bitangentW, normalW);\n#else // HAS_TANGENTS != 1\n  pbr_vNormal = normalize(vec3(pbrProjection.modelMatrix * vec4(normal.xyz, 0.0)));\n#endif\n#endif\n\n#ifdef HAS_UV\n  pbr_vUV = uv;\n#else\n  pbr_vUV = vec2(0.,0.);\n#endif\n}\n",fs:"precision highp float;\n\nuniform pbrMaterialUniforms {\n  // Material is unlit\n  bool unlit;\n\n  // Base color map\n  bool baseColorMapEnabled;\n  vec4 baseColorFactor;\n\n  bool normalMapEnabled;  \n  float normalScale; // #ifdef HAS_NORMALMAP\n\n  bool emissiveMapEnabled;\n  vec3 emissiveFactor; // #ifdef HAS_EMISSIVEMAP\n\n  vec2 metallicRoughnessValues;\n  bool metallicRoughnessMapEnabled;\n\n  bool occlusionMapEnabled;\n  float occlusionStrength; // #ifdef HAS_OCCLUSIONMAP\n  \n  bool alphaCutoffEnabled;\n  float alphaCutoff; // #ifdef ALPHA_CUTOFF\n  \n  // IBL\n  bool IBLenabled;\n  vec2 scaleIBLAmbient; // #ifdef USE_IBL\n  \n  // debugging flags used for shader output of intermediate PBR variables\n  // #ifdef PBR_DEBUG\n  vec4 scaleDiffBaseMR;\n  vec4 scaleFGDSpec;\n  // #endif\n} pbrMaterial;\n\n// Samplers\n#ifdef HAS_BASECOLORMAP\nuniform sampler2D pbr_baseColorSampler;\n#endif\n#ifdef HAS_NORMALMAP\nuniform sampler2D pbr_normalSampler;\n#endif\n#ifdef HAS_EMISSIVEMAP\nuniform sampler2D pbr_emissiveSampler;\n#endif\n#ifdef HAS_METALROUGHNESSMAP\nuniform sampler2D pbr_metallicRoughnessSampler;\n#endif\n#ifdef HAS_OCCLUSIONMAP\nuniform sampler2D pbr_occlusionSampler;\n#endif\n#ifdef USE_IBL\nuniform samplerCube pbr_diffuseEnvSampler;\nuniform samplerCube pbr_specularEnvSampler;\nuniform sampler2D pbr_brdfLUT;\n#endif\n\n// Inputs from vertex shader\n\nin vec3 pbr_vPosition;\nin vec2 pbr_vUV;\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\nin mat3 pbr_vTBN;\n#else\nin vec3 pbr_vNormal;\n#endif\n#endif\n\n// Encapsulate the various inputs used by the various functions in the shading equation\n// We store values in this struct to simplify the integration of alternative implementations\n// of the shading terms, outlined in the Readme.MD Appendix.\nstruct PBRInfo {\n  float NdotL;                  // cos angle between normal and light direction\n  float NdotV;                  // cos angle between normal and view direction\n  float NdotH;                  // cos angle between normal and half vector\n  float LdotH;                  // cos angle between light direction and half vector\n  float VdotH;                  // cos angle between view direction and half vector\n  float perceptualRoughness;    // roughness value, as authored by the model creator (input to shader)\n  float metalness;              // metallic value at the surface\n  vec3 reflectance0;            // full reflectance color (normal incidence angle)\n  vec3 reflectance90;           // reflectance color at grazing angle\n  float alphaRoughness;         // roughness mapped to a more linear change in the roughness (proposed by [2])\n  vec3 diffuseColor;            // color contribution from diffuse lighting\n  vec3 specularColor;           // color contribution from specular lighting\n  vec3 n;                       // normal at surface point\n  vec3 v;                       // vector from surface point to camera\n};\n\nconst float M_PI = 3.141592653589793;\nconst float c_MinRoughness = 0.04;\n\nvec4 SRGBtoLINEAR(vec4 srgbIn)\n{\n#ifdef MANUAL_SRGB\n#ifdef SRGB_FAST_APPROXIMATION\n  vec3 linOut = pow(srgbIn.xyz,vec3(2.2));\n#else // SRGB_FAST_APPROXIMATION\n  vec3 bLess = step(vec3(0.04045),srgbIn.xyz);\n  vec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );\n#endif //SRGB_FAST_APPROXIMATION\n  return vec4(linOut,srgbIn.w);;\n#else //MANUAL_SRGB\n  return srgbIn;\n#endif //MANUAL_SRGB\n}\n\n// Find the normal for this fragment, pulling either from a predefined normal map\n// or from the interpolated mesh normal and tangent attributes.\nvec3 getNormal()\n{\n  // Retrieve the tangent space matrix\n#ifndef HAS_TANGENTS\n  vec3 pos_dx = dFdx(pbr_vPosition);\n  vec3 pos_dy = dFdy(pbr_vPosition);\n  vec3 tex_dx = dFdx(vec3(pbr_vUV, 0.0));\n  vec3 tex_dy = dFdy(vec3(pbr_vUV, 0.0));\n  vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n\n#ifdef HAS_NORMALS\n  vec3 ng = normalize(pbr_vNormal);\n#else\n  vec3 ng = cross(pos_dx, pos_dy);\n#endif\n\n  t = normalize(t - ng * dot(ng, t));\n  vec3 b = normalize(cross(ng, t));\n  mat3 tbn = mat3(t, b, ng);\n#else // HAS_TANGENTS\n  mat3 tbn = pbr_vTBN;\n#endif\n\n#ifdef HAS_NORMALMAP\n  vec3 n = texture(pbr_normalSampler, pbr_vUV).rgb;\n  n = normalize(tbn * ((2.0 * n - 1.0) * vec3(pbrMaterial.normalScale, pbrMaterial.normalScale, 1.0)));\n#else\n  // The tbn matrix is linearly interpolated, so we need to re-normalize\n  vec3 n = normalize(tbn[2].xyz);\n#endif\n\n  return n;\n}\n\n// Calculation of the lighting contribution from an optional Image Based Light source.\n// Precomputed Environment Maps are required uniform inputs and are computed as outlined in [1].\n// See our README.md on Environment Maps [3] for additional discussion.\n#ifdef USE_IBL\nvec3 getIBLContribution(PBRInfo pbrInfo, vec3 n, vec3 reflection)\n{\n  float mipCount = 9.0; // resolution of 512x512\n  float lod = (pbrInfo.perceptualRoughness * mipCount);\n  // retrieve a scale and bias to F0. See [1], Figure 3\n  vec3 brdf = SRGBtoLINEAR(texture(pbr_brdfLUT,\n    vec2(pbrInfo.NdotV, 1.0 - pbrInfo.perceptualRoughness))).rgb;\n  vec3 diffuseLight = SRGBtoLINEAR(texture(pbr_diffuseEnvSampler, n)).rgb;\n\n#ifdef USE_TEX_LOD\n  vec3 specularLight = SRGBtoLINEAR(texture(pbr_specularEnvSampler, reflection, lod)).rgb;\n#else\n  vec3 specularLight = SRGBtoLINEAR(texture(pbr_specularEnvSampler, reflection)).rgb;\n#endif\n\n  vec3 diffuse = diffuseLight * pbrInfo.diffuseColor;\n  vec3 specular = specularLight * (pbrInfo.specularColor * brdf.x + brdf.y);\n\n  // For presentation, this allows us to disable IBL terms\n  diffuse *= pbrMaterial.scaleIBLAmbient.x;\n  specular *= pbrMaterial.scaleIBLAmbient.y;\n\n  return diffuse + specular;\n}\n#endif\n\n// Basic Lambertian diffuse\n// Implementation from Lambert's Photometria https://archive.org/details/lambertsphotome00lambgoog\n// See also [1], Equation 1\nvec3 diffuse(PBRInfo pbrInfo)\n{\n  return pbrInfo.diffuseColor / M_PI;\n}\n\n// The following equation models the Fresnel reflectance term of the spec equation (aka F())\n// Implementation of fresnel from [4], Equation 15\nvec3 specularReflection(PBRInfo pbrInfo)\n{\n  return pbrInfo.reflectance0 +\n    (pbrInfo.reflectance90 - pbrInfo.reflectance0) *\n    pow(clamp(1.0 - pbrInfo.VdotH, 0.0, 1.0), 5.0);\n}\n\n// This calculates the specular geometric attenuation (aka G()),\n// where rougher material will reflect less light back to the viewer.\n// This implementation is based on [1] Equation 4, and we adopt their modifications to\n// alphaRoughness as input as originally proposed in [2].\nfloat geometricOcclusion(PBRInfo pbrInfo)\n{\n  float NdotL = pbrInfo.NdotL;\n  float NdotV = pbrInfo.NdotV;\n  float r = pbrInfo.alphaRoughness;\n\n  float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));\n  float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));\n  return attenuationL * attenuationV;\n}\n\n// The following equation(s) model the distribution of microfacet normals across\n// the area being drawn (aka D())\n// Implementation from \"Average Irregularity Representation of a Roughened Surface\n// for Ray Reflection\" by T. S. Trowbridge, and K. P. Reitz\n// Follows the distribution function recommended in the SIGGRAPH 2013 course notes\n// from EPIC Games [1], Equation 3.\nfloat microfacetDistribution(PBRInfo pbrInfo)\n{\n  float roughnessSq = pbrInfo.alphaRoughness * pbrInfo.alphaRoughness;\n  float f = (pbrInfo.NdotH * roughnessSq - pbrInfo.NdotH) * pbrInfo.NdotH + 1.0;\n  return roughnessSq / (M_PI * f * f);\n}\n\nvoid PBRInfo_setAmbientLight(inout PBRInfo pbrInfo) {\n  pbrInfo.NdotL = 1.0;\n  pbrInfo.NdotH = 0.0;\n  pbrInfo.LdotH = 0.0;\n  pbrInfo.VdotH = 1.0;\n}\n\nvoid PBRInfo_setDirectionalLight(inout PBRInfo pbrInfo, vec3 lightDirection) {\n  vec3 n = pbrInfo.n;\n  vec3 v = pbrInfo.v;\n  vec3 l = normalize(lightDirection);             // Vector from surface point to light\n  vec3 h = normalize(l+v);                        // Half vector between both l and v\n\n  pbrInfo.NdotL = clamp(dot(n, l), 0.001, 1.0);\n  pbrInfo.NdotH = clamp(dot(n, h), 0.0, 1.0);\n  pbrInfo.LdotH = clamp(dot(l, h), 0.0, 1.0);\n  pbrInfo.VdotH = clamp(dot(v, h), 0.0, 1.0);\n}\n\nvoid PBRInfo_setPointLight(inout PBRInfo pbrInfo, PointLight pointLight) {\n  vec3 light_direction = normalize(pointLight.position - pbr_vPosition);\n  PBRInfo_setDirectionalLight(pbrInfo, light_direction);\n}\n\nvec3 calculateFinalColor(PBRInfo pbrInfo, vec3 lightColor) {\n  // Calculate the shading terms for the microfacet specular shading model\n  vec3 F = specularReflection(pbrInfo);\n  float G = geometricOcclusion(pbrInfo);\n  float D = microfacetDistribution(pbrInfo);\n\n  // Calculation of analytical lighting contribution\n  vec3 diffuseContrib = (1.0 - F) * diffuse(pbrInfo);\n  vec3 specContrib = F * G * D / (4.0 * pbrInfo.NdotL * pbrInfo.NdotV);\n  // Obtain final intensity as reflectance (BRDF) scaled by the energy of the light (cosine law)\n  return pbrInfo.NdotL * lightColor * (diffuseContrib + specContrib);\n}\n\nvec4 pbr_filterColor(vec4 colorUnused)\n{\n  // The albedo may be defined from a base texture or a flat color\n#ifdef HAS_BASECOLORMAP\n  vec4 baseColor = SRGBtoLINEAR(texture(pbr_baseColorSampler, pbr_vUV)) * pbrMaterial.baseColorFactor;\n#else\n  vec4 baseColor = pbrMaterial.baseColorFactor;\n#endif\n\n#ifdef ALPHA_CUTOFF\n  if (baseColor.a < pbrMaterial.alphaCutoff) {\n    discard;\n  }\n#endif\n\n  vec3 color = vec3(0, 0, 0);\n\n  if(pbrMaterial.unlit){\n    color.rgb = baseColor.rgb;\n  }\n  else{\n    // Metallic and Roughness material properties are packed together\n    // In glTF, these factors can be specified by fixed scalar values\n    // or from a metallic-roughness map\n    float perceptualRoughness = pbrMaterial.metallicRoughnessValues.y;\n    float metallic = pbrMaterial.metallicRoughnessValues.x;\n#ifdef HAS_METALROUGHNESSMAP\n    // Roughness is stored in the 'g' channel, metallic is stored in the 'b' channel.\n    // This layout intentionally reserves the 'r' channel for (optional) occlusion map data\n    vec4 mrSample = texture(pbr_metallicRoughnessSampler, pbr_vUV);\n    perceptualRoughness = mrSample.g * perceptualRoughness;\n    metallic = mrSample.b * metallic;\n#endif\n    perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);\n    metallic = clamp(metallic, 0.0, 1.0);\n    // Roughness is authored as perceptual roughness; as is convention,\n    // convert to material roughness by squaring the perceptual roughness [2].\n    float alphaRoughness = perceptualRoughness * perceptualRoughness;\n\n    vec3 f0 = vec3(0.04);\n    vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0);\n    diffuseColor *= 1.0 - metallic;\n    vec3 specularColor = mix(f0, baseColor.rgb, metallic);\n\n    // Compute reflectance.\n    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\n\n    // For typical incident reflectance range (between 4% to 100%) set the grazing\n    // reflectance to 100% for typical fresnel effect.\n    // For very low reflectance range on highly diffuse objects (below 4%),\n    // incrementally reduce grazing reflecance to 0%.\n    float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);\n    vec3 specularEnvironmentR0 = specularColor.rgb;\n    vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;\n\n    vec3 n = getNormal();                          // normal at surface point\n    vec3 v = normalize(pbrProjection.camera - pbr_vPosition);  // Vector from surface point to camera\n\n    float NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);\n    vec3 reflection = -normalize(reflect(v, n));\n\n    PBRInfo pbrInfo = PBRInfo(\n      0.0, // NdotL\n      NdotV,\n      0.0, // NdotH\n      0.0, // LdotH\n      0.0, // VdotH\n      perceptualRoughness,\n      metallic,\n      specularEnvironmentR0,\n      specularEnvironmentR90,\n      alphaRoughness,\n      diffuseColor,\n      specularColor,\n      n,\n      v\n    );\n\n\n#ifdef USE_LIGHTS\n    // Apply ambient light\n    PBRInfo_setAmbientLight(pbrInfo);\n    color += calculateFinalColor(pbrInfo, lighting.ambientColor);\n\n    // Apply directional light\n    for(int i = 0; i < lighting.directionalLightCount; i++) {\n      if (i < lighting.directionalLightCount) {\n        PBRInfo_setDirectionalLight(pbrInfo, lighting_getDirectionalLight(i).direction);\n        color += calculateFinalColor(pbrInfo, lighting_getDirectionalLight(i).color);\n      }\n    }\n\n    // Apply point light\n    for(int i = 0; i < lighting.pointLightCount; i++) {\n      if (i < lighting.pointLightCount) {\n        PBRInfo_setPointLight(pbrInfo, lighting_getPointLight(i));\n        float attenuation = getPointLightAttenuation(lighting_getPointLight(i), distance(lighting_getPointLight(i).position, pbr_vPosition));\n        color += calculateFinalColor(pbrInfo, lighting_getPointLight(i).color / attenuation);\n      }\n    }\n#endif\n\n    // Calculate lighting contribution from image based lighting source (IBL)\n#ifdef USE_IBL\n    if (pbrMaterial.IBLenabled) {\n      color += getIBLContribution(pbrInfo, n, reflection);\n    }\n#endif\n\n // Apply optional PBR terms for additional (optional) shading\n#ifdef HAS_OCCLUSIONMAP\n    if (pbrMaterial.occlusionMapEnabled) {\n      float ao = texture(pbr_occlusionSampler, pbr_vUV).r;\n      color = mix(color, color * ao, pbrMaterial.occlusionStrength);\n    }\n#endif\n\n#ifdef HAS_EMISSIVEMAP\n    if (pbrMaterial.emissiveMapEnabled) {\n      vec3 emissive = SRGBtoLINEAR(texture(pbr_emissiveSampler, pbr_vUV)).rgb * pbrMaterial.emissiveFactor;\n      color += emissive;\n    }\n#endif\n\n    // This section uses mix to override final color for reference app visualization\n    // of various parameters in the lighting equation.\n#ifdef PBR_DEBUG\n    // TODO: Figure out how to debug multiple lights\n\n    // color = mix(color, F, pbr_scaleFGDSpec.x);\n    // color = mix(color, vec3(G), pbr_scaleFGDSpec.y);\n    // color = mix(color, vec3(D), pbr_scaleFGDSpec.z);\n    // color = mix(color, specContrib, pbr_scaleFGDSpec.w);\n\n    // color = mix(color, diffuseContrib, pbr_scaleDiffBaseMR.x);\n    color = mix(color, baseColor.rgb, pbrMaterial.scaleDiffBaseMR.y);\n    color = mix(color, vec3(metallic), pbrMaterial.scaleDiffBaseMR.z);\n    color = mix(color, vec3(perceptualRoughness), pbrMaterial.scaleDiffBaseMR.w);\n#endif\n\n  }\n\n  return vec4(pow(color,vec3(1.0/2.2)), baseColor.a);\n}\n",defines:{LIGHTING_FRAGMENT:1},getUniforms:e=>e,uniformTypes:{unlit:"i32",baseColorMapEnabled:"i32",baseColorFactor:"vec4<f32>",normalMapEnabled:"i32",normalScale:"f32",emissiveMapEnabled:"i32",emissiveFactor:"vec3<f32>",metallicRoughnessValues:"vec2<f32>",metallicRoughnessMapEnabled:"i32",occlusionMapEnabled:"i32",occlusionStrength:"f32",alphaCutoffEnabled:"i32",alphaCutoff:"f32",IBLenabled:"i32",scaleIBLAmbient:"vec2<f32>",scaleDiffBaseMR:"vec4<f32>",scaleFGDSpec:"vec4<f32>"}},Tt={props:{},name:"brightnessContrast",uniformTypes:{brightness:"f32",contrast:"f32"},defaultUniforms:{brightness:0,contrast:0},propTypes:{brightness:{format:"f32",value:0,min:-1,max:1},contrast:{format:"f32",value:0,min:-1,max:1}},passes:[{filter:!0}],source:"struct brightnessContrastUniforms {\n  float brightness;\n  float contrast;\n};\n\n// Binding 0:1 is reserved for shader passes\n@binding(1) @group(0) var<uniform> brightnessContrast : brightnessContrastUniforms;\n\nfn brightnessContrast_filterColor_ext(color: vec4<f32>, texSize: vec2<f32>, texCoords: vec2<f32>) -> vec4<f32> {\n  color.rgb += brightnessContrast.brightness;\n  if (brightnessContrast.contrast > 0.0) {\n    color.rgb = (color.rgb - 0.5) / (1.0 - brightnessContrast.contrast) + 0.5;\n  } else {\n    color.rgb = (color.rgb - 0.5) * (1.0 + brightnessContrast.contrast) + 0.5;\n  }\n  return color;\n}\n",fs:"uniform brightnessContrastUniforms {\n  float brightness;\n  float contrast;\n} brightnessContrast;\n\nvec4 brightnessContrast_filterColor(vec4 color) {\n  color.rgb += brightnessContrast.brightness;\n  if (brightnessContrast.contrast > 0.0) {\n    color.rgb = (color.rgb - 0.5) / (1.0 - brightnessContrast.contrast) + 0.5;\n  } else {\n    color.rgb = (color.rgb - 0.5) * (1.0 + brightnessContrast.contrast) + 0.5;\n  }\n  return color;\n}\n\nvec4 brightnessContrast_filterColor_ext(vec4 color, vec2 texSize, vec2 texCoord) {\n  return brightnessContrast_filterColor(color);\n}\n"},Rt={props:{},uniforms:{},name:"denoise",uniformTypes:{strength:"f32"},propTypes:{strength:{format:"f32",value:.5,min:0,max:1}},fs:"uniform denoiseUniforms {\n  float strength;\n} noise;\n\nvec4 denoise_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {\n  float adjustedExponent = 3. + 200. * pow(1. - noise.strength, 4.);\n\n  vec4 center = texture(source, texCoord);\n  vec4 color = vec4(0.0);\n  float total = 0.0;\n  for (float x = -4.0; x <= 4.0; x += 1.0) {\n    for (float y = -4.0; y <= 4.0; y += 1.0) {\n      vec4 offsetColor = texture(source, texCoord + vec2(x, y) / texSize);\n      float weight = 1.0 - abs(dot(offsetColor.rgb - center.rgb, vec3(0.25)));\n      weight = pow(weight, adjustedExponent);\n      color += offsetColor * weight;\n      total += weight;\n    }\n  }\n\n  return color / total;\n}\n",passes:[{sampler:!0},{sampler:!0}]},bt={props:{},name:"hueSaturation",fs:"uniform hueSaturationUniforms {\n  float hue;\n  float saturation;\n} hueSaturation;\n\nvec4 hueSaturation_filterColor(vec4 color) {\n  // hue adjustment, wolfram alpha: RotationTransform[angle, {1, 1, 1}][{x, y, z}]\n  float angle = hueSaturation.hue * 3.14159265;\n  float s = sin(angle), c = cos(angle);\n  vec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;\n  float len = length(color.rgb);\n  color.rgb = vec3(\n    dot(color.rgb, weights.xyz),\n    dot(color.rgb, weights.zxy),\n    dot(color.rgb, weights.yzx)\n  );\n\n  // saturation adjustment\n  float average = (color.r + color.g + color.b) / 3.0;\n  if (hueSaturation.saturation > 0.0) {\n    color.rgb += (average - color.rgb) * (1.0 - 1.0 / (1.001 - hueSaturation.saturation));\n  } else {\n    color.rgb += (average - color.rgb) * (-hueSaturation.saturation);\n  }\n\n  return color;\n}\n\nvec4 hueSaturation_filterColor_ext(vec4 color, vec2 texSize, vec2 texCoord) {\n  return hueSaturation_filterColor(color);\n}\n",uniformTypes:{hue:"f32",saturation:"f32"},propTypes:{hue:{value:0,min:-1,max:1},saturation:{value:0,min:-1,max:1}},passes:[{filter:!0}]},St={props:{},uniforms:{},name:"noise",uniformTypes:{amount:"f32"},propTypes:{amount:{value:.5,min:0,max:1}},fs:"uniform noiseUniforms {\n  float amount;\n} noise;\n\nfloat rand(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec4 noise_filterColor_ext(vec4 color, vec2 texSize, vec2 texCoord) {\n  float diff = (rand(texCoord) - 0.5) * noise.amount;\n  color.r += diff;\n  color.g += diff;\n  color.b += diff;\n  return color;\n}\n",passes:[{filter:!0}]},Ct={props:{},uniforms:{},name:"sepia",uniformTypes:{amount:"f32"},propTypes:{amount:{value:.5,min:0,max:1}},fs:"uniform sepiaUniforms {\n  float amount;\n} sepia;\n\nvec4 sepia_filterColor(vec4 color) {\n  float r = color.r;\n  float g = color.g;\n  float b = color.b;\n\n  color.r =\n    min(1.0, (r * (1.0 - (0.607 * sepia.amount))) + (g * (0.769 * sepia.amount)) + (b * (0.189 * sepia.amount)));\n  color.g = min(1.0, (r * 0.349 * sepia.amount) + (g * (1.0 - (0.314 * sepia.amount))) + (b * 0.168 * sepia.amount));\n  color.b = min(1.0, (r * 0.272 * sepia.amount) + (g * 0.534 * sepia.amount) + (b * (1.0 - (0.869 * sepia.amount))));\n\n  return color;\n}\n\nvec4 sepia_filterColor_ext(vec4 color, vec2 texSize, vec2 texCoord) {\n  return sepia_filterColor(color);\n}\n",passes:[{filter:!0}]},It={props:{},uniforms:{},name:"vibrance",uniformTypes:{amount:"f32"},propTypes:{amount:{value:0,min:-1,max:1}},fs:"uniform vibranceUniforms {\n  float amount;\n} vibrance;\n\nvec4 vibrance_filterColor(vec4 color) {\n  float average = (color.r + color.g + color.b) / 3.0;\n  float mx = max(color.r, max(color.g, color.b));\n  float amt = (mx - average) * (-vibrance.amount * 3.0);\n  color.rgb = mix(color.rgb, vec3(mx), amt);\n  return color;\n}\n\nvec4 vibrance_filterColor_ext(vec4 color, vec2 texSize, vec2 texCoord) {\n  return vibrance_filterColor(color);\n}\n",passes:[{filter:!0}]},Pt={props:{},uniforms:{},name:"vignette",uniformTypes:{radius:"f32",amount:"f32"},defaultUniforms:{radius:.5,amount:.5},propTypes:{radius:{value:.5,min:0,max:1},amount:{value:.5,min:0,max:1}},passes:[{filter:!0}],fs:"uniform vignetteUniforms {\n  float radius;\n  float amount;\n} vignette;\n\nvec4 vignette_filterColor_ext(vec4 color, vec2 texSize, vec2 texCoord) {\n  float dist = distance(texCoord, vec2(0.5, 0.5));\n  float ratio = smoothstep(0.8, vignette.radius * 0.799, dist * (vignette.amount + vignette.radius));\n  return color.rgba * ratio + (1.0 - ratio)*vec4(0.0, 0.0, 0.0, 1.0);\n}\n"},xt={props:{},uniforms:{},name:"tiltShift",dependencies:[it],uniformTypes:{blurRadius:"f32",gradientRadius:"f32",start:"vec2<f32>",end:"vec2<f32>",invert:"i32"},propTypes:{blurRadius:{value:15,min:0,max:50},gradientRadius:{value:200,min:0,max:400},start:{value:[0,0]},end:{value:[1,1]},invert:{value:0,private:!0}},passes:[{sampler:!0,uniforms:{invert:0}},{sampler:!0,uniforms:{invert:1}}],fs:"uniform tiltShiftUniforms {\n  float blurRadius;\n  float gradientRadius;\n  vec2 start;\n  vec2 end;\n  bool invert;\n} tiltShift;\n\nvec2 tiltShift_getDelta(vec2 texSize) {\n  vec2 vector = normalize((tiltShift.end - tiltShift.start) * texSize);\n  return tiltShift.invert ? vec2(-vector.y, vector.x) : vector;\n}\n\nvec4 tiltShift_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {\n  vec4 color = vec4(0.0);\n  float total = 0.0;\n\n  /* randomize the lookup values to hide the fixed number of samples */\n  float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n\n  vec2 normal = normalize(vec2((tiltShift.start.y - tiltShift.end.y) * texSize.y, (tiltShift.end.x - tiltShift.start.x) * texSize.x));\n  float radius = smoothstep(0.0, 1.0,\n    abs(dot(texCoord * texSize - tiltShift.start * texSize, normal)) / tiltShift.gradientRadius) * tiltShift.blurRadius;\n\n  for (float t = -30.0; t <= 30.0; t++) {\n    float percent = (t + offset - 0.5) / 30.0;\n    float weight = 1.0 - abs(percent);\n    vec4 offsetColor = texture(source, texCoord + tiltShift_getDelta(texSize) / texSize * percent * radius);\n\n    /* switch to pre-multiplied alpha to correctly blur transparent images */\n    offsetColor.rgb *= offsetColor.a;\n\n    color += offsetColor * weight;\n    total += weight;\n  }\n\n  color = color / total;\n\n  /* switch back from pre-multiplied alpha */\n  color.rgb /= color.a + 0.00001;\n\n  return color;\n}\n"},Nt={props:{},uniforms:{},name:"triangleBlur",uniformTypes:{radius:"f32",delta:"vec2<f32>"},propTypes:{radius:{value:20,min:0,softMax:100},delta:{value:[1,0],private:!0}},fs:"uniform triangleBlurUniforms {\n  float radius;\n  vec2 delta;\n} triangleBlur;\n\nvec4 triangleBlur_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {\n  vec2 adjustedDelta = triangleBlur.delta * triangleBlur.radius / texSize;\n\n  vec4 color = vec4(0.0);\n  float total = 0.0;\n\n  /* randomize the lookup values to hide the fixed number of samples */\n  float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n\n  for (float t = -30.0; t <= 30.0; t++) {\n    float percent = (t + offset - 0.5) / 30.0;\n    float weight = 1.0 - abs(percent);\n    vec4 offsetColor = texture(source, texCoord + adjustedDelta * percent);\n\n    /* switch to pre-multiplied alpha to correctly blur transparent images */\n    offsetColor.rgb *= offsetColor.a;\n\n    color += offsetColor * weight;\n    total += weight;\n  }\n\n  color = color / total;\n\n  /* switch back from pre-multiplied alpha */\n  color.rgb /= color.a + 0.00001;\n\n  return color;\n}\n",dependencies:[it],passes:[{sampler:!0,uniforms:{delta:[1,0]}},{sampler:!0,uniforms:{delta:[0,1]}}]},Lt={props:{},uniforms:{},name:"zoomBlur",uniformTypes:{center:"vec2<f32>",strength:"f32"},propTypes:{center:{value:[.5,.5]},strength:{value:.3,min:0,softMax:1}},fs:"\nuniform zoomBlurUniforms {\n  vec2 center;\n  float strength;\n} zoomBlur;\n\nvec4 zoomBlur_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {\n  vec4 color = vec4(0.0);\n  float total = 0.0;\n  vec2 toCenter = zoomBlur.center * texSize - texCoord * texSize;\n\n  /* randomize the lookup values to hide the fixed number of samples */\n  float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n\n  for (float t = 0.0; t <= 40.0; t++) {\n    float percent = (t + offset) / 40.0;\n    float weight = 4.0 * (percent - percent * percent);\n    vec4 offsetColor = texture(source, texCoord + toCenter * percent * zoomBlur.strength / texSize);\n\n    /* switch to pre-multiplied alpha to correctly blur transparent images */\n    offsetColor.rgb *= offsetColor.a;\n\n    color += offsetColor * weight;\n    total += weight;\n  }\n\n  color = color / total;\n\n  /* switch back from pre-multiplied alpha */\n  color.rgb /= color.a + 0.00001;\n\n  return color;\n}\n",dependencies:[it],passes:[{sampler:!0}]},Ft={props:{},uniforms:{},name:"colorHalftone",uniformTypes:{center:"vec2<f32>",angle:"f32",size:"f32"},propTypes:{center:{value:[.5,.5]},angle:{value:1.1,softMin:0,softMax:Math.PI/2},size:{value:4,min:1,softMin:3,softMax:20}},fs:"uniform colorHalftoneUniforms {\n  vec2 center;\n  float angle;\n  float size;\n} colorHalftone;\n\nfloat pattern(float angle, float scale, vec2 texSize, vec2 texCoord) {\n  float s = sin(angle), c = cos(angle);\n  vec2 tex = texCoord * texSize - colorHalftone.center * texSize;\n  vec2 point = vec2(\n\tc * tex.x - s * tex.y,\n\ts * tex.x + c * tex.y\n  ) * scale;\n  return (sin(point.x) * sin(point.y)) * 4.0;\n}\n\nvec4 colorHalftone_filterColor_ext(vec4 color, vec2 texSize, vec2 texCoord) {\n  float scale = 3.1514 / colorHalftone.size;\n  vec3 cmy = 1.0 - color.rgb;\n  float k = min(cmy.x, min(cmy.y, cmy.z));\n\n  cmy = (cmy - k) / (1.0 - k);\n  cmy = clamp(\n\t  cmy * 10.0 - 3.0 + vec3(\n      pattern(colorHalftone.angle + 0.26179, scale, texSize, texCoord),\n\t    pattern(colorHalftone.angle + 1.30899, scale, texSize, texCoord),\n      pattern(colorHalftone.angle, scale, texSize, texCoord)\n    ),\n\t  0.0,\n\t  1.0\n  );\n  k = clamp(k * 10.0 - 5.0 + pattern(colorHalftone.angle + 0.78539, scale, texSize, texCoord), 0.0, 1.0);\n  return vec4(1.0 - cmy - k, color.a);\n}\n",passes:[{filter:!0}]},yt={props:{},uniforms:{},name:"dotScreen",uniformTypes:{center:"vec2<f32>",angle:"f32",size:"f32"},propTypes:{center:{value:[.5,.5]},angle:{value:1.1,softMin:0,softMax:Math.PI/2},size:{value:3,min:1,softMin:3,softMax:20}},fs:"uniform dotScreenUniforms {\n  vec2 center;\n  float angle;\n  float size;\n} dotScreen;\n\nfloat pattern(vec2 texSize, vec2 texCoord) {\n  float scale = 3.1415 / dotScreen.size;\n\n  float s = sin(dotScreen.angle), c = cos(dotScreen.angle);\n  vec2 tex = texCoord * texSize - dotScreen.center * texSize;\n  vec2 point = vec2(\n    c * tex.x - s * tex.y,\n    s * tex.x + c * tex.y\n  ) * scale;\n  return (sin(point.x) * sin(point.y)) * 4.0;\n}\n\nvec4 dotScreen_filterColor_ext(vec4 color, vec2 texSize, vec2 texCoord) {\n  float average = (color.r + color.g + color.b) / 3.0;\n  return vec4(vec3(average * 10.0 - 5.0 + pattern(texSize, texCoord)), color.a);\n}\n",passes:[{filter:!0}]},Mt={props:{},uniforms:{},name:"edgeWork",dependencies:[it],fs:"uniform edgeWorkUniforms {\n  float radius;\n  int mode;\n} edgeWork;\n\nvec4 edgeWork_sampleColorRGB(sampler2D source, vec2 texSize, vec2 texCoord, vec2 delta) {\n  vec2 relativeDelta = edgeWork.radius * delta / texSize;\n\n  vec2 color = vec2(0.0);\n  vec2 total = vec2(0.0);\n\n  /* randomize the lookup values to hide the fixed number of samples */\n  float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n\n  for (float t = -30.0; t <= 30.0; t++) {\n    float percent = (t + offset - 0.5) / 30.0;\n    float weight = 1.0 - abs(percent);\n    vec3 sampleColor = texture(source, texCoord + relativeDelta * percent).rgb;\n    float average = (sampleColor.r + sampleColor.g + sampleColor.b) / 3.0;\n    color.x += average * weight;\n    total.x += weight;\n    if (abs(t) < 15.0) {\n      weight = weight * 2.0 - 1.0;\n      color.y += average * weight;\n      total.y += weight;\n    }\n  }\n  return vec4(color / total, 0.0, 1.0);\n}\n\nvec4 edgeWork_sampleColorXY(sampler2D source, vec2 texSize, vec2 texCoord, vec2 delta) {\n  vec2 relativeDelta = edgeWork.radius * delta / texSize;\n\n  vec2 color = vec2(0.0);\n  vec2 total = vec2(0.0);\n\n  /* randomize the lookup values to hide the fixed number of samples */\n  float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n\n  for (float t = -30.0; t <= 30.0; t++) {\n    float percent = (t + offset - 0.5) / 30.0;\n    float weight = 1.0 - abs(percent);\n    vec2 sampleColor = texture(source, texCoord + relativeDelta * percent).xy;\n    color.x += sampleColor.x * weight;\n    total.x += weight;\n    if (abs(t) < 15.0) {\n      weight = weight * 2.0 - 1.0;\n      color.y += sampleColor.y * weight;\n      total.y += weight;\n    }\n  }\n  float c = clamp(10000.0 * (color.y / total.y - color.x / total.x) + 0.5, 0.0, 1.0);\n  return vec4(c, c, c, 1.0);\n}\n\nvec4 edgeWork_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {\n  switch (edgeWork.mode) {\n    case 0: \n    return edgeWork_sampleColorRGB(source, texSize, texCoord, vec2(1., 0.));\n    case 1: \n    default:\n      return edgeWork_sampleColorXY(source, texSize, texCoord, vec2(0., 1.));\n  }\n}\n",uniformTypes:{radius:"f32",mode:"i32"},propTypes:{radius:{value:2,min:1,softMax:50},mode:{value:0,private:!0}},passes:[{sampler:!0,uniforms:{mode:0}},{sampler:!0,uniforms:{mode:1}}]},Ot={props:{},uniforms:{},name:"hexagonalPixelate",uniformTypes:{center:"vec2<f32>",scale:"f32"},propTypes:{center:{value:[.5,.5],hint:"screenspace"},scale:{value:10,min:1,softMin:5,softMax:50}},fs:"uniform hexagonalPixelateUniforms {\n  vec2 center;\n  float scale;\n} hexagonalPixelate;\n\nvec4 hexagonalPixelate_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {\n  vec2 tex = (texCoord * texSize - hexagonalPixelate.center * texSize) / hexagonalPixelate.scale;\n  tex.y /= 0.866025404;\n  tex.x -= tex.y * 0.5;\n\n  vec2 a;\n  if (tex.x + tex.y - floor(tex.x) - floor(tex.y) < 1.0) {\n    a = vec2(floor(tex.x), floor(tex.y));\n  }\n  else a = vec2(ceil(tex.x), ceil(tex.y));\n  vec2 b = vec2(ceil(tex.x), floor(tex.y));\n  vec2 c = vec2(floor(tex.x), ceil(tex.y));\n\n  vec3 TEX = vec3(tex.x, tex.y, 1.0 - tex.x - tex.y);\n  vec3 A = vec3(a.x, a.y, 1.0 - a.x - a.y);\n  vec3 B = vec3(b.x, b.y, 1.0 - b.x - b.y);\n  vec3 C = vec3(c.x, c.y, 1.0 - c.x - c.y);\n\n  float alen = length(TEX - A);\n  float blen = length(TEX - B);\n  float clen = length(TEX - C);\n\n  vec2 choice;\n  if (alen < blen) {\n    if (alen < clen) choice = a;\n    else choice = c;\n  } else {\n    if (blen < clen) choice = b;\n    else choice = c;\n  }\n\n  choice.x += choice.y * 0.5;\n  choice.y *= 0.866025404;\n  choice *= hexagonalPixelate.scale / texSize;\n\n  return texture(source, choice + hexagonalPixelate.center);\n}\n",passes:[{sampler:!0}]},Bt={props:{},uniforms:{},name:"ink",fs:"uniform inkUniforms {\n  float strength;\n} ink;\n\nvec4 ink_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {\n  vec2 dx = vec2(1.0 / texSize.x, 0.0);\n  vec2 dy = vec2(0.0, 1.0 / texSize.y);\n  vec4 color = texture(source, texCoord);\n  float bigTotal = 0.0;\n  float smallTotal = 0.0;\n  vec3 bigAverage = vec3(0.0);\n  vec3 smallAverage = vec3(0.0);\n  for (float x = -2.0; x <= 2.0; x += 1.0) {\n    for (float y = -2.0; y <= 2.0; y += 1.0) {\n      vec3 offsetColor = texture(source, texCoord + dx * x + dy * y).rgb;\n      bigAverage += offsetColor;\n      bigTotal += 1.0;\n      if (abs(x) + abs(y) < 2.0) {\n        smallAverage += offsetColor;\n        smallTotal += 1.0;\n      }\n    }\n  }\n  vec3 edge = max(vec3(0.0), bigAverage / bigTotal - smallAverage / smallTotal);\n  float power = ink.strength * ink.strength * ink.strength * ink.strength * ink.strength;\n  return vec4(color.rgb - dot(edge, edge) * power * 100000.0, color.a);\n}\n",uniformTypes:{strength:"f32"},propTypes:{strength:{value:.25,min:0,softMax:1}},passes:[{sampler:!0}]},Dt={name:"magnify",uniformTypes:{screenXY:"vec2<f32>",radiusPixels:"f32",zoom:"f32",borderWidthPixels:"f32",borderColor:"vec4<f32>"},propTypes:{screenXY:{value:[0,0]},radiusPixels:200,zoom:2,borderWidthPixels:0,borderColor:{value:[255,255,255,255]}},fs:"uniform magnifyUniforms {\n  vec2 screenXY;\n  float radiusPixels;\n  float zoom;\n  float borderWidthPixels;\n  vec4 borderColor;\n} magnify;\n\nvec4 magnify_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {\n  vec2 pos = vec2(magnify.screenXY.x, 1.0 - magnify.screenXY.y);\n  float dist = distance(texCoord * texSize, pos * texSize);\n  if (dist < magnify.radiusPixels) {\n    return texture(source, (texCoord - pos) / magnify.zoom + pos);\n  }\n\n  if (dist <= magnify.radiusPixels + magnify.borderWidthPixels) {\n    return magnify.borderColor;\n  }\n  return texture(source, texCoord);\n}\n",passes:[{sampler:!0}]},wt={name:"warp",passes:[],fs:"vec4 warp_sampleColor(sampler2D source, vec2 texSize, vec2 coord) {\n  vec4 color = texture(source, coord / texSize);\n  vec2 clampedCoord = clamp(coord, vec2(0.0), texSize);\n  if (coord != clampedCoord) {\n    /* fade to transparent if we are outside the image */\n    color.a *= max(0.0, 1.0 - length(coord - clampedCoord));\n  }\n\n  return color;\n}\n"},Ut={props:{},uniforms:{},name:"bulgePinch",dependencies:[wt],fs:"uniform bulgePinchUniforms {\n  float radius;\n  float strength;\n  vec2 center;\n} bulgePinch;\n\nvec2 bulgePinch_warp(vec2 coord, vec2 texCenter) {\n  coord -= texCenter;\n  float distance = length(coord);\n  if (distance < bulgePinch.radius) {\n    float percent = distance / bulgePinch.radius;\n    if (bulgePinch.strength > 0.0) {\n      coord *= mix(1.0, smoothstep(0.0, bulgePinch.radius / distance, percent), bulgePinch.strength * 0.75);\n    } else {\n      coord *= mix(1.0, pow(percent, 1.0 + bulgePinch.strength * 0.75) * bulgePinch.radius / distance, 1.0 - percent);\n    }\n  }\n  coord += texCenter;\n  return coord;\n}\n\nvec4 bulgePinch_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {\n  vec2 coord = texCoord * texSize;\n  coord = bulgePinch_warp(coord, bulgePinch.center * texSize);\n\n  return warp_sampleColor(source, texSize, coord);\n}\n",uniformTypes:{center:"vec2<f32>",radius:"f32",strength:"f32"},propTypes:{center:{value:[.5,.5]},radius:{value:200,min:1,softMax:600},strength:{value:.5,min:-1,max:1}},passes:[{sampler:!0}]},Gt={props:{},uniforms:{},name:"swirl",dependencies:[wt],fs:"uniform swirlUniforms {\n  float radius;\n  float angle;\n  vec2 center;\n} swirl;\n\nvec2 swirl_warp(vec2 coord, vec2 texCenter) {\n  coord -= texCenter;\n  float distance = length(coord);\n  if (distance < swirl.radius) {\n    float percent = (swirl.radius - distance) / swirl.radius;\n    float theta = percent * percent * swirl.angle;\n    float s = sin(theta);\n    float c = cos(theta);\n    coord = vec2(\n      coord.x * c - coord.y * s,\n      coord.x * s + coord.y * c\n    );\n  }\n  coord += texCenter;\n  return coord;\n}\n\nvec4 swirl_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {\n  vec2 coord = texCoord * texSize;\n  coord = swirl_warp(coord, swirl.center * texSize);\n\n  return warp_sampleColor(source, texSize, coord);\n}\n",uniformTypes:{center:"vec2<f32>",radius:"f32",angle:"f32"},propTypes:{center:{value:[.5,.5]},radius:{value:200,min:1,softMax:600},angle:{value:3,softMin:-25,softMax:25}},passes:[{sampler:!0}]},Ht={name:"fxaa",propTypes:{},fs:"\n#define FXAA_QUALITY_PRESET 29\n\n#if (FXAA_QUALITY_PRESET == 10)\n    #define FXAA_QUALITY_PS 3\n    #define FXAA_QUALITY_P0 1.5\n    #define FXAA_QUALITY_P1 3.0\n    #define FXAA_QUALITY_P2 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 11)\n    #define FXAA_QUALITY_PS 4\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 3.0\n    #define FXAA_QUALITY_P3 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 12)\n    #define FXAA_QUALITY_PS 5\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 4.0\n    #define FXAA_QUALITY_P4 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 13)\n    #define FXAA_QUALITY_PS 6\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 4.0\n    #define FXAA_QUALITY_P5 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 14)\n    #define FXAA_QUALITY_PS 7\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 4.0\n    #define FXAA_QUALITY_P6 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 15)\n    #define FXAA_QUALITY_PS 8\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 4.0\n    #define FXAA_QUALITY_P7 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 20)\n    #define FXAA_QUALITY_PS 3\n    #define FXAA_QUALITY_P0 1.5\n    #define FXAA_QUALITY_P1 2.0\n    #define FXAA_QUALITY_P2 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 21)\n    #define FXAA_QUALITY_PS 4\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 22)\n    #define FXAA_QUALITY_PS 5\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 23)\n    #define FXAA_QUALITY_PS 6\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 24)\n    #define FXAA_QUALITY_PS 7\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 3.0\n    #define FXAA_QUALITY_P6 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 25)\n    #define FXAA_QUALITY_PS 8\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 4.0\n    #define FXAA_QUALITY_P7 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 26)\n    #define FXAA_QUALITY_PS 9\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 4.0\n    #define FXAA_QUALITY_P8 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 27)\n    #define FXAA_QUALITY_PS 10\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 4.0\n    #define FXAA_QUALITY_P9 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 28)\n    #define FXAA_QUALITY_PS 11\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 2.0\n    #define FXAA_QUALITY_P9 4.0\n    #define FXAA_QUALITY_P10 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 29)\n    #define FXAA_QUALITY_PS 12\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 2.0\n    #define FXAA_QUALITY_P9 2.0\n    #define FXAA_QUALITY_P10 4.0\n    #define FXAA_QUALITY_P11 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 39)\n    #define FXAA_QUALITY_PS 12\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.0\n    #define FXAA_QUALITY_P2 1.0\n    #define FXAA_QUALITY_P3 1.0\n    #define FXAA_QUALITY_P4 1.0\n    #define FXAA_QUALITY_P5 1.5\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 2.0\n    #define FXAA_QUALITY_P9 2.0\n    #define FXAA_QUALITY_P10 4.0\n    #define FXAA_QUALITY_P11 8.0\n#endif\n\n#define FxaaBool bool\n#define FxaaFloat float\n#define FxaaFloat2 vec2\n#define FxaaFloat3 vec3\n#define FxaaFloat4 vec4\n#define FxaaHalf float\n#define FxaaHalf2 vec2\n#define FxaaHalf3 vec3\n#define FxaaHalf4 vec4\n#define FxaaInt2 vec2\n#define FxaaTex sampler2D\n\n#define FxaaSat(x) clamp(x, 0.0, 1.0)\n#define FxaaTexTop(t, p) texture(t, p)\n#define FxaaTexOff(t, p, o, r) texture(t, p + (o * r))\n\nFxaaFloat FxaaLuma_(FxaaFloat4 rgba) { return dot(rgba.rgb, vec3(0.2126, 0.7152, 0.0722)); }\n\nFxaaFloat4 FxaaPixelShader_(\n    //\n    // Use noperspective interpolation here (turn off perspective interpolation).\n    // {xy} = center of pixel\n    FxaaFloat2 pos,\n    //\n    // Input color texture.\n    // {rgb_} = color in linear or perceptual color space\n    // if (FXAA_GREEN_AS_LUMA == 0)\n    //     {___a} = luma in perceptual color space (not linear)\n    FxaaTex tex,\n    //\n    // Only used on FXAA Quality.\n    // This must be from a constant/uniform.\n    // {x_} = 1.0/screenWidthInPixels\n    // {_y} = 1.0/screenHeightInPixels\n    FxaaFloat2 fxaaQualityRcpFrame,\n    //\n    // Only used on FXAA Quality.\n    // This used to be the FXAA_QUALITY_SUBPIX define.\n    // It is here now to allow easier tuning.\n    // Choose the amount of sub-pixel aliasing removal.\n    // This can effect sharpness.\n    //   1.00 - upper limit (softer)\n    //   0.75 - default amount of filtering\n    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)\n    //   0.25 - almost off\n    //   0.00 - completely off\n    FxaaFloat fxaaQualitySubpix,\n    //\n    // Only used on FXAA Quality.\n    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.\n    // It is here now to allow easier tuning.\n    // The minimum amount of local contrast required to apply algorithm.\n    //   0.333 - too little (faster)\n    //   0.250 - low quality\n    //   0.166 - default\n    //   0.125 - high quality\n    //   0.063 - overkill (slower)\n    FxaaFloat fxaaQualityEdgeThreshold,\n    //\n    // Only used on FXAA Quality.\n    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.\n    // It is here now to allow easier tuning.\n    // Trims the algorithm from processing darks.\n    //   0.0833 - upper limit (default, the start of visible unfiltered edges)\n    //   0.0625 - high quality (faster)\n    //   0.0312 - visible limit (slower)\n    // Special notes when using FXAA_GREEN_AS_LUMA,\n    //   Likely want to set this to zero.\n    //   As colors that are mostly not-green\n    //   will appear very dark in the green channel!\n    //   Tune by looking at mostly non-green content,\n    //   then start at zero and increase until aliasing is a problem.\n    FxaaFloat fxaaQualityEdgeThresholdMin\n) {\n/*--------------------------------------------------------------------------*/\n    FxaaFloat2 posM;\n    posM.x = pos.x;\n    posM.y = pos.y;\n    FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n    #define lumaM rgbyM.y\n    FxaaFloat lumaS = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));\n    FxaaFloat lumaE = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));\n    FxaaFloat lumaN = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));\n    FxaaFloat lumaW = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));\n/*--------------------------------------------------------------------------*/\n    FxaaFloat maxSM = max(lumaS, lumaM);\n    FxaaFloat minSM = min(lumaS, lumaM);\n    FxaaFloat maxESM = max(lumaE, maxSM);\n    FxaaFloat minESM = min(lumaE, minSM);\n    FxaaFloat maxWN = max(lumaN, lumaW);\n    FxaaFloat minWN = min(lumaN, lumaW);\n    FxaaFloat rangeMax = max(maxWN, maxESM);\n    FxaaFloat rangeMin = min(minWN, minESM);\n    FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\n    FxaaFloat range = rangeMax - rangeMin;\n    FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\n    FxaaBool earlyExit = range < rangeMaxClamped;\n/*--------------------------------------------------------------------------*/\n    if(earlyExit)\n        return rgbyM;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat lumaNW = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));\n    FxaaFloat lumaSE = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));\n    FxaaFloat lumaNE = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));\n    FxaaFloat lumaSW = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n/*--------------------------------------------------------------------------*/\n    FxaaFloat lumaNS = lumaN + lumaS;\n    FxaaFloat lumaWE = lumaW + lumaE;\n    FxaaFloat subpixRcpRange = 1.0/range;\n    FxaaFloat subpixNSWE = lumaNS + lumaWE;\n    FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;\n    FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat lumaNESE = lumaNE + lumaSE;\n    FxaaFloat lumaNWNE = lumaNW + lumaNE;\n    FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\n    FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat lumaNWSW = lumaNW + lumaSW;\n    FxaaFloat lumaSWSE = lumaSW + lumaSE;\n    FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\n    FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\n    FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\n    FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\n    FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;\n    FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;\n    FxaaFloat lengthSign = fxaaQualityRcpFrame.x;\n    FxaaBool horzSpan = edgeHorz >= edgeVert;\n    FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\n/*--------------------------------------------------------------------------*/\n    if(!horzSpan) lumaN = lumaW;\n    if(!horzSpan) lumaS = lumaE;\n    if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;\n    FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat gradientN = lumaN - lumaM;\n    FxaaFloat gradientS = lumaS - lumaM;\n    FxaaFloat lumaNN = lumaN + lumaM;\n    FxaaFloat lumaSS = lumaS + lumaM;\n    FxaaBool pairN = abs(gradientN) >= abs(gradientS);\n    FxaaFloat gradient = max(abs(gradientN), abs(gradientS));\n    if(pairN) lengthSign = -lengthSign;\n    FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);\n/*--------------------------------------------------------------------------*/\n    FxaaFloat2 posB;\n    posB.x = posM.x;\n    posB.y = posM.y;\n    FxaaFloat2 offNP;\n    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\n    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\n    if(!horzSpan) posB.x += lengthSign * 0.5;\n    if( horzSpan) posB.y += lengthSign * 0.5;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat2 posN;\n    posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;\n    posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;\n    FxaaFloat2 posP;\n    posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;\n    posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;\n    FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;\n    FxaaFloat lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN));\n    FxaaFloat subpixE = subpixC * subpixC;\n    FxaaFloat lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP));\n/*--------------------------------------------------------------------------*/\n    if(!pairN) lumaNN = lumaSS;\n    FxaaFloat gradientScaled = gradient * 1.0/4.0;\n    FxaaFloat lumaMM = lumaM - lumaNN * 0.5;\n    FxaaFloat subpixF = subpixD * subpixE;\n    FxaaBool lumaMLTZero = lumaMM < 0.0;\n/*--------------------------------------------------------------------------*/\n    lumaEndN -= lumaNN * 0.5;\n    lumaEndP -= lumaNN * 0.5;\n    FxaaBool doneN = abs(lumaEndN) >= gradientScaled;\n    FxaaBool doneP = abs(lumaEndP) >= gradientScaled;\n    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;\n    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;\n    FxaaBool doneNP = (!doneN) || (!doneP);\n    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;\n    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;\n/*--------------------------------------------------------------------------*/\n    if(doneNP) {\n        if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n        if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n        doneN = abs(lumaEndN) >= gradientScaled;\n        doneP = abs(lumaEndP) >= gradientScaled;\n        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;\n        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;\n        doneNP = (!doneN) || (!doneP);\n        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;\n        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;\n/*--------------------------------------------------------------------------*/\n        #if (FXAA_QUALITY_PS > 3)\n        if(doneNP) {\n            if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n            if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n            doneN = abs(lumaEndN) >= gradientScaled;\n            doneP = abs(lumaEndP) >= gradientScaled;\n            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;\n            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;\n            doneNP = (!doneN) || (!doneP);\n            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;\n            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;\n/*--------------------------------------------------------------------------*/\n            #if (FXAA_QUALITY_PS > 4)\n            if(doneNP) {\n                if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n                if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                doneN = abs(lumaEndN) >= gradientScaled;\n                doneP = abs(lumaEndP) >= gradientScaled;\n                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;\n                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;\n                doneNP = (!doneN) || (!doneP);\n                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;\n                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;\n/*--------------------------------------------------------------------------*/\n                #if (FXAA_QUALITY_PS > 5)\n                if(doneNP) {\n                    if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n                    if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                    doneN = abs(lumaEndN) >= gradientScaled;\n                    doneP = abs(lumaEndP) >= gradientScaled;\n                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;\n                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;\n                    doneNP = (!doneN) || (!doneP);\n                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;\n                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;\n/*--------------------------------------------------------------------------*/\n                    #if (FXAA_QUALITY_PS > 6)\n                    if(doneNP) {\n                        if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n                        if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                        doneN = abs(lumaEndN) >= gradientScaled;\n                        doneP = abs(lumaEndP) >= gradientScaled;\n                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;\n                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;\n                        doneNP = (!doneN) || (!doneP);\n                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;\n                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;\n/*--------------------------------------------------------------------------*/\n                        #if (FXAA_QUALITY_PS > 7)\n                        if(doneNP) {\n                            if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n                            if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                            doneN = abs(lumaEndN) >= gradientScaled;\n                            doneP = abs(lumaEndP) >= gradientScaled;\n                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;\n                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;\n                            doneNP = (!doneN) || (!doneP);\n                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;\n                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;\n/*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PS > 8)\n    if(doneNP) {\n        if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n        if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n        doneN = abs(lumaEndN) >= gradientScaled;\n        doneP = abs(lumaEndP) >= gradientScaled;\n        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;\n        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;\n        doneNP = (!doneN) || (!doneP);\n        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;\n        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;\n/*--------------------------------------------------------------------------*/\n        #if (FXAA_QUALITY_PS > 9)\n        if(doneNP) {\n            if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n            if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n            doneN = abs(lumaEndN) >= gradientScaled;\n            doneP = abs(lumaEndP) >= gradientScaled;\n            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;\n            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;\n            doneNP = (!doneN) || (!doneP);\n            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;\n            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;\n/*--------------------------------------------------------------------------*/\n            #if (FXAA_QUALITY_PS > 10)\n            if(doneNP) {\n                if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n                if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                doneN = abs(lumaEndN) >= gradientScaled;\n                doneP = abs(lumaEndP) >= gradientScaled;\n                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;\n                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;\n                doneNP = (!doneN) || (!doneP);\n                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;\n                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;\n/*--------------------------------------------------------------------------*/\n                #if (FXAA_QUALITY_PS > 11)\n                if(doneNP) {\n                    if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n                    if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                    doneN = abs(lumaEndN) >= gradientScaled;\n                    doneP = abs(lumaEndP) >= gradientScaled;\n                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;\n                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;\n                    doneNP = (!doneN) || (!doneP);\n                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;\n                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;\n/*--------------------------------------------------------------------------*/\n                    #if (FXAA_QUALITY_PS > 12)\n                    if(doneNP) {\n                        if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n                        if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                        doneN = abs(lumaEndN) >= gradientScaled;\n                        doneP = abs(lumaEndP) >= gradientScaled;\n                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;\n                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;\n                        doneNP = (!doneN) || (!doneP);\n                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;\n                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;\n/*--------------------------------------------------------------------------*/\n                    }\n                    #endif\n/*--------------------------------------------------------------------------*/\n                }\n                #endif\n/*--------------------------------------------------------------------------*/\n            }\n            #endif\n/*--------------------------------------------------------------------------*/\n        }\n        #endif\n/*--------------------------------------------------------------------------*/\n    }\n    #endif\n/*--------------------------------------------------------------------------*/\n                        }\n                        #endif\n/*--------------------------------------------------------------------------*/\n                    }\n                    #endif\n/*--------------------------------------------------------------------------*/\n                }\n                #endif\n/*--------------------------------------------------------------------------*/\n            }\n            #endif\n/*--------------------------------------------------------------------------*/\n        }\n        #endif\n/*--------------------------------------------------------------------------*/\n    }\n/*--------------------------------------------------------------------------*/\n    FxaaFloat dstN = posM.x - posN.x;\n    FxaaFloat dstP = posP.x - posM.x;\n    if(!horzSpan) dstN = posM.y - posN.y;\n    if(!horzSpan) dstP = posP.y - posM.y;\n/*--------------------------------------------------------------------------*/\n    FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\n    FxaaFloat spanLength = (dstP + dstN);\n    FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\n    FxaaFloat spanLengthRcp = 1.0/spanLength;\n/*--------------------------------------------------------------------------*/\n    FxaaBool directionN = dstN < dstP;\n    FxaaFloat dst = min(dstN, dstP);\n    FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;\n    FxaaFloat subpixG = subpixF * subpixF;\n    FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\n    FxaaFloat subpixH = subpixG * fxaaQualitySubpix;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\n    FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\n    if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;\n    if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;\n    return FxaaTexTop(tex, posM);\n}\n\nvec4 fxaa_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {\n    const float fxaa_QualitySubpix = 0.5;\n    const float fxaa_QualityEdgeThreshold = 0.125;\n    const float fxaa_QualityEdgeThresholdMin = 0.0833;\n\n    return FxaaPixelShader_(\n        texCoord,\n        source,\n        vec2(1.0) / texSize,\n        fxaa_QualitySubpix,\n        fxaa_QualityEdgeThreshold,\n        fxaa_QualityEdgeThresholdMin\n    );\n}\n",passes:[{sampler:!0}],getUniforms:e=>e},Xt={ONE:1};const Vt={name:"fp64-arithmetic",vs:"uniform float ONE;\n\n/*\nAbout LUMA_FP64_CODE_ELIMINATION_WORKAROUND\n\nThe purpose of this workaround is to prevent shader compilers from\noptimizing away necessary arithmetic operations by swapping their sequences\nor transform the equation to some 'equivalent' form.\n\nThe method is to multiply an artifical variable, ONE, which will be known to\nthe compiler to be 1 only at runtime. The whole expression is then represented\nas a polynomial with respective to ONE. In the coefficients of all terms, only one a\nand one b should appear\n\nerr = (a + b) * ONE^6 - a * ONE^5 - (a + b) * ONE^4 + a * ONE^3 - b - (a + b) * ONE^2 + a * ONE\n*/\n\n// Divide float number to high and low floats to extend fraction bits\nvec2 split(float a) {\n  const float SPLIT = 4097.0;\n  float t = a * SPLIT;\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float a_hi = t * ONE - (t - a);\n  float a_lo = a * ONE - a_hi;\n#else\n  float a_hi = t - (t - a);\n  float a_lo = a - a_hi;\n#endif\n  return vec2(a_hi, a_lo);\n}\n\n// Divide float number again when high float uses too many fraction bits\nvec2 split2(vec2 a) {\n  vec2 b = split(a.x);\n  b.y += a.y;\n  return b;\n}\n\n// Special sum operation when a > b\nvec2 quickTwoSum(float a, float b) {\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float sum = (a + b) * ONE;\n  float err = b - (sum - a) * ONE;\n#else\n  float sum = a + b;\n  float err = b - (sum - a);\n#endif\n  return vec2(sum, err);\n}\n\n// General sum operation\nvec2 twoSum(float a, float b) {\n  float s = (a + b);\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float v = (s * ONE - a) * ONE;\n  float err = (a - (s - v) * ONE) * ONE * ONE * ONE + (b - v);\n#else\n  float v = s - a;\n  float err = (a - (s - v)) + (b - v);\n#endif\n  return vec2(s, err);\n}\n\nvec2 twoSub(float a, float b) {\n  float s = (a - b);\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float v = (s * ONE - a) * ONE;\n  float err = (a - (s - v) * ONE) * ONE * ONE * ONE - (b + v);\n#else\n  float v = s - a;\n  float err = (a - (s - v)) - (b + v);\n#endif\n  return vec2(s, err);\n}\n\nvec2 twoSqr(float a) {\n  float prod = a * a;\n  vec2 a_fp64 = split(a);\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float err = ((a_fp64.x * a_fp64.x - prod) * ONE + 2.0 * a_fp64.x *\n    a_fp64.y * ONE * ONE) + a_fp64.y * a_fp64.y * ONE * ONE * ONE;\n#else\n  float err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;\n#endif\n  return vec2(prod, err);\n}\n\nvec2 twoProd(float a, float b) {\n  float prod = a * b;\n  vec2 a_fp64 = split(a);\n  vec2 b_fp64 = split(b);\n  float err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +\n    a_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;\n  return vec2(prod, err);\n}\n\nvec2 sum_fp64(vec2 a, vec2 b) {\n  vec2 s, t;\n  s = twoSum(a.x, b.x);\n  t = twoSum(a.y, b.y);\n  s.y += t.x;\n  s = quickTwoSum(s.x, s.y);\n  s.y += t.y;\n  s = quickTwoSum(s.x, s.y);\n  return s;\n}\n\nvec2 sub_fp64(vec2 a, vec2 b) {\n  vec2 s, t;\n  s = twoSub(a.x, b.x);\n  t = twoSub(a.y, b.y);\n  s.y += t.x;\n  s = quickTwoSum(s.x, s.y);\n  s.y += t.y;\n  s = quickTwoSum(s.x, s.y);\n  return s;\n}\n\nvec2 mul_fp64(vec2 a, vec2 b) {\n  vec2 prod = twoProd(a.x, b.x);\n  // y component is for the error\n  prod.y += a.x * b.y;\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  prod = split2(prod);\n#endif\n  prod = quickTwoSum(prod.x, prod.y);\n  prod.y += a.y * b.x;\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  prod = split2(prod);\n#endif\n  prod = quickTwoSum(prod.x, prod.y);\n  return prod;\n}\n\nvec2 div_fp64(vec2 a, vec2 b) {\n  float xn = 1.0 / b.x;\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  vec2 yn = mul_fp64(a, vec2(xn, 0));\n#else\n  vec2 yn = a * xn;\n#endif\n  float diff = (sub_fp64(a, mul_fp64(b, yn))).x;\n  vec2 prod = twoProd(xn, diff);\n  return sum_fp64(yn, prod);\n}\n\nvec2 sqrt_fp64(vec2 a) {\n  if (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);\n  if (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);\n\n  float x = 1.0 / sqrt(a.x);\n  float yn = a.x * x;\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  vec2 yn_sqr = twoSqr(yn) * ONE;\n#else\n  vec2 yn_sqr = twoSqr(yn);\n#endif\n  float diff = sub_fp64(a, yn_sqr).x;\n  vec2 prod = twoProd(x * 0.5, diff);\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  return sum_fp64(split(yn), prod);\n#else\n  return sum_fp64(vec2(yn, 0.0), prod);\n#endif\n}\n",getUniforms:function(){return Xt},fp64ify:et,fp64LowPart:tt,fp64ifyMatrix4:nt},kt={name:"fp64",vs:"const vec2 E_FP64 = vec2(2.7182817459106445e+00, 8.254840366817007e-08);\nconst vec2 LOG2_FP64 = vec2(0.6931471824645996e+00, -1.9046542121259336e-09);\nconst vec2 PI_FP64 = vec2(3.1415927410125732, -8.742278012618954e-8);\nconst vec2 TWO_PI_FP64 = vec2(6.2831854820251465, -1.7484556025237907e-7);\nconst vec2 PI_2_FP64 = vec2(1.5707963705062866, -4.371139006309477e-8);\nconst vec2 PI_4_FP64 = vec2(0.7853981852531433, -2.1855695031547384e-8);\nconst vec2 PI_16_FP64 = vec2(0.19634954631328583, -5.463923757886846e-9);\nconst vec2 PI_16_2_FP64 = vec2(0.39269909262657166, -1.0927847515773692e-8);\nconst vec2 PI_16_3_FP64 = vec2(0.5890486240386963, -1.4906100798128818e-9);\nconst vec2 PI_180_FP64 = vec2(0.01745329238474369, 1.3519960498364902e-10);\n\nconst vec2 SIN_TABLE_0_FP64 = vec2(0.19509032368659973, -1.6704714833615242e-9);\nconst vec2 SIN_TABLE_1_FP64 = vec2(0.3826834261417389, 6.22335089017767e-9);\nconst vec2 SIN_TABLE_2_FP64 = vec2(0.5555702447891235, -1.1769521357507529e-8);\nconst vec2 SIN_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617041793133e-8);\n\nconst vec2 COS_TABLE_0_FP64 = vec2(0.9807852506637573, 2.9739473106360492e-8);\nconst vec2 COS_TABLE_1_FP64 = vec2(0.9238795042037964, 2.8307490351764386e-8);\nconst vec2 COS_TABLE_2_FP64 = vec2(0.8314695954322815, 1.6870263741530778e-8);\nconst vec2 COS_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617152815436e-8);\n\nconst vec2 INVERSE_FACTORIAL_3_FP64 = vec2(1.666666716337204e-01, -4.967053879312289e-09); // 1/3!\nconst vec2 INVERSE_FACTORIAL_4_FP64 = vec2(4.16666679084301e-02, -1.2417634698280722e-09); // 1/4!\nconst vec2 INVERSE_FACTORIAL_5_FP64 = vec2(8.333333767950535e-03, -4.34617203337595e-10); // 1/5!\nconst vec2 INVERSE_FACTORIAL_6_FP64 = vec2(1.3888889225199819e-03, -3.3631094437103215e-11); // 1/6!\nconst vec2 INVERSE_FACTORIAL_7_FP64 = vec2(1.9841270113829523e-04,  -2.725596874933456e-12); // 1/7!\nconst vec2 INVERSE_FACTORIAL_8_FP64 = vec2(2.4801587642286904e-05, -3.406996025904184e-13); // 1/8!\nconst vec2 INVERSE_FACTORIAL_9_FP64 = vec2(2.75573188446287533e-06, 3.7935713937038186e-14); // 1/9!\nconst vec2 INVERSE_FACTORIAL_10_FP64 = vec2(2.755731998149713e-07, -7.575112367869873e-15); // 1/10!\n\nfloat nint(float d) {\n    if (d == floor(d)) return d;\n    return floor(d + 0.5);\n}\n\nvec2 nint_fp64(vec2 a) {\n    float hi = nint(a.x);\n    float lo;\n    vec2 tmp;\n    if (hi == a.x) {\n        lo = nint(a.y);\n        tmp = quickTwoSum(hi, lo);\n    } else {\n        lo = 0.0;\n        if (abs(hi - a.x) == 0.5 && a.y < 0.0) {\n            hi -= 1.0;\n        }\n        tmp = vec2(hi, lo);\n    }\n    return tmp;\n}\n\n/* k_power controls how much range reduction we would like to have\nRange reduction uses the following method:\nassume a = k_power * r + m * log(2), k and m being integers.\nSet k_power = 4 (we can choose other k to trade accuracy with performance.\nwe only need to calculate exp(r) and using exp(a) = 2^m * exp(r)^k_power;\n*/\n\nvec2 exp_fp64(vec2 a) {\n  // We need to make sure these two numbers match\n  // as bit-wise shift is not available in GLSL 1.0\n  const int k_power = 4;\n  const float k = 16.0;\n\n  const float inv_k = 1.0 / k;\n\n  if (a.x <= -88.0) return vec2(0.0, 0.0);\n  if (a.x >= 88.0) return vec2(1.0 / 0.0, 1.0 / 0.0);\n  if (a.x == 0.0 && a.y == 0.0) return vec2(1.0, 0.0);\n  if (a.x == 1.0 && a.y == 0.0) return E_FP64;\n\n  float m = floor(a.x / LOG2_FP64.x + 0.5);\n  vec2 r = sub_fp64(a, mul_fp64(LOG2_FP64, vec2(m, 0.0))) * inv_k;\n  vec2 s, t, p;\n\n  p = mul_fp64(r, r);\n  s = sum_fp64(r, p * 0.5);\n  p = mul_fp64(p, r);\n  t = mul_fp64(p, INVERSE_FACTORIAL_3_FP64);\n\n  s = sum_fp64(s, t);\n  p = mul_fp64(p, r);\n  t = mul_fp64(p, INVERSE_FACTORIAL_4_FP64);\n\n  s = sum_fp64(s, t);\n  p = mul_fp64(p, r);\n  t = mul_fp64(p, INVERSE_FACTORIAL_5_FP64);\n\n  // s = sum_fp64(s, t);\n  // p = mul_fp64(p, r);\n  // t = mul_fp64(p, INVERSE_FACTORIAL_6_FP64);\n\n  // s = sum_fp64(s, t);\n  // p = mul_fp64(p, r);\n  // t = mul_fp64(p, INVERSE_FACTORIAL_7_FP64);\n\n  s = sum_fp64(s, t);\n\n\n  // At this point, s = exp(r) - 1; but after following 4 recursions, we will get exp(r) ^ 512 - 1.\n  for (int i = 0; i < k_power; i++) {\n    s = sum_fp64(s * 2.0, mul_fp64(s, s));\n  }\n\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n  s = sum_fp64(s, vec2(ONE, 0.0));\n#else\n  s = sum_fp64(s, vec2(1.0, 0.0));\n#endif\n\n  return s * pow(2.0, m);\n//   return r;\n}\n\nvec2 log_fp64(vec2 a)\n{\n  if (a.x == 1.0 && a.y == 0.0) return vec2(0.0, 0.0);\n  if (a.x <= 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);\n  vec2 x = vec2(log(a.x), 0.0);\n  vec2 s;\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n  s = vec2(ONE, 0.0);\n#else\n  s = vec2(1.0, 0.0);\n#endif\n\n  x = sub_fp64(sum_fp64(x, mul_fp64(a, exp_fp64(-x))), s);\n  return x;\n}\n\nvec2 sin_taylor_fp64(vec2 a) {\n  vec2 r, s, t, x;\n\n  if (a.x == 0.0 && a.y == 0.0) {\n    return vec2(0.0, 0.0);\n  }\n\n  x = -mul_fp64(a, a);\n  s = a;\n  r = a;\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_3_FP64);\n  s = sum_fp64(s, t);\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_5_FP64);\n  s = sum_fp64(s, t);\n\n  /* keep the following commented code in case we need them\n  for extra accuracy from the Taylor expansion*/\n\n  // r = mul_fp64(r, x);\n  // t = mul_fp64(r, INVERSE_FACTORIAL_7_FP64);\n  // s = sum_fp64(s, t);\n\n  // r = mul_fp64(r, x);\n  // t = mul_fp64(r, INVERSE_FACTORIAL_9_FP64);\n  // s = sum_fp64(s, t);\n\n  return s;\n}\n\nvec2 cos_taylor_fp64(vec2 a) {\n  vec2 r, s, t, x;\n\n  if (a.x == 0.0 && a.y == 0.0) {\n    return vec2(1.0, 0.0);\n  }\n\n  x = -mul_fp64(a, a);\n  r = x;\n  s = sum_fp64(vec2(1.0, 0.0), r * 0.5);\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_4_FP64);\n  s = sum_fp64(s, t);\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_6_FP64);\n  s = sum_fp64(s, t);\n\n  /* keep the following commented code in case we need them\n  for extra accuracy from the Taylor expansion*/\n\n  // r = mul_fp64(r, x);\n  // t = mul_fp64(r, INVERSE_FACTORIAL_8_FP64);\n  // s = sum_fp64(s, t);\n\n  // r = mul_fp64(r, x);\n  // t = mul_fp64(r, INVERSE_FACTORIAL_10_FP64);\n  // s = sum_fp64(s, t);\n\n  return s;\n}\n\nvoid sincos_taylor_fp64(vec2 a, out vec2 sin_t, out vec2 cos_t) {\n  if (a.x == 0.0 && a.y == 0.0) {\n    sin_t = vec2(0.0, 0.0);\n    cos_t = vec2(1.0, 0.0);\n  }\n\n  sin_t = sin_taylor_fp64(a);\n  cos_t = sqrt_fp64(sub_fp64(vec2(1.0, 0.0), mul_fp64(sin_t, sin_t)));\n}\n\nvec2 sin_fp64(vec2 a) {\n    if (a.x == 0.0 && a.y == 0.0) {\n        return vec2(0.0, 0.0);\n    }\n\n    // 2pi range reduction\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\n\n    vec2 t;\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    }\n\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\n\n    q = floor(t.x / PI_16_FP64.x + 0.5);\n    int k = int(q);\n\n    if (k == 0) {\n        if (j == 0) {\n            return sin_taylor_fp64(t);\n        } else if (j == 1) {\n            return cos_taylor_fp64(t);\n        } else if (j == -1) {\n            return -cos_taylor_fp64(t);\n        } else {\n            return -sin_taylor_fp64(t);\n        }\n    }\n\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    } else {\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n    }\n\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n    if (abs(float(abs_k) - 1.0) < 0.5) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs(float(abs_k) - 2.0) < 0.5) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs(float(abs_k) - 3.0) < 0.5) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs(float(abs_k) - 4.0) < 0.5) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#else\n    if (abs_k == 1) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs_k == 2) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs_k == 3) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs_k == 4) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#endif\n\n    vec2 sin_t, cos_t;\n    sincos_taylor_fp64(t, sin_t, cos_t);\n\n\n\n    vec2 result = vec2(0.0, 0.0);\n    if (j == 0) {\n        if (k > 0) {\n            result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        }\n    } else if (j == 1) {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        } else {\n            result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    } else if (j == -1) {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n        } else {\n            result = -sum_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n        }\n    } else {\n        if (k > 0) {\n            result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));\n        }\n    }\n\n    return result;\n}\n\nvec2 cos_fp64(vec2 a) {\n    if (a.x == 0.0 && a.y == 0.0) {\n        return vec2(1.0, 0.0);\n    }\n\n    // 2pi range reduction\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\n\n    vec2 t;\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    }\n\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\n\n    q = floor(t.x / PI_16_FP64.x + 0.5);\n    int k = int(q);\n\n    if (k == 0) {\n        if (j == 0) {\n            return cos_taylor_fp64(t);\n        } else if (j == 1) {\n            return -sin_taylor_fp64(t);\n        } else if (j == -1) {\n            return sin_taylor_fp64(t);\n        } else {\n            return -cos_taylor_fp64(t);\n        }\n    }\n\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    } else {\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n    }\n\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n    if (abs(float(abs_k) - 1.0) < 0.5) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs(float(abs_k) - 2.0) < 0.5) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs(float(abs_k) - 3.0) < 0.5) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs(float(abs_k) - 4.0) < 0.5) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#else\n    if (abs_k == 1) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs_k == 2) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs_k == 3) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs_k == 4) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#endif\n\n    vec2 sin_t, cos_t;\n    sincos_taylor_fp64(t, sin_t, cos_t);\n\n    vec2 result = vec2(0.0, 0.0);\n    if (j == 0) {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        } else {\n            result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    } else if (j == 1) {\n        if (k > 0) {\n            result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));\n        }\n    } else if (j == -1) {\n        if (k > 0) {\n            result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        }\n    } else {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n        } else {\n            result = -sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    }\n\n    return result;\n}\n\nvec2 tan_fp64(vec2 a) {\n    vec2 sin_a;\n    vec2 cos_a;\n\n    if (a.x == 0.0 && a.y == 0.0) {\n        return vec2(0.0, 0.0);\n    }\n\n    // 2pi range reduction\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\n\n    vec2 t;\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\n    int j = int(q);\n\n\n    if (j < -2 || j > 2) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    }\n\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\n\n    q = floor(t.x / PI_16_FP64.x + 0.5);\n    int k = int(q);\n    int abs_k = int(abs(float(k)));\n\n    // We just can't get PI/16 * 3.0 very accurately.\n    // so let's just store it\n    if (abs_k > 4) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    } else {\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n    }\n\n\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n\n    vec2 sin_t, cos_t;\n    vec2 s, c;\n    sincos_taylor_fp64(t, sin_t, cos_t);\n\n    if (k == 0) {\n        s = sin_t;\n        c = cos_t;\n    } else {\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n        if (abs(float(abs_k) - 1.0) < 0.5) {\n            u = COS_TABLE_0_FP64;\n            v = SIN_TABLE_0_FP64;\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\n            u = COS_TABLE_1_FP64;\n            v = SIN_TABLE_1_FP64;\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\n            u = COS_TABLE_2_FP64;\n            v = SIN_TABLE_2_FP64;\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\n            u = COS_TABLE_3_FP64;\n            v = SIN_TABLE_3_FP64;\n        }\n#else\n        if (abs_k == 1) {\n            u = COS_TABLE_0_FP64;\n            v = SIN_TABLE_0_FP64;\n        } else if (abs_k == 2) {\n            u = COS_TABLE_1_FP64;\n            v = SIN_TABLE_1_FP64;\n        } else if (abs_k == 3) {\n            u = COS_TABLE_2_FP64;\n            v = SIN_TABLE_2_FP64;\n        } else if (abs_k == 4) {\n            u = COS_TABLE_3_FP64;\n            v = SIN_TABLE_3_FP64;\n        }\n#endif\n        if (k > 0) {\n            s = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n            c = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        } else {\n            s = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n            c = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    }\n\n    if (j == 0) {\n        sin_a = s;\n        cos_a = c;\n    } else if (j == 1) {\n        sin_a = c;\n        cos_a = -s;\n    } else if (j == -1) {\n        sin_a = -c;\n        cos_a = s;\n    } else {\n        sin_a = -s;\n        cos_a = -c;\n    }\n    return div_fp64(sin_a, cos_a);\n}\n\nvec2 radians_fp64(vec2 degree) {\n  return mul_fp64(degree, PI_180_FP64);\n}\n\nvec2 mix_fp64(vec2 a, vec2 b, float x) {\n  vec2 range = sub_fp64(b, a);\n  return sum_fp64(a, mul_fp64(range, vec2(x, 0.0)));\n}\n\n// Vector functions\n// vec2 functions\nvoid vec2_sum_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = sum_fp64(a[0], b[0]);\n    out_val[1] = sum_fp64(a[1], b[1]);\n}\n\nvoid vec2_sub_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = sub_fp64(a[0], b[0]);\n    out_val[1] = sub_fp64(a[1], b[1]);\n}\n\nvoid vec2_mul_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = mul_fp64(a[0], b[0]);\n    out_val[1] = mul_fp64(a[1], b[1]);\n}\n\nvoid vec2_div_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = div_fp64(a[0], b[0]);\n    out_val[1] = div_fp64(a[1], b[1]);\n}\n\nvoid vec2_mix_fp64(vec2 x[2], vec2 y[2], float a, out vec2 out_val[2]) {\n  vec2 range[2];\n  vec2_sub_fp64(y, x, range);\n  vec2 portion[2];\n  portion[0] = range[0] * a;\n  portion[1] = range[1] * a;\n  vec2_sum_fp64(x, portion, out_val);\n}\n\nvec2 vec2_length_fp64(vec2 x[2]) {\n  return sqrt_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])));\n}\n\nvoid vec2_normalize_fp64(vec2 x[2], out vec2 out_val[2]) {\n  vec2 length = vec2_length_fp64(x);\n  vec2 length_vec2[2];\n  length_vec2[0] = length;\n  length_vec2[1] = length;\n\n  vec2_div_fp64(x, length_vec2, out_val);\n}\n\nvec2 vec2_distance_fp64(vec2 x[2], vec2 y[2]) {\n  vec2 diff[2];\n  vec2_sub_fp64(x, y, diff);\n  return vec2_length_fp64(diff);\n}\n\nvec2 vec2_dot_fp64(vec2 a[2], vec2 b[2]) {\n  vec2 v[2];\n\n  v[0] = mul_fp64(a[0], b[0]);\n  v[1] = mul_fp64(a[1], b[1]);\n\n  return sum_fp64(v[0], v[1]);\n}\n\n// vec3 functions\nvoid vec3_sub_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {\n  for (int i = 0; i < 3; i++) {\n    out_val[i] = sum_fp64(a[i], b[i]);\n  }\n}\n\nvoid vec3_sum_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {\n  for (int i = 0; i < 3; i++) {\n    out_val[i] = sum_fp64(a[i], b[i]);\n  }\n}\n\nvec2 vec3_length_fp64(vec2 x[3]) {\n  return sqrt_fp64(sum_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])),\n    mul_fp64(x[2], x[2])));\n}\n\nvec2 vec3_distance_fp64(vec2 x[3], vec2 y[3]) {\n  vec2 diff[3];\n  vec3_sub_fp64(x, y, diff);\n  return vec3_length_fp64(diff);\n}\n\n// vec4 functions\nvoid vec4_fp64(vec4 a, out vec2 out_val[4]) {\n  out_val[0].x = a[0];\n  out_val[0].y = 0.0;\n\n  out_val[1].x = a[1];\n  out_val[1].y = 0.0;\n\n  out_val[2].x = a[2];\n  out_val[2].y = 0.0;\n\n  out_val[3].x = a[3];\n  out_val[3].y = 0.0;\n}\n\nvoid vec4_scalar_mul_fp64(vec2 a[4], vec2 b, out vec2 out_val[4]) {\n  out_val[0] = mul_fp64(a[0], b);\n  out_val[1] = mul_fp64(a[1], b);\n  out_val[2] = mul_fp64(a[2], b);\n  out_val[3] = mul_fp64(a[3], b);\n}\n\nvoid vec4_sum_fp64(vec2 a[4], vec2 b[4], out vec2 out_val[4]) {\n  for (int i = 0; i < 4; i++) {\n    out_val[i] = sum_fp64(a[i], b[i]);\n  }\n}\n\nvoid vec4_dot_fp64(vec2 a[4], vec2 b[4], out vec2 out_val) {\n  vec2 v[4];\n\n  v[0] = mul_fp64(a[0], b[0]);\n  v[1] = mul_fp64(a[1], b[1]);\n  v[2] = mul_fp64(a[2], b[2]);\n  v[3] = mul_fp64(a[3], b[3]);\n\n  out_val = sum_fp64(sum_fp64(v[0], v[1]), sum_fp64(v[2], v[3]));\n}\n\nvoid mat4_vec4_mul_fp64(vec2 b[16], vec2 a[4], out vec2 out_val[4]) {\n  vec2 tmp[4];\n\n  for (int i = 0; i < 4; i++)\n  {\n    for (int j = 0; j < 4; j++)\n    {\n      tmp[j] = b[j + i * 4];\n    }\n    vec4_dot_fp64(a, tmp, out_val[i]);\n  }\n}\n",dependencies:[Vt],fp64ify:et,fp64LowPart:tt,fp64ifyMatrix4:nt},Wt={name:"geometry",vs:"varying vec4 geometry_vPosition;\nvarying vec3 geometry_vNormal;\n\nvoid geometry_setNormal(vec3 normal) {\n  geometry_vNormal = normal;\n}\n\nvoid geometry_setPosition(vec4 position) {\n  geometry_vPosition = position;\n}\n\nvoid geometry_setPosition(vec3 position) {\n  geometry_vPosition = vec4(position, 1.);\n}\n",fs:"varying vec4 geometry_vPosition;\nvarying vec3 geometry_vNormal;\n\nvec4 geometry_getPosition() {\n  return geometry_vPosition;\n}\n\nvec3 geometry_getNormal() {\n  return geometry_vNormal;\n}\n"},Yt=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],zt={modelMatrix:Yt,viewMatrix:Yt,projectionMatrix:Yt,cameraPositionWorld:[0,0,0]};const Kt="varying vec4 project_vPositionWorld;\nvarying vec3 project_vNormalWorld;\n\nvec4 project_getPosition_World() {\n  return project_vPositionWorld;\n}\n\nvec3 project_getNormal_World() {\n  return project_vNormalWorld;\n}\n",jt={name:"project",getUniforms:function(e,t){void 0===e&&(e=zt),void 0===t&&(t={});const n={};return void 0!==e.modelMatrix&&(n.modelMatrix=e.modelMatrix),void 0!==e.viewMatrix&&(n.viewMatrix=e.viewMatrix),void 0!==e.projectionMatrix&&(n.projectionMatrix=e.projectionMatrix),void 0!==e.cameraPositionWorld&&(n.cameraPositionWorld=e.cameraPositionWorld),void 0!==e.projectionMatrix&&void 0!==e.viewMatrix&&(n.viewProjectionMatrix=new P.k(e.projectionMatrix).multiplyRight(e.viewMatrix)),n},vs:`${Kt}\n\n// Unprefixed uniforms\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewProjectionMatrix;\nuniform vec3 cameraPositionWorld;\n\nstruct World {\n  vec3 position;\n  vec3 normal;\n};\n\nWorld world;\n\nvoid project_setPosition(vec4 position) {\n  project_vPositionWorld = position;\n}\n\nvoid project_setNormal(vec3 normal) {\n  project_vNormalWorld = normal;\n}\n\nvoid project_setPositionAndNormal_World(vec3 position, vec3 normal) {\n  world.position = position;\n  world.normal = normal;\n}\n\nvoid project_setPositionAndNormal_Model(vec3 position, vec3 normal) {\n  world.position = (modelMatrix * vec4(position, 1.)).xyz;\n  world.normal = mat3(modelMatrix) * normal;\n}\n\nvec4 project_model_to_clipspace(vec4 position) {\n  return viewProjectionMatrix * modelMatrix * position;\n}\n\nvec4 project_model_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * modelMatrix * vec4(position, 1.);\n}\n\nvec4 project_world_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * vec4(position, 1.);\n}\n\nvec4 project_view_to_clipspace(vec3 position) {\n  return projectionMatrix * vec4(position, 1.);\n}\n\nvec4 project_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * vec4(position, 1.);\n}\n`,fs:`\n${Kt}`};var Qt=n(291);const $t={lightDirection:new Float32Array([1,1,2])};const qt={name:"dirlight",fs:"uniform vec3 dirlight_uLightDirection;\n\n/*\n * Returns color attenuated by angle from light source\n */\nvec4 dirlight_filterColor(vec4 color) {\n  vec3 normal = project_getNormal_World();\n  float d = abs(dot(normalize(normal), normalize(dirlight_uLightDirection)));\n  return vec4(color.rgb * d, color.a);\n}\n",getUniforms:function(e){void 0===e&&(e=$t);const t={};return e.lightDirection&&(t.dirlight_uLightDirection=e.lightDirection),t},dependencies:[jt]},Zt="\nuniform float lighting_uAmbient;\nuniform float lighting_uDiffuse;\nuniform float lighting_uShininess;\nuniform vec3  lighting_uSpecularColor;\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\n    vec3 halfway_direction = normalize(light_direction + view_direction);\n    float lambertian = dot(light_direction, normal_worldspace);\n    float specular = 0.0;\n    if (lambertian > 0.0) {\n      float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n      specular = pow(specular_angle, lighting_uShininess);\n    }\n    lambertian = max(lambertian, 0.0);\n    return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;\n}\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = surfaceColor;\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n    lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n\nvec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = vec3(0, 0, 0);\n  vec3 surfaceColor = vec3(0, 0, 0);\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n",Jt={};function en(e){if(void 0===e&&(e=Jt),!("material"in e))return{};const{material:t}=e;return t?function(e){const{ambient:t=.35,diffuse:n=.6,shininess:i=32,specularColor:r=[30,30,30]}=e;return{lighting_uAmbient:t,lighting_uDiffuse:n,lighting_uShininess:i,lighting_uSpecularColor:r.map((e=>e/255))}}(t):{lighting_uEnabled:!1}}const tn={name:"gouraud-lighting",dependencies:[Qt._],vs:Zt,defines:{LIGHTING_VERTEX:1},getUniforms:en},nn={name:"phong-lighting",dependencies:[Qt._],fs:Zt,defines:{LIGHTING_FRAGMENT:1},getUniforms:en};var rn=n(9345);class on extends l{static info='\n<div class="contents">Copyright 2011 <a href="http://madebyevan.com">Evan Wallace</a>\n  <br><br>This application is powered by <a href="http://evanw.github.com/glfx.js/">glfx.js</a>, \n  an open-source image effect library that uses WebGL.&nbsp; The source code for this application is \n  also <a href="http://github.com/evanw/webgl-filter/">available on GitHub</a>.\n</div>\n';scenes=[];center=[0,0,0];vantage=[0,0,0];time=0;constructor(e){let{device:t}=e;super(),this.device=t,this.imageTexture=new M.i(t,{data:(0,O.Dt)("./image.jpg",{imageOrientation:"flipY"})}),this.shaderPassMap=function(){const e={};return Object.entries(i).forEach((t=>{let[n,i]=t;i.passes&&!n.startsWith("_")&&(e[n]=i)})),e}(),this.setShaderPasses([]);const n=["No effect",...Object.keys(this.shaderPassMap)];this.selector=function(e,t,n){var i=document.createElement("select");i.id="selector",e.appendChild(i),i.style.cssText="position: absolute; top: 0; right: 0; margin: 20px; z-index: 1000;";for(const o of t){var r=document.createElement("option");r.value=o,r.text=o,r.id=o,i.appendChild(r)}return i?.addEventListener("change",(e=>n(e.target.value))),i}(document.body,n,(e=>{const t=this.shaderPassMap[e]?[this.shaderPassMap[e]]:[];this.setShaderPasses(t)}))}onFinalize(){this.shaderPassRenderer?.destroy()}onRender(e){let{device:t}=e;this.shaderPassRenderer.renderToScreen({sourceTexture:this.imageTexture})}setShaderPasses(e){this.shaderPassRenderer?.destroy(),this.shaderPassRenderer=new Ie(this.device,{shaderPasses:e})}}class sn extends l{static info="\nHave to start somewhere...\n";constructor(e){let{device:t}=e;super();const n=new Float32Array([0,0,-.5,-.5,1,0,0,.5,-.5,0,1,0,0,.5,0,0,1]);this.interleavedBuffer=t.createBuffer(n),this.model=new _.K(t,{id:"triangle",vs:"#version 300 es\n\nin vec2 position;\nin vec3 color;\n\nout vec3 vColor;\n\nvoid main() {\n  vColor = color;\n  gl_Position = vec4(position, 0.0, 1.0);\n}\n",fs:"#version 300 es\n\nin vec3 vColor;\nout vec4 fragColor;\nvoid main() {\n  fragColor = vec4(vColor, 1.0);\n}\n",bufferLayout:[{name:"vertexData",byteStride:20,attributes:[{attribute:"position",format:"float32x2",byteOffset:8},{attribute:"color",format:"float32x3",byteOffset:16}]}],attributes:{vertexData:this.interleavedBuffer},vertexCount:3})}onFinalize(){this.model.destroy(),this.interleavedBuffer.destroy()}onRender(e){let{device:t}=e;const n=t.beginRenderPass({clearColor:[0,0,0,1]});this.model.draw(n),n.end()}}class an extends l{constructor(e){let{device:t}=e;super(),this.model=new _.K(t,{source:"@vertex\nfn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> @builtin(position) vec4<f32> {\n  var positions = array<vec2<f32>, 3>(vec2(0.0, 0.5), vec2(-0.5, -0.5), vec2(0.5, -0.5));\n  return vec4<f32>(positions[vertexIndex], 0.0, 1.0);\n}\n\n@fragment\nfn fragmentMain() -> @location(0) vec4<f32> {\n  return vec4<f32>(1.0, 0.0, 0.0, 1.0);\n}\n",vs:"#version 300 es\nconst vec2 pos[3] = vec2[3](vec2(0.0f, 0.5f), vec2(-0.5f, -0.5f), vec2(0.5f, -0.5f));\nvoid main() {\n  gl_Position = vec4(pos[gl_VertexID], 0.0, 1.0);\n}\n",fs:"#version 300 es\nprecision highp float;\nlayout(location = 0) out vec4 outColor;\nvoid main() {\n    outColor = vec4(1.0, 0.0, 0.0, 1.0);\n}\n",topology:"triangle-list",vertexCount:3,shaderLayout:{attributes:[],bindings:[]},parameters:{depthFormat:"depth24plus"}})}onFinalize(){this.model.destroy()}onRender(e){let{device:t}=e;const n=t.beginRenderPass({clearColor:[1,1,1,1]});this.model.draw(n),n.end()}}var ln=n(5839),cn=n(9270);const un={uniformTypes:{mvpMatrix:"mat4x4<f32>"}},dn=[0,0,5];class fn extends l{static info="<p>\nDrawing a textured cube\n</p>\n";mvpMatrix=(()=>new cn.k)();viewMatrix=(()=>(new cn.k).lookAt({eye:dn}))();uniformStore=(()=>new s.K({app:un}))();constructor(e){let{device:t}=e;super();const n=new M.i(t,{usage:ln.g.TEXTURE&ln.g.COPY_DST,data:(0,O.Dt)("vis-logo.png"),mipmaps:!0,sampler:t.createSampler({minFilter:"linear",magFilter:"linear",mipmapFilter:"linear"})});this.model=new _.K(t,{id:"rotating-cube",source:"struct Uniforms {\n  modelViewProjectionMatrix : mat4x4<f32>,\n};\n\n@binding(0) @group(0) var<uniform> app : Uniforms;\n\nstruct VertexInputs {\n  // CUBE GEOMETRY\n  @location(0) positions : vec4<f32>,\n  @location(1) texCoords : vec2<f32>\n};\n\nstruct FragmentInputs {\n  @builtin(position) Position : vec4<f32>,\n  @location(0) fragUV : vec2<f32>,\n  @location(1) fragPosition: vec4<f32>,\n}\n\n@vertex\nfn vertexMain(inputs: VertexInputs) -> FragmentInputs {\n  var outputs : FragmentInputs;\n  outputs.Position = app.modelViewProjectionMatrix * inputs.positions;\n  outputs.fragUV = inputs.texCoords;\n  outputs.fragPosition = 0.5 * (inputs.positions + vec4(1.0, 1.0, 1.0, 1.0));\n  return outputs;\n}\n\n@fragment\nfn fragmentMain(inputs: FragmentInputs) -> @location(0) vec4<f32> {\n  return inputs.fragPosition;\n}\n",vs:"#version 300 es\n#define SHADER_NAME cube-vs\n\nuniform appUniforms {\n  mat4 modelViewProjectionMatrix;\n} app;\n\nlayout(location=0) in vec3 positions;\nlayout(location=1) in vec2 texCoords;\n\nout vec2 fragUV;\nout vec4 fragPosition;\n\nvoid main() {\n  gl_Position = app.modelViewProjectionMatrix * vec4(positions, 1.0);\n  fragUV = texCoords;\n  fragPosition = 0.5 * (vec4(positions, 1.) + vec4(1., 1., 1., 1.));\n}\n",fs:"#version 300 es\n#define SHADER_NAME cube-fs\nprecision highp float;\n\nuniform sampler2D uTexture;\n\nuniform appUniforms {\n  mat4 modelViewProjectionMatrix;\n} app;\n\nin vec2 fragUV;\nin vec4 fragPosition;\n\nlayout (location=0) out vec4 fragColor;\n\nvoid main() {\n  fragColor = fragPosition;\n  fragColor = texture(uTexture, vec2(fragUV.x, 1.0 - fragUV.y));\n}\n",geometry:new m({indices:!1}),bindings:{app:this.uniformStore.getManagedUniformBuffer(t,"app"),uTexture:n},parameters:{depthWriteEnabled:!0,depthCompare:"less-equal"}})}onFinalize(){this.model.destroy(),this.uniformStore.destroy()}onRender(e){let{device:t,aspect:n,tick:i}=e;this.mvpMatrix.perspective({fovy:Math.PI/3,aspect:n}).multiplyRight(this.viewMatrix).rotateX(.01*i).rotateY(.013*i),this.uniformStore.setUniforms({app:{mvpMatrix:this.mvpMatrix}});const r=t.beginRenderPass({clearColor:[0,0,0,1]});this.model.draw(r),r.end()}}var _n=n(8564);class hn extends l{constructor(e){let{device:t}=e;super(),this.uniformBuffer1=t.createBuffer({id:"uniforms-1",usage:_n.h.UNIFORM|_n.h.COPY_DST,byteLength:64}),this.uniformBuffer2=t.createBuffer({id:"uniforms-2",usage:_n.h.UNIFORM|_n.h.COPY_DST,byteLength:64}),this.cubeModel=new _.K(t,{id:"cube",source:"struct Uniforms {\n  modelViewProjectionMatrix : mat4x4<f32>,\n};\n@binding(0) @group(0) var<uniform> app : Uniforms;\n\nstruct VertexInputs {\n  @location(0) positions : vec4<f32>,\n  @location(1) texCoords : vec2<f32>\n};\n\nstruct FragmentInputs {\n  @builtin(position) Position : vec4<f32>,\n  @location(0) fragUV : vec2<f32>,\n  @location(1) fragPosition: vec4<f32>,\n}\n\n@vertex\nfn vertexMain(inputs: VertexInputs) -> FragmentInputs {\n  var outputs : FragmentInputs;\n  outputs.Position = app.modelViewProjectionMatrix * inputs.positions;\n  outputs.fragUV = inputs.texCoords;\n  outputs.fragPosition = 0.5 * (inputs.positions + vec4(1.0, 1.0, 1.0, 1.0));\n  return outputs;\n}\n\n@fragment\nfn fragmentMain(inputs: FragmentInputs) -> @location(0) vec4<f32> {\n  return inputs.fragPosition;\n}\n",vs:"#version 300 es\n#define SHADER_NAME cube-vs\n\nuniform appUniforms {\n  mat4 modelViewProjectionMatrix;\n} app;\n\nlayout(location=0) in vec3 positions;\nlayout(location=1) in vec2 texCoords;\n\nout vec2 fragUV;\nout vec4 fragPosition;\n\nvoid main() {\n  gl_Position = app.modelViewProjectionMatrix * vec4(positions, 1.0);\n  fragUV = texCoords;\n  fragPosition = vec4(positions, 1.);\n}\n",fs:"#version 300 es\n#define SHADER_NAME cube-fs\nprecision highp float;\n\nuniform appUniforms {\n  mat4 modelViewProjectionMatrix;\n} app;\n\nin vec2 fragUV;\nin vec4 fragPosition;\n\nlayout (location=0) out vec4 fragColor;\n\nvoid main() {\n  fragColor = fragPosition;\n}\n",geometry:new m({indices:!1}),parameters:{depthWriteEnabled:!0,depthCompare:"less",depthFormat:"depth24plus",cullMode:"back"},bindings:{app:this.uniformBuffer1}})}onFinalize(){this.cubeModel.destroy(),this.uniformBuffer1.destroy(),this.uniformBuffer2.destroy()}onRender(e){let{device:t}=e;const n=new P.k,i=new P.k,r=new P.k,o=t.canvasContext?.getAspect(),s=Date.now()/1e3;n.perspective({fovy:2*Math.PI/5,aspect:o,near:1,far:100}),i.identity().translate([-2,0,-7]).rotateAxis(1,[Math.sin(s),Math.cos(s),0]),r.copy(i).multiplyLeft(n),this.uniformBuffer1.write(new Float32Array(r)),i.identity().translate([2,0,-7]).rotateAxis(1,[Math.cos(s),Math.sin(s),0]),r.copy(i).multiplyLeft(n),this.uniformBuffer2.write(new Float32Array(r));const a=t.beginRenderPass({clearColor:[0,0,0,1]});this.cubeModel.setBindings({app:this.uniformBuffer1}),this.cubeModel.draw(a),this.cubeModel.setBindings({app:this.uniformBuffer2}),this.cubeModel.draw(a),a.end()}}class pn extends l{constructor(e){let{device:t}=e;super(),this.uniformBuffer=t.createBuffer({id:"uniforms",usage:_n.h.UNIFORM|_n.h.COPY_DST,byteLength:1024}),this.cubeModel=new _.K(t,{id:"cube",source:"struct Uniforms {\n  modelViewProjectionMatrix : array<mat4x4<f32>, 16>,\n};\n\n@binding(0) @group(0) var<uniform> app : Uniforms;\n\nstruct VertexInputs {\n  @builtin(instance_index) instanceIdx : u32,\n  // CUBE GEOMETRY\n  @location(0) positions : vec4<f32>,\n  @location(1) texCoords : vec2<f32>\n}\n\nstruct FragmentInputs {\n  @builtin(position) Position : vec4<f32>,\n  @location(0) fragUV : vec2<f32>,\n  @location(1) fragPosition: vec4<f32>,\n}\n\n@vertex\nfn vertexMain(inputs: VertexInputs) -> FragmentInputs {\n  var outputs : FragmentInputs;\n  outputs.Position = app.modelViewProjectionMatrix[inputs.instanceIdx] * inputs.positions;\n  outputs.fragUV = inputs.texCoords;\n  outputs.fragPosition = 0.5 * (inputs.positions + vec4<f32>(1.0, 1.0, 1.0, 1.0));\n  return outputs;\n}\n\n@fragment\nfn fragmentMain(inputs: FragmentInputs) -> @location(0) vec4<f32> {\n  return inputs.fragPosition;\n}\n",vs:"#version 300 es\n#define SHADER_NAME cube-vs\n\nuniform appUniforms {\n  mat4 modelViewProjectionMatrix[16];\n} app;\n\n// CUBE GEOMETRY\nlayout(location=0) in vec3 positions;\nlayout(location=1) in vec2 texCoords;\n\nout vec2 fragUV;\nout vec4 fragPosition;\n\nvoid main() {\n  gl_Position = app.modelViewProjectionMatrix[gl_InstanceID] * vec4(positions, 1.0);\n  fragUV = texCoords;\n  fragPosition = vec4(positions, 1.);\n}\n",fs:"#version 300 es\n#define SHADER_NAME cube-fs\nprecision highp float;\nin vec2 fragUV;\nin vec4 fragPosition;\n\nlayout (location=0) out vec4 fragColor;\n\nvoid main() {\n  fragColor = fragPosition;\n}\n",geometry:new m({indices:!1}),instanceCount:16,parameters:{depthWriteEnabled:!0,depthCompare:"less",depthFormat:"depth24plus",cullMode:"back"},bindings:{app:this.uniformBuffer}})}onFinalize(e){this.uniformBuffer.destroy(),this.cubeModel.destroy()}onRender(e){let{device:t}=e;const n=new P.k,i=t.canvasContext?.getAspect(),r=Date.now()/1e3;n.perspective({fovy:2*Math.PI/5,aspect:i,near:1,far:100});const o=function(e,t){const n=(new P.k).translate([0,0,-12]),i=new P.k;let r=0,o=0;for(let s=0;s<4;s++)for(let a=0;a<4;a++)i.copy(mn[r]).rotateAxis(1,[Math.sin((s+.5)*t),Math.cos((a+.5)*t),0]).multiplyLeft(n).multiplyLeft(e),gn.set(i,o),r++,o+=16;return gn}(n,r);this.uniformBuffer.write(o);const s=t.beginRenderPass();this.cubeModel.draw(s),s.end()}}const mn=[];for(let li=0;li<4;li++)for(let e=0;e<4;e++)mn.push((new P.k).translate([4*(li-2+.5),4*(e-2+.5),0]));const gn=new Float32Array(256);const En={name:"color",vs:"out vec3 color_vColor;\n\nvoid color_setColor(vec3 color) {\n  color_vColor = color;\n}\n  ",fs:"in vec3 color_vColor;\n\nvec3 color_getColor() {\n  return color_vColor;\n}\n  "};class An extends l{static info="\nInstanced triangles using luma.gl's high-level API\n";constructor(e){let{device:t}=e;super(),this.positionBuffer=t.createBuffer(new Float32Array([-.2,-.2,.2,-.2,0,.2])),this.colorBuffer=t.createBuffer(new Float32Array([1,0,0,0,1,0,0,0,1,1,1,0])),this.offsetBuffer=t.createBuffer(new Float32Array([.5,.5,-.5,.5,.5,-.5,-.5,-.5])),this.model=new _.K(t,{vs:"#version 300 es\nin vec2 position;\nin vec3 instanceColor;\nin vec2 instanceOffset;\n\nvoid main() {\n  color_setColor(instanceColor);\n  gl_Position = vec4(position + instanceOffset, 0.0, 1.0);\n}\n      ",fs:"#version 300 es\nout vec4 fragColor;\nvoid main() {\n  fragColor = vec4(color_getColor(), 1.0);\n}\n      ",modules:[En],bufferLayout:[{name:"position",format:"float32x2"},{name:"instanceColor",format:"float32x3",stepMode:"instance"},{name:"instanceOffset",format:"float32x2",stepMode:"instance"}],attributes:{position:this.positionBuffer,instanceColor:this.colorBuffer,instanceOffset:this.offsetBuffer},vertexCount:3,instanceCount:4})}onFinalize(){this.model.destroy(),this.positionBuffer.destroy(),this.colorBuffer.destroy(),this.offsetBuffer.destroy()}onRender(e){let{device:t}=e;const n=t.beginRenderPass({clearColor:[0,0,0,1]});this.model.draw(n),n.end()}}var vn=n(8112),Tn=n(779),Rn=n(8136),bn=n(9258),Sn=n(7757);class Cn extends l{static info="\nHave to start somewhere...\n";scenes=[];center=[0,0,0];vantage=[0,0,0];time=0;constructor(e){let{device:t}=e;super(),this.device=t,this.loadGLTF("Avocado");const n=document.getElementById("model-select");n?.addEventListener("change",(e=>{this.loadGLTF(e.target.value)}))}onFinalize(){this.scenes[0].traverse((e=>e.model.destroy()))}onRender(e){let{aspect:t,device:n,time:i}=e;if(!this.scenes?.length)return;const r=n.beginRenderPass({clearColor:[0,0,0,1],clearDepth:!0}),o=2*this.vantage[0],s=o/1e3,a=(new Sn.k).perspective({fovy:Math.PI/3,aspect:t,near:s,far:o}),l=[this.vantage[0]*Math.sin(.001*i),this.vantage[1],this.vantage[2]*Math.cos(.001*i)];this.scenes[0].traverse(((e,t)=>{let{worldMatrix:n}=t;const{model:i}=e,o=n.transformAsPoint(l),s=n.transformAsPoint(this.center),c=(new Sn.k).lookAt({eye:o,center:s}),u=new Sn.k(a).multiplyRight(c).multiplyRight(n);i.shaderInputs.setProps({lighting:In,pbrProjection:{camera:o,modelViewProjectionMatrix:u,modelMatrix:n,normalMatrix:new Sn.k(n).invert().transpose()}}),i.draw(r)})),r.end()}async loadGLTF(e){const t=this.device.canvasContext.canvas;t.style.opacity="0.1";const n=await(0,vn.H)(`https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Assets/main/Models/${e}/glTF/${e}.gltf`,Rn.B),i=(0,bn.R)(n),{scenes:r}=(0,Tn.v)(this.device,i,{pbrDebug:!1,imageBasedLightingEnvironment:null,lights:!0});this.scenes=r;let o=[1/0,1/0,1/0],s=[0,0,0];this.scenes[0].traverse((e=>{const{bounds:t}=e;o=o.map(((e,n)=>Math.min(e,t[0][n],t[1][n]))),s=s.map(((e,n)=>Math.max(e,t[0][n],t[1][n])))})),this.vantage=[2*(s[0]+s[2]),s[1],2*(s[0]+s[2])],this.center=[.5*(o[0]+s[0]),.5*(o[1]+s[1]),.5*(o[2]+s[2])],t.style.opacity="1"}}const In={ambientLight:{color:[255,133,133],intensity:1,type:"ambient"},directionalLights:[{color:[222,244,255],direction:[1,-.5,.5],intensity:10,type:"directional"}],pointLights:[{color:[255,222,222],position:[3,10,0],intensity:5,type:"point"}]};var Pn=n(1464);const xn={name:"app",uniformTypes:{modelMatrix:"mat4x4<f32>",mvpMatrix:"mat4x4<f32>",eyePosition:"vec3<f32>"}},Nn=[0,0,5];class Ln extends l{static info="\n<p>\nDrawing a phong-shaded cube\n</p>\n";shaderInputs=(()=>new y.l({app:xn,lighting:dt,phongMaterial:Et}))();modelMatrix=(()=>new Pn.k)();viewMatrix=(()=>(new Pn.k).lookAt({eye:Nn}))();mvpMatrix=(()=>new Pn.k)();constructor(e){let{device:t}=e;super(),this.shaderInputs.setProps({lighting:{lights:[{type:"ambient",color:[255,255,255]},{type:"point",color:[255,120,10],position:[2,4,3]},{type:"point",color:[0,255,10],position:[-2,1,3]}]},phongMaterial:{specularColor:[255,255,255],shininess:100}});const n=new M.i(t,{data:(0,O.Dt)("vis-logo.png")});this.model=new _.K(t,{source:"\nstruct Uniforms {\n  modelMatrix : mat4x4<f32>,\n  mvpMatrix : mat4x4<f32>,\n  eyePosition : vec3<f32>,\n};\n\n@binding(0) @group(0) var<uniform> app : Uniforms;\n\nstruct VertexInputs {\n  // CUBE GEOMETRY\n  @location(0) positions : vec3<f32>,\n  @location(1) normals : vec3<f32>,\n  @location(2) texCoords : vec2<f32>\n};\n\nstruct FragmentInputs {\n  @builtin(position) Position : vec4<f32>,\n  @location(0) fragUV : vec2<f32>,\n  @location(1) fragPosition: vec3<f32>,\n  @location(2) fragNormal: vec3<f32>\n}\n\n@vertex\nfn vertexMain(inputs: VertexInputs) -> FragmentInputs {\n  var outputs : FragmentInputs;\n  outputs.Position = app.mvpMatrix * app.modelMatrix * vec4<f32>(inputs.positions, 1);\n  outputs.fragUV = inputs.texCoords;\n  outputs.fragPosition = (app.modelMatrix * vec4<f32>(inputs.positions, 1.0)).xyz;\n  // NOTE: WGSL lacks conversion syntax: https://github.com/gpuweb/gpuweb/issues/2399\n  let mat3 = mat3x3(app.modelMatrix[0].xyz, app.modelMatrix[1].xyz, app.modelMatrix[2].xyz);\n  outputs.fragNormal = mat3 * inputs.normals;\n  return outputs;\n}\n\n// void main(void) {\n//   vPosition = (app.modelMatrix * vec4(positions, 1.0)).xyz;\n//   vNormal = mat3(app.modelMatrix) * normals;\n//   vUV = texCoords;\n//   gl_Position = app.mvpMatrix * vec4(positions, 1.0);\n// }\n\n// uniform sampler2D uTexture;\n\n@fragment\nfn fragmentMain(inputs: FragmentInputs) -> @location(0) vec4<f32> {\n  return vec4<f32>(inputs.fragPosition, 1);\n}\n\n// void main(void) {\n//   vec3 surfaceColor = texture(uTexture, vec2(vUV.x, 1.0 - vUV.y)).rgb;\n//   surfaceColor = lighting_getLightColor(surfaceColor, uApp.eyePosition, vPosition, normalize(vNormal));\n//   fragColor = vec4(surfaceColor, 1.0);\n// }\n",vs:"#version 300 es\n\nin vec3 positions;\nin vec3 normals;\nin vec2 texCoords;\n\nout vec3 vPosition;\nout vec3 vNormal;\nout vec2 vUV;\nout vec3 vColor;\n\nuniform appUniforms {\n  mat4 modelMatrix;\n  mat4 mvpMatrix;\n  vec3 eyePosition;\n} app;\n\nvoid main(void) {\n  vPosition = (app.modelMatrix * vec4(positions, 1.0)).xyz;\n  vNormal = mat3(app.modelMatrix) * normals;\n  vUV = texCoords;\n\n  #ifdef LIGHTING_VERTEX\n  vColor = lighting_getLightColor(vec3(1.0), app.eyePosition, vPosition, normalize(vNormal));\n  #endif\n  gl_Position = app.mvpMatrix * vec4(positions, 1.0);\n}\n",fs:"#version 300 es\nprecision highp float;\n\nin vec3 vPosition;\nin vec3 vNormal;\nin vec2 vUV;\nin vec3 vColor;\n\nuniform sampler2D uTexture;\n\nuniform appUniforms {\n  mat4 modelMatrix;\n  mat4 mvpMatrix;\n  vec3 eyePosition;\n} app;\n\nout vec4 fragColor;\n\nvoid main(void) {\n  #ifdef LIGHTING_FRAGMENT\n  vec3 surfaceColor = texture(uTexture, vec2(vUV.x, 1.0 - vUV.y)).rgb;\n  surfaceColor = lighting_getLightColor(surfaceColor, app.eyePosition, vPosition, normalize(vNormal));\n  fragColor = vec4(surfaceColor, 1.0);\n  #endif\n\n  #ifdef LIGHTING_VERTEX\n  fragColor = vec4(vColor, 1.0);\n  #endif\n}\n",shaderInputs:this.shaderInputs,geometry:new m,instanceCount:1,bindings:{uTexture:n},parameters:{depthWriteEnabled:!0,depthCompare:"less-equal"}})}onFinalize(){this.model.destroy()}onRender(e){let{device:t,aspect:n,tick:i}=e;this.modelMatrix.identity().rotateX(.01*i).rotateY(.013*i),this.mvpMatrix.perspective({fovy:Math.PI/3,aspect:n}).multiplyRight(this.viewMatrix).multiplyRight(this.modelMatrix),this.shaderInputs.setProps({app:{mvpMatrix:this.mvpMatrix,modelMatrix:this.modelMatrix}});const r=t.beginRenderPass({clearColor:[0,0,0,1],clearDepth:!0});this.model.draw(r),r.end()}}const Fn="#version 300 es\n\nin vec2 position;\n\nvoid main() {\n  gl_Position = vec4(position, 0.0, 1.0);\n  OFFSET_POSITION(gl_Position);\n}\n",yn="#version 300 es\n\nuniform appUniforms {  \n  vec3 color;\n} app;\n\nout vec4 fragColor;\n\nvoid main() {\n  fragColor = vec4(app.color, 1.0);\n}\n",Mn={name:"offsetLeft",inject:{"vs:OFFSET_POSITION":"position.x -= 0.5;"}},On={name:"offsetRight",inject:{"vs:OFFSET_POSITION":"position.x += 0.5;"}};class Bn extends l{static info="\nModifying shader behavior with shader hooks\n";uniformStore=(()=>new s.K({app:{uniformTypes:{color:"vec3<f32>"}}}))();constructor(e){let{device:t}=e;super();const n=Fe._.getDefaultShaderAssembler();n.addShaderHook("vs:OFFSET_POSITION(inout vec4 position)"),this.positionBuffer=t.createBuffer(new Float32Array([-.3,-.5,.3,-.5,0,.5])),this.uniformBuffer1=this.uniformStore.createUniformBuffer(t,"app",{app:{color:[1,0,0]}});const i=this.uniformStore.getUniformBufferData("app");this.uniformBuffer1.write(i),this.uniformBuffer2=this.uniformStore.createUniformBuffer(t,"app",{app:{color:[0,0,1]}}),this.model1=new _.K(t,{vs:Fn,fs:yn,shaderAssembler:n,modules:[Mn],bufferLayout:[{name:"position",format:"float32x2"}],attributes:{position:this.positionBuffer},vertexCount:3,bindings:{app:this.uniformBuffer1}}),this.model2=new _.K(t,{vs:Fn,fs:yn,shaderAssembler:n,modules:[On],bufferLayout:[{name:"position",format:"float32x2"}],vertexCount:3,attributes:{position:this.positionBuffer},bindings:{app:this.uniformBuffer2}})}onFinalize(){this.model1.destroy(),this.model2.destroy(),this.positionBuffer.destroy(),this.uniformStore.destroy(),this.uniformBuffer1.destroy(),this.uniformBuffer2.destroy()}onRender(e){let{device:t}=e;const n=t.beginRenderPass({clearColor:[0,0,0,1]});this.model1.draw(n),this.model2.draw(n),n.end()}}const Dn={name:"color",fs:"\nvec3 color_hsv2rgb(vec3 hsv) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(hsv.xxx + K.xyz) * 6.0 - K.www);\n  vec3 rgb = hsv.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), hsv.y);\n  return rgb;\n}\n  ",uniformTypes:{hsv:"vec3<f32>"}};class wn extends l{static info="\nRe-using shader code with shader modules\n";shaderInputs1=(()=>new y.l({color:Dn}))();shaderInputs2=(()=>new y.l({color:Dn}))();constructor(e){let{device:t}=e;super(),this.positionBuffer=t.createBuffer(new Float32Array([-.3,-.5,.3,-.5,0,.5])),this.shaderInputs1.setProps({color:{hsv:[.7,1,1]}}),this.shaderInputs2.setProps({color:{hsv:[1,1,1]}}),this.model1=new _.K(t,{vs:"#version 300 es\nin vec2 position;\nvoid main() {\n  gl_Position = vec4(position - vec2(0.5, 0.0), 0.0, 1.0);\n}\n",fs:"#version 300 es\nprecision highp float;\n\nuniform colorUniforms {\n  vec3 hsv;\n} color;\n\nout vec4 fragColor;\n\nvoid main() {\n  fragColor = vec4(color_hsv2rgb(color.hsv), 1.0);\n}\n",shaderInputs:this.shaderInputs1,bufferLayout:[{name:"position",format:"float32x2"}],attributes:{position:this.positionBuffer},vertexCount:3}),this.model2=new _.K(t,{vs:"#version 300 es\nin vec2 position;\nvoid main() {\n  gl_Position = vec4(position + vec2(0.5, 0.0), 0.0, 1.0);\n}\n",fs:"#version 300 es\n\nprecision highp float;\n\nuniform colorUniforms {\n  vec3 hsv;\n} color;\n\nout vec4 fragColor;\n\nvoid main() {\n  fragColor = vec4(color_hsv2rgb(color.hsv) - 0.3, 1.0);\n}\n",shaderInputs:this.shaderInputs2,bufferLayout:[{name:"position",format:"float32x2"}],attributes:{position:this.positionBuffer},vertexCount:3})}onFinalize(){this.model1.destroy(),this.model2.destroy(),this.positionBuffer.destroy()}onRender(e){let{device:t}=e;const n=t.beginRenderPass({clearColor:[0,0,0,1]});this.model1.draw(n),this.model2.draw(n),n.end()}}class Un{static defaultProps=(()=>({..._.K.defaultProps,outputs:void 0,feedbackBuffers:void 0}))();static isSupported(e){return"webgl"===e?.info?.type}constructor(e,t){if(void 0===t&&(t=Un.defaultProps),!Un.isSupported(e))throw new Error("BufferTransform not yet implemented on WebGPU");this.device=e,this.model=new _.K(this.device,{id:t.id||"buffer-transform-model",fs:t.fs||Be(),topology:t.topology||"point-list",varyings:t.outputs||t.varyings,...t}),this.transformFeedback=this.device.createTransformFeedback({layout:this.model.pipeline.shaderLayout,buffers:t.feedbackBuffers}),this.model.setTransformFeedback(this.transformFeedback),Object.seal(this)}destroy(){this.model&&this.model.destroy()}delete(){this.destroy()}run(e){e?.inputBuffers&&this.model.setAttributes(e.inputBuffers),e?.outputBuffers&&this.transformFeedback.setBuffers(e.outputBuffers);const t=this.device.beginRenderPass(e);this.model.draw(t),t.end()}getBuffer(e){return this.transformFeedback.getBuffer(e)}readAsync(e){const t=this.getBuffer(e);if(!t)throw new Error("BufferTransform#getBuffer");if(t instanceof _n.h)return t.readAsync();const{buffer:n,byteOffset:i=0,byteLength:r=n.byteLength}=t;return n.readAsync(i,r)}}class Gn extends l{static info="\nAnimation via transform feedback.\n";constructor(e){let{device:t,animationLoop:n}=e;super(),"webgl"===t.type?(this.positionBuffers=new Se({current:t.createBuffer(new Float32Array([-.5,-.5,.5,-.5,0,.5])),next:t.createBuffer(new Float32Array(6))}),this.colorBuffer=t.createBuffer(new Float32Array([1,0,0,0,1,0,0,0,1])),this.transform=new Un(t,{vs:"#version 300 es\n#define SIN2 0.03489949\n#define COS2 0.99939082\n\nmat2 rotation = mat2(\n  COS2, SIN2,\n  -SIN2, COS2\n);\n\nin vec2 oldPositions;\nout vec2 newPositions;\n\nvoid main() {\n  newPositions = rotation * oldPositions;\n}\n",bufferLayout:[{name:"oldPositions",format:"float32x2"}],outputs:["newPositions"],vertexCount:3}),this.model=new _.K(t,{vs:"#version 300 es\n\nin vec2 position;\nin vec3 color;\nout vec3 vColor;\n\nvoid main() {\n    vColor = color;\n    gl_Position = vec4(position, 0.0, 1.0);\n}\n",fs:"#version 300 es\nprecision highp float;\n\nin vec3 vColor;\nout vec4 fragColor;\n\nvoid main() {\n    fragColor = vec4(vColor, 1.0);\n}\n",attributes:{color:this.colorBuffer},bufferLayout:[{name:"position",format:"float32x2"},{name:"color",format:"float32x3"}],vertexCount:3})):n.setError(new Error("This demo is only implemented for WebGL2"))}onFinalize(){this.transform.destroy(),this.model.destroy(),this.positionBuffers.destroy(),this.colorBuffer.destroy()}onRender(e){let{device:t}=e;this.transform.run({inputBuffers:{oldPositions:this.positionBuffers.current},outputBuffers:{newPositions:this.positionBuffers.next}}),this.positionBuffers.swap();const n=t.beginRenderPass({clearColor:[0,0,0,1]});this.model.setAttributes({position:this.positionBuffers.current}),this.model.draw(n),n.end()}}const Hn=a(),Xn=1e3;class Vn extends l{static info='\n<p>\n  Instanced triangles animated on the GPU using a luma.gl <code>BufferTransform</code> object.\n\n  This is a port of an example from\n  <a href="https://github.com/WebGLSamples/WebGL2Samples/blob/master/samples/transform_feedback_instanced.html">\n    WebGL2Samples\n  </a>\n';constructor(e){let{device:t,width:n,height:i,animationLoop:r}=e;if(super(),"webgl"!==t.type)return void r.setError(new Error("This demo is only implemented for WebGL2"));const o=new Float32Array([.015,0,-.01,.01,-.01,-.01]),s=new Float32Array(2e3),a=new Float32Array(Xn),l=new Float32Array(3e3),c=new Float32Array(2e3);for(let u=0;u<Xn;++u){s[2*u]=2*Hn()-1,s[2*u+1]=2*Hn()-1,a[u]=2*Hn()*Math.PI;Hn()>.5?(l[3*u+1]=1,l[3*u+2]=1):(l[3*u]=1,l[3*u+2]=1),c[2*u]=Math.floor(u/255),c[2*u+1]=u-255*c[2*u]}this.positionBuffer=t.createBuffer({data:o}),this.instanceColorBuffer=t.createBuffer({data:l}),this.instancePositionBuffers=new Se({current:t.createBuffer({data:s}),next:t.createBuffer({data:s})}),this.instanceRotationBuffers=new Se({current:t.createBuffer({data:a}),next:t.createBuffer({data:a})}),this.instancePickingColorBuffer=t.createBuffer({data:c}),this.renderModel=new _.K(t,{id:"RenderModel",vs:"#version 300 es\n#define OFFSET_LOCATION 0\n#define ROTATION_LOCATION 1\n#define POSITION_LOCATION 2\n#define COLOR_LOCATION 3\nprecision highp float;\nprecision highp int;\nlayout(location = POSITION_LOCATION) in vec2 positions;\nlayout(location = ROTATION_LOCATION) in float instanceRotations;\nlayout(location = OFFSET_LOCATION) in vec2 instancePositions;\nlayout(location = COLOR_LOCATION) in vec3 instanceColors;\nin vec2 instancePickingColors;\nout vec3 vColor;\nvoid main()\n{\n    vColor = instanceColors;\n\n    float cos_r = cos(instanceRotations);\n    float sin_r = sin(instanceRotations);\n    mat2 rot = mat2(\n        cos_r, sin_r,\n        -sin_r, cos_r\n    );\n    gl_Position = vec4(rot * positions + instancePositions, 0.0, 1.0);\n    picking_setPickingColor(vec3(0., instancePickingColors));\n}\n",fs:"#version 300 es\n#define ALPHA 0.9\nprecision highp float;\nprecision highp int;\nin vec3 vColor;\nout vec4 fragColor;\nvoid main()\n{\n    fragColor = vec4(vColor * ALPHA, ALPHA);\n    fragColor = picking_filterColor(fragColor);\n}\n",modules:[ot],topology:"triangle-list",vertexCount:3,isInstanced:!0,instanceCount:Xn,attributes:{positions:this.positionBuffer,instanceColors:this.instanceColorBuffer,instancePickingColors:this.instancePickingColorBuffer},bufferLayout:[{name:"positions",format:"float32x2"},{name:"instancePositions",format:"float32x2"},{name:"instanceRotations",format:"float32"},{name:"instanceColors",format:"float32x3"},{name:"instancePickingColors",format:"float32x2"}]}),this.transform=new Un(t,{vs:"#version 300 es\n#define OFFSET_LOCATION 0\n#define ROTATION_LOCATION 1\n\n#define M_2PI 6.28318530718\n\n#define MAP_HALF_LENGTH 1.01\n#define WANDER_CIRCLE_R 0.01\n#define WANDER_CIRCLE_OFFSET 0.04\n#define MOVE_DELTA 0.001\nprecision highp float;\nprecision highp int;\nuniform float u_time;\n\nlayout(location = OFFSET_LOCATION) in vec2 oldPositions;\nlayout(location = ROTATION_LOCATION) in float oldRotations;\n\nout vec2 newOffsets;\nout float newRotations;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    float theta = M_2PI * rand(vec2(u_time, oldRotations + oldPositions.x + oldPositions.y));\n    float cos_r = cos(oldRotations);\n    float sin_r = sin(oldRotations);\n    mat2 rot = mat2(\n        cos_r, sin_r,\n        -sin_r, cos_r\n    );\n\n    vec2 p = WANDER_CIRCLE_R * vec2(cos(theta), sin(theta)) + vec2(WANDER_CIRCLE_OFFSET, 0.0);\n    \n    vec2 move = normalize(rot * p);\n    newRotations = atan(move.y, move.x);\n    newOffsets = oldPositions + MOVE_DELTA * move;\n\n    // wrapping at edges\n    newOffsets = vec2 (\n        newOffsets.x > MAP_HALF_LENGTH ? - MAP_HALF_LENGTH :\n          ( newOffsets.x < - MAP_HALF_LENGTH ? MAP_HALF_LENGTH : newOffsets.x ) ,\n        newOffsets.y > MAP_HALF_LENGTH ? - MAP_HALF_LENGTH :\n          ( newOffsets.y < - MAP_HALF_LENGTH ? MAP_HALF_LENGTH : newOffsets.y )\n        );\n\n    gl_Position = vec4(newOffsets, 0.0, 1.0);\n}\n",vertexCount:Xn,bufferLayout:[{name:"oldPositions",format:"float32x2"},{name:"oldRotations",format:"float32"}],outputs:["newOffsets","newRotations"]})}onFinalize(){this.renderModel.destroy(),this.transform.destroy()}onRender(e){let{device:t,width:n,height:i,time:r}=e;this.transform.model.setUniforms({u_time:r}),this.transform.run({inputBuffers:{oldPositions:this.instancePositionBuffers.current,oldRotations:this.instanceRotationBuffers.current},outputBuffers:{newOffsets:this.instancePositionBuffers.next,newRotations:this.instanceRotationBuffers.next}}),this.instancePositionBuffers.swap(),this.instanceRotationBuffers.swap(),this.renderModel.setAttributes({instancePositions:this.instancePositionBuffers.current,instanceRotations:this.instanceRotationBuffers.current});const o=t.beginRenderPass({clearColor:[0,0,0,1],clearDepth:!0});this.renderModel.draw(o)}}const kn={},Wn=()=>r.createElement(o.fo,{id:"animation",directory:"api",template:F,config:kn}),Yn=()=>r.createElement(o.fo,{id:"cubemap",directory:"api",template:U,config:kn}),zn=()=>r.createElement(o.fo,{id:"texture-3d",directory:"api-3d",template:z,config:kn}),Kn=()=>r.createElement(o.fo,{id:"instancing",directory:"showcase",template:te,config:kn}),jn=()=>r.createElement(o.fo,{id:"persistence",directory:"showcase",template:Re,config:kn}),Qn=()=>r.createElement(o.fo,{id:"postprocessing",directory:"showcase",template:on,config:kn}),$n=()=>r.createElement(o.fo,{id:"hello-cube",directory:"tutorials",template:fn,config:kn}),qn=()=>r.createElement(o.fo,{id:"hello-instancing",directory:"tutorials",template:An,config:kn}),Zn=()=>r.createElement(o.fo,{id:"hello-triangle",directory:"tutorials",template:an,config:kn}),Jn=()=>r.createElement(o.fo,{id:"lighting",directory:"tutorials",template:Ln,config:kn}),ei=()=>r.createElement(o.fo,{id:"hello-gltf",directory:"tutorials",template:Cn,config:kn}),ti=()=>r.createElement(o.fo,{id:"shader-hooks",directory:"tutorials",template:Bn,config:kn}),ni=()=>r.createElement(o.fo,{id:"shader-modules",directory:"tutorials",template:wn,config:kn}),ii=()=>r.createElement(o.fo,{id:"transform-feedback",directory:"tutorials",template:Gn,config:kn}),ri=()=>r.createElement(o.fo,{id:"transform",directory:"tutorials",template:Vn,config:kn}),oi=()=>r.createElement(o.fo,{id:"hello-triangle-geometry",directory:"tutorials",template:sn,config:kn}),si=()=>r.createElement(o.fo,{id:"instanced-cubes",directory:"tutorials",template:pn,config:kn}),ai=()=>r.createElement(o.fo,{id:"two-cubes",directory:"tutorials",template:hn,config:kn})},5783:(e,t,n)=>{n.d(t,{xN:()=>ri,Xj:()=>ai,dJ:()=>ci,yL:()=>li,R2:()=>oi,I$:()=>si,fo:()=>pi,dw:()=>ui});var i=n(6540),r=n(5556),o=n.n(r);function s(){return s=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var i in n)Object.prototype.hasOwnProperty.call(n,i)&&(e[i]=n[i])}return e},s.apply(this,arguments)}class a extends i.Component{static displayName="Base Icon";static propTypes=(()=>({height:o().string,width:o().string,viewBox:o().string,children:o().node,predefinedClassName:o().string,className:o().string}))();static defaultProps={height:null,width:null,viewBox:"0 0 64 64",predefinedClassName:"",className:""};render(){const{height:e,width:t,viewBox:n,style:r={},children:o,predefinedClassName:a,className:l,colors:c,totalColor:u,...d}=this.props,f=e,_=t||f;r.fill="currentColor";const h=Array.isArray(c)&&u&&((e,t)=>new Array(e).fill(1).reduce(((e,n,i)=>`${e}.cr${i+1} {fill:${t[i%t.length]};}`),""))(u,c);return i.createElement("svg",s({viewBox:n,width:_,height:f,style:r,className:`${a} ${l}`},d),h?i.createElement("style",{type:"text/css"},h):null,o)}}const l=e=>i.createElement(a,e,i.createElement("path",{fillRule:"evenodd",clipRule:"evenodd",d:"M5.02167 13.7625C4.69623 13.4459 4.69623 12.9325 5.02167 12.6159L9.76574 8.00002L5.02167 3.38416C4.69623 3.06752 4.69623 2.55415 5.02167 2.2375C5.3471 1.92086 5.87474 1.92086 6.20018 2.2375L11.5335 7.42669C11.6898 7.57875 11.7776 7.78498 11.7776 8.00002C11.7776 8.21506 11.6898 8.4213 11.5335 8.57335L6.20018 13.7625C5.87474 14.0792 5.3471 14.0792 5.02167 13.7625Z"}));l.propTypes={height:o().string},l.defaultProps={height:"16px",viewBox:"0 0 17 16",predefinedClassName:"unfolded-icons-arrowbigright"};var c=n(4745),u=n(6769),d=n(6237);const f=new class{stats=(()=>new Map)();getStats(e){return this.get(e)}get(e){return this.stats.has(e)||this.stats.set(e,new d.A({id:e})),this.stats.get(e)}};var _=n(8862),h=n(1010),p=n(8564),m=n(6700);const g=["bc1","bc2","bc3","bc4","bc5","bc6","bc7","etc1","etc2","eac","atc","astc","pvrtc"],E=/^(r|rg|rgb|rgba|bgra)([0-9]*)([a-z]*)(-srgb)?(-webgl)?$/;function A(e){return g.some((t=>e.startsWith(t)))}function v(e){const t=E.exec(e);if(t){const[,n,i,r,o,s]=t;if(e){const e=`${r}${i}`,t=(0,m.l)(e),a={channels:n,components:n.length,bitsPerChannel:8*t.byteLength,bytesPerPixel:t.byteLength*n.length,dataType:t.dataType,integer:t.integer,signed:t.signed,normalized:t.normalized};return"-webgl"===s&&(a.webgl=!0),"-srgb"===o&&(a.srgb=!0),a}}return function(e){if(A(e)){const t={channels:"rgb",components:3,bytesPerPixel:1,srgb:!1,compressed:!0},n=function(e){const t=/.*-(\d+)x(\d+)-.*/.exec(e);if(t){const[,e,n]=t;return{blockWidth:Number(e),blockHeight:Number(n)}}return null}(e);return n&&(t.blockWidth=n.blockWidth,t.blockHeight=n.blockHeight),t}const t=T[e];if(!t)throw new Error(`Unknown format ${e}`);const n={...t,channels:t.channels||"",components:t.components||t.channels?.length||1,bytesPerPixel:t.bytesPerPixel||1,srgb:!1};t.packed&&(n.packed=t.packed);return n}(e)}const T={"rgba4unorm-webgl":{channels:"rgba",bytesPerPixel:2,packed:!0},"rgb565unorm-webgl":{channels:"rgb",bytesPerPixel:2,packed:!0},"rgb5a1unorm-webgl":{channels:"rgba",bytesPerPixel:2,packed:!0},rgb9e5ufloat:{channels:"rgb",bytesPerPixel:4,packed:!0},rg11b10ufloat:{channels:"rgb",bytesPerPixel:4,packed:!0},rgb10a2unorm:{channels:"rgba",bytesPerPixel:4,packed:!0},"rgb10a2uint-webgl":{channels:"rgba",bytesPerPixel:4,packed:!0},stencil8:{components:1,bytesPerPixel:1,a:"stencil",dataType:"uint8"},depth16unorm:{components:1,bytesPerPixel:2,a:"depth",dataType:"uint16"},depth24plus:{components:1,bytesPerPixel:3,a:"depth",dataType:"uint32"},depth32float:{components:1,bytesPerPixel:4,a:"depth",dataType:"float32"},"depth24plus-stencil8":{components:2,bytesPerPixel:4,a:"depth-stencil",packed:!0},"depth32float-stencil8":{components:2,bytesPerPixel:4,a:"depth-stencil",packed:!0}};class R{}class b{constructor(e,t){void 0===e&&(e=[]),this.features=new Set(e),this.disabledFeatures=t||{}}*[Symbol.iterator](){yield*this.features}has(e){return!this.disabledFeatures?.[e]&&this.features.has(e)}}class S{static defaultProps=(()=>({id:null,powerPreference:"high-performance",failIfMajorPerformanceCaveat:!1,createCanvasContext:void 0,onError:e=>_.R.error(e.message),_factoryDestroyPolicy:"unused",_initializeFeatures:!0,_disabledFeatures:{"compilation-status-async-webgl":!0},_requestMaxLimits:!0,webgl:{},debug:_.R.get("debug")||void 0,debugShaders:_.R.get("debug-shaders")||void 0,debugFramebuffers:Boolean(_.R.get("debug-framebuffers")),debugWebGL:Boolean(_.R.get("debug-webgl")),debugSpectorJS:void 0,debugSpectorJSUrl:void 0,_handle:void 0}))();get[Symbol.toStringTag](){return"Device"}constructor(e){this.props={...S.defaultProps,...e},this.id=this.props.id||(0,h.L)(this[Symbol.toStringTag].toLowerCase())}userData={};statsManager=(()=>f)();timestamp=0;_lumaData={};isTextureFormatCompressed(e){return A(e)}loseDevice(){return!1}error(e){this.props.onError(e)}getDefaultCanvasContext(){if(!this.canvasContext)throw new Error("Device has no default CanvasContext. See props.createCanvasContext");return this.canvasContext}createCommandEncoder(e){throw void 0===e&&(e={}),new Error("not implemented")}incrementTimestamp(){return this.timestamp++}onError(e){this.props.onError(e)}getCanvasContext(){return this.getDefaultCanvasContext()}readPixelsToArrayWebGL(e,t){throw new Error("not implemented")}readPixelsToBufferWebGL(e,t){throw new Error("not implemented")}setParametersWebGL(e){throw new Error("not implemented")}getParametersWebGL(e){throw new Error("not implemented")}withParametersWebGL(e,t){throw new Error("not implemented")}clearWebGL(e){throw new Error("not implemented")}resetWebGL(){throw new Error("not implemented")}_normalizeBufferProps(e){(e instanceof ArrayBuffer||ArrayBuffer.isView(e))&&(e={data:e});const t={...e};return(e.usage||0)&p.h.INDEX&&!e.indexType&&(e.data instanceof Uint32Array?t.indexType="uint32":e.data instanceof Uint16Array?t.indexType="uint16":_.R.warn("indices buffer content must be of integer type")()),t}}const C=(0,u.B)()&&"undefined"!=typeof document,I="No matching device found. Ensure `@luma.gl/webgl` and/or `@luma.gl/webgpu` modules are imported.";class P{static defaultProps=(()=>({...S.defaultProps,type:"best-available",adapters:void 0,waitForPageLoad:!0}))();static pageLoaded=(()=>function(){if(C&&"complete"===document.readyState||"undefined"==typeof window)return Promise.resolve();return new Promise((e=>{window.addEventListener("load",(()=>e()))}))}().then((()=>{_.R.probe(2,"DOM is loaded")()})))();stats=(()=>f)();log=(()=>_.R)();VERSION=(()=>"undefined"!=typeof __VERSION__?__VERSION__:"running from source")();preregisteredAdapters=(()=>new Map)();constructor(){if(globalThis.luma){if(globalThis.luma.VERSION!==this.VERSION)throw _.R.error(`Found luma.gl ${globalThis.luma.VERSION} while initialzing ${this.VERSION}`)(),_.R.error("'yarn why @luma.gl/core' can help identify the source of the conflict")(),new Error("luma.gl - multiple versions detected: see console log");_.R.error("This version of luma.gl has already been initialized")()}_.R.log(1,`${this.VERSION} - set luma.log.level=1 (or higher) to trace rendering`)(),globalThis.luma=this}registerAdapters(e){for(const t of e)this.preregisteredAdapters.set(t.type,t)}getSupportedAdapters(e){void 0===e&&(e=[]);const t=this.getAdapterMap(e);return Array.from(t).map((e=>{let[,t]=e;return t})).filter((e=>e.isSupported?.())).map((e=>e.type))}getBestAvailableAdapter(e){void 0===e&&(e=[]);const t=this.getAdapterMap(e);return t.get("webgpu")?.isSupported?.()?"webgpu":t.get("webgl")?.isSupported?.()?"webgl":null}setDefaultDeviceProps(e){Object.assign(P.defaultProps,e)}async createDevice(e){void 0===e&&(e={}),(e={...P.defaultProps,...e}).waitForPageLoad&&await P.pageLoaded;const t=this.getAdapterMap(e.adapters);let n=e.type||"";"best-available"===n&&(n=this.getBestAvailableAdapter(e.adapters)||n);const i=(this.getAdapterMap(e.adapters)||t).get(n),r=await(i?.create?.(e));if(r)return r;throw new Error(I)}async attachDevice(e){const t=this.getAdapterMap(e.adapters);let n="";e.handle instanceof WebGL2RenderingContext&&(n="webgl"),e.createCanvasContext&&await P.pageLoaded,null===e.handle&&(n="unknown");const i=t.get(n),r=await(i?.attach?.(null));if(r)return r;throw new Error(I)}enforceWebGL2(e,t){void 0===e&&(e=!0),void 0===t&&(t=[]);const n=this.getAdapterMap(t).get("webgl");n||_.R.warn("enforceWebGL2: webgl adapter not found")(),n?.enforceWebGL2?.(e)}getAdapterMap(e){void 0===e&&(e=[]);const t=new Map(this.preregisteredAdapters);for(const n of e)t.set(n.type,n);return t}registerDevices(e){_.R.warn("luma.registerDevices() is deprecated, use luma.registerAdapters() instead");for(const t of e){const e=t.adapter;e&&this.preregisteredAdapters.set(e.type,e)}}}const x=new P;class N{}var L=function(e){return e[e.DEPTH_BUFFER_BIT=256]="DEPTH_BUFFER_BIT",e[e.STENCIL_BUFFER_BIT=1024]="STENCIL_BUFFER_BIT",e[e.COLOR_BUFFER_BIT=16384]="COLOR_BUFFER_BIT",e[e.POINTS=0]="POINTS",e[e.LINES=1]="LINES",e[e.LINE_LOOP=2]="LINE_LOOP",e[e.LINE_STRIP=3]="LINE_STRIP",e[e.TRIANGLES=4]="TRIANGLES",e[e.TRIANGLE_STRIP=5]="TRIANGLE_STRIP",e[e.TRIANGLE_FAN=6]="TRIANGLE_FAN",e[e.ZERO=0]="ZERO",e[e.ONE=1]="ONE",e[e.SRC_COLOR=768]="SRC_COLOR",e[e.ONE_MINUS_SRC_COLOR=769]="ONE_MINUS_SRC_COLOR",e[e.SRC_ALPHA=770]="SRC_ALPHA",e[e.ONE_MINUS_SRC_ALPHA=771]="ONE_MINUS_SRC_ALPHA",e[e.DST_ALPHA=772]="DST_ALPHA",e[e.ONE_MINUS_DST_ALPHA=773]="ONE_MINUS_DST_ALPHA",e[e.DST_COLOR=774]="DST_COLOR",e[e.ONE_MINUS_DST_COLOR=775]="ONE_MINUS_DST_COLOR",e[e.SRC_ALPHA_SATURATE=776]="SRC_ALPHA_SATURATE",e[e.CONSTANT_COLOR=32769]="CONSTANT_COLOR",e[e.ONE_MINUS_CONSTANT_COLOR=32770]="ONE_MINUS_CONSTANT_COLOR",e[e.CONSTANT_ALPHA=32771]="CONSTANT_ALPHA",e[e.ONE_MINUS_CONSTANT_ALPHA=32772]="ONE_MINUS_CONSTANT_ALPHA",e[e.FUNC_ADD=32774]="FUNC_ADD",e[e.FUNC_SUBTRACT=32778]="FUNC_SUBTRACT",e[e.FUNC_REVERSE_SUBTRACT=32779]="FUNC_REVERSE_SUBTRACT",e[e.BLEND_EQUATION=32777]="BLEND_EQUATION",e[e.BLEND_EQUATION_RGB=32777]="BLEND_EQUATION_RGB",e[e.BLEND_EQUATION_ALPHA=34877]="BLEND_EQUATION_ALPHA",e[e.BLEND_DST_RGB=32968]="BLEND_DST_RGB",e[e.BLEND_SRC_RGB=32969]="BLEND_SRC_RGB",e[e.BLEND_DST_ALPHA=32970]="BLEND_DST_ALPHA",e[e.BLEND_SRC_ALPHA=32971]="BLEND_SRC_ALPHA",e[e.BLEND_COLOR=32773]="BLEND_COLOR",e[e.ARRAY_BUFFER_BINDING=34964]="ARRAY_BUFFER_BINDING",e[e.ELEMENT_ARRAY_BUFFER_BINDING=34965]="ELEMENT_ARRAY_BUFFER_BINDING",e[e.LINE_WIDTH=2849]="LINE_WIDTH",e[e.ALIASED_POINT_SIZE_RANGE=33901]="ALIASED_POINT_SIZE_RANGE",e[e.ALIASED_LINE_WIDTH_RANGE=33902]="ALIASED_LINE_WIDTH_RANGE",e[e.CULL_FACE_MODE=2885]="CULL_FACE_MODE",e[e.FRONT_FACE=2886]="FRONT_FACE",e[e.DEPTH_RANGE=2928]="DEPTH_RANGE",e[e.DEPTH_WRITEMASK=2930]="DEPTH_WRITEMASK",e[e.DEPTH_CLEAR_VALUE=2931]="DEPTH_CLEAR_VALUE",e[e.DEPTH_FUNC=2932]="DEPTH_FUNC",e[e.STENCIL_CLEAR_VALUE=2961]="STENCIL_CLEAR_VALUE",e[e.STENCIL_FUNC=2962]="STENCIL_FUNC",e[e.STENCIL_FAIL=2964]="STENCIL_FAIL",e[e.STENCIL_PASS_DEPTH_FAIL=2965]="STENCIL_PASS_DEPTH_FAIL",e[e.STENCIL_PASS_DEPTH_PASS=2966]="STENCIL_PASS_DEPTH_PASS",e[e.STENCIL_REF=2967]="STENCIL_REF",e[e.STENCIL_VALUE_MASK=2963]="STENCIL_VALUE_MASK",e[e.STENCIL_WRITEMASK=2968]="STENCIL_WRITEMASK",e[e.STENCIL_BACK_FUNC=34816]="STENCIL_BACK_FUNC",e[e.STENCIL_BACK_FAIL=34817]="STENCIL_BACK_FAIL",e[e.STENCIL_BACK_PASS_DEPTH_FAIL=34818]="STENCIL_BACK_PASS_DEPTH_FAIL",e[e.STENCIL_BACK_PASS_DEPTH_PASS=34819]="STENCIL_BACK_PASS_DEPTH_PASS",e[e.STENCIL_BACK_REF=36003]="STENCIL_BACK_REF",e[e.STENCIL_BACK_VALUE_MASK=36004]="STENCIL_BACK_VALUE_MASK",e[e.STENCIL_BACK_WRITEMASK=36005]="STENCIL_BACK_WRITEMASK",e[e.VIEWPORT=2978]="VIEWPORT",e[e.SCISSOR_BOX=3088]="SCISSOR_BOX",e[e.COLOR_CLEAR_VALUE=3106]="COLOR_CLEAR_VALUE",e[e.COLOR_WRITEMASK=3107]="COLOR_WRITEMASK",e[e.UNPACK_ALIGNMENT=3317]="UNPACK_ALIGNMENT",e[e.PACK_ALIGNMENT=3333]="PACK_ALIGNMENT",e[e.MAX_TEXTURE_SIZE=3379]="MAX_TEXTURE_SIZE",e[e.MAX_VIEWPORT_DIMS=3386]="MAX_VIEWPORT_DIMS",e[e.SUBPIXEL_BITS=3408]="SUBPIXEL_BITS",e[e.RED_BITS=3410]="RED_BITS",e[e.GREEN_BITS=3411]="GREEN_BITS",e[e.BLUE_BITS=3412]="BLUE_BITS",e[e.ALPHA_BITS=3413]="ALPHA_BITS",e[e.DEPTH_BITS=3414]="DEPTH_BITS",e[e.STENCIL_BITS=3415]="STENCIL_BITS",e[e.POLYGON_OFFSET_UNITS=10752]="POLYGON_OFFSET_UNITS",e[e.POLYGON_OFFSET_FACTOR=32824]="POLYGON_OFFSET_FACTOR",e[e.TEXTURE_BINDING_2D=32873]="TEXTURE_BINDING_2D",e[e.SAMPLE_BUFFERS=32936]="SAMPLE_BUFFERS",e[e.SAMPLES=32937]="SAMPLES",e[e.SAMPLE_COVERAGE_VALUE=32938]="SAMPLE_COVERAGE_VALUE",e[e.SAMPLE_COVERAGE_INVERT=32939]="SAMPLE_COVERAGE_INVERT",e[e.COMPRESSED_TEXTURE_FORMATS=34467]="COMPRESSED_TEXTURE_FORMATS",e[e.VENDOR=7936]="VENDOR",e[e.RENDERER=7937]="RENDERER",e[e.VERSION=7938]="VERSION",e[e.IMPLEMENTATION_COLOR_READ_TYPE=35738]="IMPLEMENTATION_COLOR_READ_TYPE",e[e.IMPLEMENTATION_COLOR_READ_FORMAT=35739]="IMPLEMENTATION_COLOR_READ_FORMAT",e[e.BROWSER_DEFAULT_WEBGL=37444]="BROWSER_DEFAULT_WEBGL",e[e.STATIC_DRAW=35044]="STATIC_DRAW",e[e.STREAM_DRAW=35040]="STREAM_DRAW",e[e.DYNAMIC_DRAW=35048]="DYNAMIC_DRAW",e[e.ARRAY_BUFFER=34962]="ARRAY_BUFFER",e[e.ELEMENT_ARRAY_BUFFER=34963]="ELEMENT_ARRAY_BUFFER",e[e.BUFFER_SIZE=34660]="BUFFER_SIZE",e[e.BUFFER_USAGE=34661]="BUFFER_USAGE",e[e.CURRENT_VERTEX_ATTRIB=34342]="CURRENT_VERTEX_ATTRIB",e[e.VERTEX_ATTRIB_ARRAY_ENABLED=34338]="VERTEX_ATTRIB_ARRAY_ENABLED",e[e.VERTEX_ATTRIB_ARRAY_SIZE=34339]="VERTEX_ATTRIB_ARRAY_SIZE",e[e.VERTEX_ATTRIB_ARRAY_STRIDE=34340]="VERTEX_ATTRIB_ARRAY_STRIDE",e[e.VERTEX_ATTRIB_ARRAY_TYPE=34341]="VERTEX_ATTRIB_ARRAY_TYPE",e[e.VERTEX_ATTRIB_ARRAY_NORMALIZED=34922]="VERTEX_ATTRIB_ARRAY_NORMALIZED",e[e.VERTEX_ATTRIB_ARRAY_POINTER=34373]="VERTEX_ATTRIB_ARRAY_POINTER",e[e.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING=34975]="VERTEX_ATTRIB_ARRAY_BUFFER_BINDING",e[e.CULL_FACE=2884]="CULL_FACE",e[e.FRONT=1028]="FRONT",e[e.BACK=1029]="BACK",e[e.FRONT_AND_BACK=1032]="FRONT_AND_BACK",e[e.BLEND=3042]="BLEND",e[e.DEPTH_TEST=2929]="DEPTH_TEST",e[e.DITHER=3024]="DITHER",e[e.POLYGON_OFFSET_FILL=32823]="POLYGON_OFFSET_FILL",e[e.SAMPLE_ALPHA_TO_COVERAGE=32926]="SAMPLE_ALPHA_TO_COVERAGE",e[e.SAMPLE_COVERAGE=32928]="SAMPLE_COVERAGE",e[e.SCISSOR_TEST=3089]="SCISSOR_TEST",e[e.STENCIL_TEST=2960]="STENCIL_TEST",e[e.NO_ERROR=0]="NO_ERROR",e[e.INVALID_ENUM=1280]="INVALID_ENUM",e[e.INVALID_VALUE=1281]="INVALID_VALUE",e[e.INVALID_OPERATION=1282]="INVALID_OPERATION",e[e.OUT_OF_MEMORY=1285]="OUT_OF_MEMORY",e[e.CONTEXT_LOST_WEBGL=37442]="CONTEXT_LOST_WEBGL",e[e.CW=2304]="CW",e[e.CCW=2305]="CCW",e[e.DONT_CARE=4352]="DONT_CARE",e[e.FASTEST=4353]="FASTEST",e[e.NICEST=4354]="NICEST",e[e.GENERATE_MIPMAP_HINT=33170]="GENERATE_MIPMAP_HINT",e[e.BYTE=5120]="BYTE",e[e.UNSIGNED_BYTE=5121]="UNSIGNED_BYTE",e[e.SHORT=5122]="SHORT",e[e.UNSIGNED_SHORT=5123]="UNSIGNED_SHORT",e[e.INT=5124]="INT",e[e.UNSIGNED_INT=5125]="UNSIGNED_INT",e[e.FLOAT=5126]="FLOAT",e[e.DOUBLE=5130]="DOUBLE",e[e.DEPTH_COMPONENT=6402]="DEPTH_COMPONENT",e[e.ALPHA=6406]="ALPHA",e[e.RGB=6407]="RGB",e[e.RGBA=6408]="RGBA",e[e.LUMINANCE=6409]="LUMINANCE",e[e.LUMINANCE_ALPHA=6410]="LUMINANCE_ALPHA",e[e.UNSIGNED_SHORT_4_4_4_4=32819]="UNSIGNED_SHORT_4_4_4_4",e[e.UNSIGNED_SHORT_5_5_5_1=32820]="UNSIGNED_SHORT_5_5_5_1",e[e.UNSIGNED_SHORT_5_6_5=33635]="UNSIGNED_SHORT_5_6_5",e[e.FRAGMENT_SHADER=35632]="FRAGMENT_SHADER",e[e.VERTEX_SHADER=35633]="VERTEX_SHADER",e[e.COMPILE_STATUS=35713]="COMPILE_STATUS",e[e.DELETE_STATUS=35712]="DELETE_STATUS",e[e.LINK_STATUS=35714]="LINK_STATUS",e[e.VALIDATE_STATUS=35715]="VALIDATE_STATUS",e[e.ATTACHED_SHADERS=35717]="ATTACHED_SHADERS",e[e.ACTIVE_ATTRIBUTES=35721]="ACTIVE_ATTRIBUTES",e[e.ACTIVE_UNIFORMS=35718]="ACTIVE_UNIFORMS",e[e.MAX_VERTEX_ATTRIBS=34921]="MAX_VERTEX_ATTRIBS",e[e.MAX_VERTEX_UNIFORM_VECTORS=36347]="MAX_VERTEX_UNIFORM_VECTORS",e[e.MAX_VARYING_VECTORS=36348]="MAX_VARYING_VECTORS",e[e.MAX_COMBINED_TEXTURE_IMAGE_UNITS=35661]="MAX_COMBINED_TEXTURE_IMAGE_UNITS",e[e.MAX_VERTEX_TEXTURE_IMAGE_UNITS=35660]="MAX_VERTEX_TEXTURE_IMAGE_UNITS",e[e.MAX_TEXTURE_IMAGE_UNITS=34930]="MAX_TEXTURE_IMAGE_UNITS",e[e.MAX_FRAGMENT_UNIFORM_VECTORS=36349]="MAX_FRAGMENT_UNIFORM_VECTORS",e[e.SHADER_TYPE=35663]="SHADER_TYPE",e[e.SHADING_LANGUAGE_VERSION=35724]="SHADING_LANGUAGE_VERSION",e[e.CURRENT_PROGRAM=35725]="CURRENT_PROGRAM",e[e.NEVER=512]="NEVER",e[e.LESS=513]="LESS",e[e.EQUAL=514]="EQUAL",e[e.LEQUAL=515]="LEQUAL",e[e.GREATER=516]="GREATER",e[e.NOTEQUAL=517]="NOTEQUAL",e[e.GEQUAL=518]="GEQUAL",e[e.ALWAYS=519]="ALWAYS",e[e.KEEP=7680]="KEEP",e[e.REPLACE=7681]="REPLACE",e[e.INCR=7682]="INCR",e[e.DECR=7683]="DECR",e[e.INVERT=5386]="INVERT",e[e.INCR_WRAP=34055]="INCR_WRAP",e[e.DECR_WRAP=34056]="DECR_WRAP",e[e.NEAREST=9728]="NEAREST",e[e.LINEAR=9729]="LINEAR",e[e.NEAREST_MIPMAP_NEAREST=9984]="NEAREST_MIPMAP_NEAREST",e[e.LINEAR_MIPMAP_NEAREST=9985]="LINEAR_MIPMAP_NEAREST",e[e.NEAREST_MIPMAP_LINEAR=9986]="NEAREST_MIPMAP_LINEAR",e[e.LINEAR_MIPMAP_LINEAR=9987]="LINEAR_MIPMAP_LINEAR",e[e.TEXTURE_MAG_FILTER=10240]="TEXTURE_MAG_FILTER",e[e.TEXTURE_MIN_FILTER=10241]="TEXTURE_MIN_FILTER",e[e.TEXTURE_WRAP_S=10242]="TEXTURE_WRAP_S",e[e.TEXTURE_WRAP_T=10243]="TEXTURE_WRAP_T",e[e.TEXTURE_2D=3553]="TEXTURE_2D",e[e.TEXTURE=5890]="TEXTURE",e[e.TEXTURE_CUBE_MAP=34067]="TEXTURE_CUBE_MAP",e[e.TEXTURE_BINDING_CUBE_MAP=34068]="TEXTURE_BINDING_CUBE_MAP",e[e.TEXTURE_CUBE_MAP_POSITIVE_X=34069]="TEXTURE_CUBE_MAP_POSITIVE_X",e[e.TEXTURE_CUBE_MAP_NEGATIVE_X=34070]="TEXTURE_CUBE_MAP_NEGATIVE_X",e[e.TEXTURE_CUBE_MAP_POSITIVE_Y=34071]="TEXTURE_CUBE_MAP_POSITIVE_Y",e[e.TEXTURE_CUBE_MAP_NEGATIVE_Y=34072]="TEXTURE_CUBE_MAP_NEGATIVE_Y",e[e.TEXTURE_CUBE_MAP_POSITIVE_Z=34073]="TEXTURE_CUBE_MAP_POSITIVE_Z",e[e.TEXTURE_CUBE_MAP_NEGATIVE_Z=34074]="TEXTURE_CUBE_MAP_NEGATIVE_Z",e[e.MAX_CUBE_MAP_TEXTURE_SIZE=34076]="MAX_CUBE_MAP_TEXTURE_SIZE",e[e.TEXTURE0=33984]="TEXTURE0",e[e.ACTIVE_TEXTURE=34016]="ACTIVE_TEXTURE",e[e.REPEAT=10497]="REPEAT",e[e.CLAMP_TO_EDGE=33071]="CLAMP_TO_EDGE",e[e.MIRRORED_REPEAT=33648]="MIRRORED_REPEAT",e[e.TEXTURE_WIDTH=4096]="TEXTURE_WIDTH",e[e.TEXTURE_HEIGHT=4097]="TEXTURE_HEIGHT",e[e.FLOAT_VEC2=35664]="FLOAT_VEC2",e[e.FLOAT_VEC3=35665]="FLOAT_VEC3",e[e.FLOAT_VEC4=35666]="FLOAT_VEC4",e[e.INT_VEC2=35667]="INT_VEC2",e[e.INT_VEC3=35668]="INT_VEC3",e[e.INT_VEC4=35669]="INT_VEC4",e[e.BOOL=35670]="BOOL",e[e.BOOL_VEC2=35671]="BOOL_VEC2",e[e.BOOL_VEC3=35672]="BOOL_VEC3",e[e.BOOL_VEC4=35673]="BOOL_VEC4",e[e.FLOAT_MAT2=35674]="FLOAT_MAT2",e[e.FLOAT_MAT3=35675]="FLOAT_MAT3",e[e.FLOAT_MAT4=35676]="FLOAT_MAT4",e[e.SAMPLER_2D=35678]="SAMPLER_2D",e[e.SAMPLER_CUBE=35680]="SAMPLER_CUBE",e[e.LOW_FLOAT=36336]="LOW_FLOAT",e[e.MEDIUM_FLOAT=36337]="MEDIUM_FLOAT",e[e.HIGH_FLOAT=36338]="HIGH_FLOAT",e[e.LOW_INT=36339]="LOW_INT",e[e.MEDIUM_INT=36340]="MEDIUM_INT",e[e.HIGH_INT=36341]="HIGH_INT",e[e.FRAMEBUFFER=36160]="FRAMEBUFFER",e[e.RENDERBUFFER=36161]="RENDERBUFFER",e[e.RGBA4=32854]="RGBA4",e[e.RGB5_A1=32855]="RGB5_A1",e[e.RGB565=36194]="RGB565",e[e.DEPTH_COMPONENT16=33189]="DEPTH_COMPONENT16",e[e.STENCIL_INDEX=6401]="STENCIL_INDEX",e[e.STENCIL_INDEX8=36168]="STENCIL_INDEX8",e[e.DEPTH_STENCIL=34041]="DEPTH_STENCIL",e[e.RENDERBUFFER_WIDTH=36162]="RENDERBUFFER_WIDTH",e[e.RENDERBUFFER_HEIGHT=36163]="RENDERBUFFER_HEIGHT",e[e.RENDERBUFFER_INTERNAL_FORMAT=36164]="RENDERBUFFER_INTERNAL_FORMAT",e[e.RENDERBUFFER_RED_SIZE=36176]="RENDERBUFFER_RED_SIZE",e[e.RENDERBUFFER_GREEN_SIZE=36177]="RENDERBUFFER_GREEN_SIZE",e[e.RENDERBUFFER_BLUE_SIZE=36178]="RENDERBUFFER_BLUE_SIZE",e[e.RENDERBUFFER_ALPHA_SIZE=36179]="RENDERBUFFER_ALPHA_SIZE",e[e.RENDERBUFFER_DEPTH_SIZE=36180]="RENDERBUFFER_DEPTH_SIZE",e[e.RENDERBUFFER_STENCIL_SIZE=36181]="RENDERBUFFER_STENCIL_SIZE",e[e.FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE=36048]="FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE",e[e.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME=36049]="FRAMEBUFFER_ATTACHMENT_OBJECT_NAME",e[e.FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL=36050]="FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL",e[e.FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE=36051]="FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE",e[e.COLOR_ATTACHMENT0=36064]="COLOR_ATTACHMENT0",e[e.DEPTH_ATTACHMENT=36096]="DEPTH_ATTACHMENT",e[e.STENCIL_ATTACHMENT=36128]="STENCIL_ATTACHMENT",e[e.DEPTH_STENCIL_ATTACHMENT=33306]="DEPTH_STENCIL_ATTACHMENT",e[e.NONE=0]="NONE",e[e.FRAMEBUFFER_COMPLETE=36053]="FRAMEBUFFER_COMPLETE",e[e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT=36054]="FRAMEBUFFER_INCOMPLETE_ATTACHMENT",e[e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT=36055]="FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT",e[e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS=36057]="FRAMEBUFFER_INCOMPLETE_DIMENSIONS",e[e.FRAMEBUFFER_UNSUPPORTED=36061]="FRAMEBUFFER_UNSUPPORTED",e[e.FRAMEBUFFER_BINDING=36006]="FRAMEBUFFER_BINDING",e[e.RENDERBUFFER_BINDING=36007]="RENDERBUFFER_BINDING",e[e.READ_FRAMEBUFFER=36008]="READ_FRAMEBUFFER",e[e.DRAW_FRAMEBUFFER=36009]="DRAW_FRAMEBUFFER",e[e.MAX_RENDERBUFFER_SIZE=34024]="MAX_RENDERBUFFER_SIZE",e[e.INVALID_FRAMEBUFFER_OPERATION=1286]="INVALID_FRAMEBUFFER_OPERATION",e[e.UNPACK_FLIP_Y_WEBGL=37440]="UNPACK_FLIP_Y_WEBGL",e[e.UNPACK_PREMULTIPLY_ALPHA_WEBGL=37441]="UNPACK_PREMULTIPLY_ALPHA_WEBGL",e[e.UNPACK_COLORSPACE_CONVERSION_WEBGL=37443]="UNPACK_COLORSPACE_CONVERSION_WEBGL",e[e.READ_BUFFER=3074]="READ_BUFFER",e[e.UNPACK_ROW_LENGTH=3314]="UNPACK_ROW_LENGTH",e[e.UNPACK_SKIP_ROWS=3315]="UNPACK_SKIP_ROWS",e[e.UNPACK_SKIP_PIXELS=3316]="UNPACK_SKIP_PIXELS",e[e.PACK_ROW_LENGTH=3330]="PACK_ROW_LENGTH",e[e.PACK_SKIP_ROWS=3331]="PACK_SKIP_ROWS",e[e.PACK_SKIP_PIXELS=3332]="PACK_SKIP_PIXELS",e[e.TEXTURE_BINDING_3D=32874]="TEXTURE_BINDING_3D",e[e.UNPACK_SKIP_IMAGES=32877]="UNPACK_SKIP_IMAGES",e[e.UNPACK_IMAGE_HEIGHT=32878]="UNPACK_IMAGE_HEIGHT",e[e.MAX_3D_TEXTURE_SIZE=32883]="MAX_3D_TEXTURE_SIZE",e[e.MAX_ELEMENTS_VERTICES=33e3]="MAX_ELEMENTS_VERTICES",e[e.MAX_ELEMENTS_INDICES=33001]="MAX_ELEMENTS_INDICES",e[e.MAX_TEXTURE_LOD_BIAS=34045]="MAX_TEXTURE_LOD_BIAS",e[e.MAX_FRAGMENT_UNIFORM_COMPONENTS=35657]="MAX_FRAGMENT_UNIFORM_COMPONENTS",e[e.MAX_VERTEX_UNIFORM_COMPONENTS=35658]="MAX_VERTEX_UNIFORM_COMPONENTS",e[e.MAX_ARRAY_TEXTURE_LAYERS=35071]="MAX_ARRAY_TEXTURE_LAYERS",e[e.MIN_PROGRAM_TEXEL_OFFSET=35076]="MIN_PROGRAM_TEXEL_OFFSET",e[e.MAX_PROGRAM_TEXEL_OFFSET=35077]="MAX_PROGRAM_TEXEL_OFFSET",e[e.MAX_VARYING_COMPONENTS=35659]="MAX_VARYING_COMPONENTS",e[e.FRAGMENT_SHADER_DERIVATIVE_HINT=35723]="FRAGMENT_SHADER_DERIVATIVE_HINT",e[e.RASTERIZER_DISCARD=35977]="RASTERIZER_DISCARD",e[e.VERTEX_ARRAY_BINDING=34229]="VERTEX_ARRAY_BINDING",e[e.MAX_VERTEX_OUTPUT_COMPONENTS=37154]="MAX_VERTEX_OUTPUT_COMPONENTS",e[e.MAX_FRAGMENT_INPUT_COMPONENTS=37157]="MAX_FRAGMENT_INPUT_COMPONENTS",e[e.MAX_SERVER_WAIT_TIMEOUT=37137]="MAX_SERVER_WAIT_TIMEOUT",e[e.MAX_ELEMENT_INDEX=36203]="MAX_ELEMENT_INDEX",e[e.RED=6403]="RED",e[e.RGB8=32849]="RGB8",e[e.RGBA8=32856]="RGBA8",e[e.RGB10_A2=32857]="RGB10_A2",e[e.TEXTURE_3D=32879]="TEXTURE_3D",e[e.TEXTURE_WRAP_R=32882]="TEXTURE_WRAP_R",e[e.TEXTURE_MIN_LOD=33082]="TEXTURE_MIN_LOD",e[e.TEXTURE_MAX_LOD=33083]="TEXTURE_MAX_LOD",e[e.TEXTURE_BASE_LEVEL=33084]="TEXTURE_BASE_LEVEL",e[e.TEXTURE_MAX_LEVEL=33085]="TEXTURE_MAX_LEVEL",e[e.TEXTURE_COMPARE_MODE=34892]="TEXTURE_COMPARE_MODE",e[e.TEXTURE_COMPARE_FUNC=34893]="TEXTURE_COMPARE_FUNC",e[e.SRGB=35904]="SRGB",e[e.SRGB8=35905]="SRGB8",e[e.SRGB8_ALPHA8=35907]="SRGB8_ALPHA8",e[e.COMPARE_REF_TO_TEXTURE=34894]="COMPARE_REF_TO_TEXTURE",e[e.RGBA32F=34836]="RGBA32F",e[e.RGB32F=34837]="RGB32F",e[e.RGBA16F=34842]="RGBA16F",e[e.RGB16F=34843]="RGB16F",e[e.TEXTURE_2D_ARRAY=35866]="TEXTURE_2D_ARRAY",e[e.TEXTURE_BINDING_2D_ARRAY=35869]="TEXTURE_BINDING_2D_ARRAY",e[e.R11F_G11F_B10F=35898]="R11F_G11F_B10F",e[e.RGB9_E5=35901]="RGB9_E5",e[e.RGBA32UI=36208]="RGBA32UI",e[e.RGB32UI=36209]="RGB32UI",e[e.RGBA16UI=36214]="RGBA16UI",e[e.RGB16UI=36215]="RGB16UI",e[e.RGBA8UI=36220]="RGBA8UI",e[e.RGB8UI=36221]="RGB8UI",e[e.RGBA32I=36226]="RGBA32I",e[e.RGB32I=36227]="RGB32I",e[e.RGBA16I=36232]="RGBA16I",e[e.RGB16I=36233]="RGB16I",e[e.RGBA8I=36238]="RGBA8I",e[e.RGB8I=36239]="RGB8I",e[e.RED_INTEGER=36244]="RED_INTEGER",e[e.RGB_INTEGER=36248]="RGB_INTEGER",e[e.RGBA_INTEGER=36249]="RGBA_INTEGER",e[e.R8=33321]="R8",e[e.RG8=33323]="RG8",e[e.R16F=33325]="R16F",e[e.R32F=33326]="R32F",e[e.RG16F=33327]="RG16F",e[e.RG32F=33328]="RG32F",e[e.R8I=33329]="R8I",e[e.R8UI=33330]="R8UI",e[e.R16I=33331]="R16I",e[e.R16UI=33332]="R16UI",e[e.R32I=33333]="R32I",e[e.R32UI=33334]="R32UI",e[e.RG8I=33335]="RG8I",e[e.RG8UI=33336]="RG8UI",e[e.RG16I=33337]="RG16I",e[e.RG16UI=33338]="RG16UI",e[e.RG32I=33339]="RG32I",e[e.RG32UI=33340]="RG32UI",e[e.R8_SNORM=36756]="R8_SNORM",e[e.RG8_SNORM=36757]="RG8_SNORM",e[e.RGB8_SNORM=36758]="RGB8_SNORM",e[e.RGBA8_SNORM=36759]="RGBA8_SNORM",e[e.RGB10_A2UI=36975]="RGB10_A2UI",e[e.TEXTURE_IMMUTABLE_FORMAT=37167]="TEXTURE_IMMUTABLE_FORMAT",e[e.TEXTURE_IMMUTABLE_LEVELS=33503]="TEXTURE_IMMUTABLE_LEVELS",e[e.UNSIGNED_INT_2_10_10_10_REV=33640]="UNSIGNED_INT_2_10_10_10_REV",e[e.UNSIGNED_INT_10F_11F_11F_REV=35899]="UNSIGNED_INT_10F_11F_11F_REV",e[e.UNSIGNED_INT_5_9_9_9_REV=35902]="UNSIGNED_INT_5_9_9_9_REV",e[e.FLOAT_32_UNSIGNED_INT_24_8_REV=36269]="FLOAT_32_UNSIGNED_INT_24_8_REV",e[e.UNSIGNED_INT_24_8=34042]="UNSIGNED_INT_24_8",e[e.HALF_FLOAT=5131]="HALF_FLOAT",e[e.RG=33319]="RG",e[e.RG_INTEGER=33320]="RG_INTEGER",e[e.INT_2_10_10_10_REV=36255]="INT_2_10_10_10_REV",e[e.CURRENT_QUERY=34917]="CURRENT_QUERY",e[e.QUERY_RESULT=34918]="QUERY_RESULT",e[e.QUERY_RESULT_AVAILABLE=34919]="QUERY_RESULT_AVAILABLE",e[e.ANY_SAMPLES_PASSED=35887]="ANY_SAMPLES_PASSED",e[e.ANY_SAMPLES_PASSED_CONSERVATIVE=36202]="ANY_SAMPLES_PASSED_CONSERVATIVE",e[e.MAX_DRAW_BUFFERS=34852]="MAX_DRAW_BUFFERS",e[e.DRAW_BUFFER0=34853]="DRAW_BUFFER0",e[e.DRAW_BUFFER1=34854]="DRAW_BUFFER1",e[e.DRAW_BUFFER2=34855]="DRAW_BUFFER2",e[e.DRAW_BUFFER3=34856]="DRAW_BUFFER3",e[e.DRAW_BUFFER4=34857]="DRAW_BUFFER4",e[e.DRAW_BUFFER5=34858]="DRAW_BUFFER5",e[e.DRAW_BUFFER6=34859]="DRAW_BUFFER6",e[e.DRAW_BUFFER7=34860]="DRAW_BUFFER7",e[e.DRAW_BUFFER8=34861]="DRAW_BUFFER8",e[e.DRAW_BUFFER9=34862]="DRAW_BUFFER9",e[e.DRAW_BUFFER10=34863]="DRAW_BUFFER10",e[e.DRAW_BUFFER11=34864]="DRAW_BUFFER11",e[e.DRAW_BUFFER12=34865]="DRAW_BUFFER12",e[e.DRAW_BUFFER13=34866]="DRAW_BUFFER13",e[e.DRAW_BUFFER14=34867]="DRAW_BUFFER14",e[e.DRAW_BUFFER15=34868]="DRAW_BUFFER15",e[e.MAX_COLOR_ATTACHMENTS=36063]="MAX_COLOR_ATTACHMENTS",e[e.COLOR_ATTACHMENT1=36065]="COLOR_ATTACHMENT1",e[e.COLOR_ATTACHMENT2=36066]="COLOR_ATTACHMENT2",e[e.COLOR_ATTACHMENT3=36067]="COLOR_ATTACHMENT3",e[e.COLOR_ATTACHMENT4=36068]="COLOR_ATTACHMENT4",e[e.COLOR_ATTACHMENT5=36069]="COLOR_ATTACHMENT5",e[e.COLOR_ATTACHMENT6=36070]="COLOR_ATTACHMENT6",e[e.COLOR_ATTACHMENT7=36071]="COLOR_ATTACHMENT7",e[e.COLOR_ATTACHMENT8=36072]="COLOR_ATTACHMENT8",e[e.COLOR_ATTACHMENT9=36073]="COLOR_ATTACHMENT9",e[e.COLOR_ATTACHMENT10=36074]="COLOR_ATTACHMENT10",e[e.COLOR_ATTACHMENT11=36075]="COLOR_ATTACHMENT11",e[e.COLOR_ATTACHMENT12=36076]="COLOR_ATTACHMENT12",e[e.COLOR_ATTACHMENT13=36077]="COLOR_ATTACHMENT13",e[e.COLOR_ATTACHMENT14=36078]="COLOR_ATTACHMENT14",e[e.COLOR_ATTACHMENT15=36079]="COLOR_ATTACHMENT15",e[e.SAMPLER_3D=35679]="SAMPLER_3D",e[e.SAMPLER_2D_SHADOW=35682]="SAMPLER_2D_SHADOW",e[e.SAMPLER_2D_ARRAY=36289]="SAMPLER_2D_ARRAY",e[e.SAMPLER_2D_ARRAY_SHADOW=36292]="SAMPLER_2D_ARRAY_SHADOW",e[e.SAMPLER_CUBE_SHADOW=36293]="SAMPLER_CUBE_SHADOW",e[e.INT_SAMPLER_2D=36298]="INT_SAMPLER_2D",e[e.INT_SAMPLER_3D=36299]="INT_SAMPLER_3D",e[e.INT_SAMPLER_CUBE=36300]="INT_SAMPLER_CUBE",e[e.INT_SAMPLER_2D_ARRAY=36303]="INT_SAMPLER_2D_ARRAY",e[e.UNSIGNED_INT_SAMPLER_2D=36306]="UNSIGNED_INT_SAMPLER_2D",e[e.UNSIGNED_INT_SAMPLER_3D=36307]="UNSIGNED_INT_SAMPLER_3D",e[e.UNSIGNED_INT_SAMPLER_CUBE=36308]="UNSIGNED_INT_SAMPLER_CUBE",e[e.UNSIGNED_INT_SAMPLER_2D_ARRAY=36311]="UNSIGNED_INT_SAMPLER_2D_ARRAY",e[e.MAX_SAMPLES=36183]="MAX_SAMPLES",e[e.SAMPLER_BINDING=35097]="SAMPLER_BINDING",e[e.PIXEL_PACK_BUFFER=35051]="PIXEL_PACK_BUFFER",e[e.PIXEL_UNPACK_BUFFER=35052]="PIXEL_UNPACK_BUFFER",e[e.PIXEL_PACK_BUFFER_BINDING=35053]="PIXEL_PACK_BUFFER_BINDING",e[e.PIXEL_UNPACK_BUFFER_BINDING=35055]="PIXEL_UNPACK_BUFFER_BINDING",e[e.COPY_READ_BUFFER=36662]="COPY_READ_BUFFER",e[e.COPY_WRITE_BUFFER=36663]="COPY_WRITE_BUFFER",e[e.COPY_READ_BUFFER_BINDING=36662]="COPY_READ_BUFFER_BINDING",e[e.COPY_WRITE_BUFFER_BINDING=36663]="COPY_WRITE_BUFFER_BINDING",e[e.FLOAT_MAT2x3=35685]="FLOAT_MAT2x3",e[e.FLOAT_MAT2x4=35686]="FLOAT_MAT2x4",e[e.FLOAT_MAT3x2=35687]="FLOAT_MAT3x2",e[e.FLOAT_MAT3x4=35688]="FLOAT_MAT3x4",e[e.FLOAT_MAT4x2=35689]="FLOAT_MAT4x2",e[e.FLOAT_MAT4x3=35690]="FLOAT_MAT4x3",e[e.UNSIGNED_INT_VEC2=36294]="UNSIGNED_INT_VEC2",e[e.UNSIGNED_INT_VEC3=36295]="UNSIGNED_INT_VEC3",e[e.UNSIGNED_INT_VEC4=36296]="UNSIGNED_INT_VEC4",e[e.UNSIGNED_NORMALIZED=35863]="UNSIGNED_NORMALIZED",e[e.SIGNED_NORMALIZED=36764]="SIGNED_NORMALIZED",e[e.VERTEX_ATTRIB_ARRAY_INTEGER=35069]="VERTEX_ATTRIB_ARRAY_INTEGER",e[e.VERTEX_ATTRIB_ARRAY_DIVISOR=35070]="VERTEX_ATTRIB_ARRAY_DIVISOR",e[e.TRANSFORM_FEEDBACK_BUFFER_MODE=35967]="TRANSFORM_FEEDBACK_BUFFER_MODE",e[e.MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS=35968]="MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS",e[e.TRANSFORM_FEEDBACK_VARYINGS=35971]="TRANSFORM_FEEDBACK_VARYINGS",e[e.TRANSFORM_FEEDBACK_BUFFER_START=35972]="TRANSFORM_FEEDBACK_BUFFER_START",e[e.TRANSFORM_FEEDBACK_BUFFER_SIZE=35973]="TRANSFORM_FEEDBACK_BUFFER_SIZE",e[e.TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN=35976]="TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN",e[e.MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS=35978]="MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS",e[e.MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS=35979]="MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS",e[e.INTERLEAVED_ATTRIBS=35980]="INTERLEAVED_ATTRIBS",e[e.SEPARATE_ATTRIBS=35981]="SEPARATE_ATTRIBS",e[e.TRANSFORM_FEEDBACK_BUFFER=35982]="TRANSFORM_FEEDBACK_BUFFER",e[e.TRANSFORM_FEEDBACK_BUFFER_BINDING=35983]="TRANSFORM_FEEDBACK_BUFFER_BINDING",e[e.TRANSFORM_FEEDBACK=36386]="TRANSFORM_FEEDBACK",e[e.TRANSFORM_FEEDBACK_PAUSED=36387]="TRANSFORM_FEEDBACK_PAUSED",e[e.TRANSFORM_FEEDBACK_ACTIVE=36388]="TRANSFORM_FEEDBACK_ACTIVE",e[e.TRANSFORM_FEEDBACK_BINDING=36389]="TRANSFORM_FEEDBACK_BINDING",e[e.FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING=33296]="FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING",e[e.FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE=33297]="FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE",e[e.FRAMEBUFFER_ATTACHMENT_RED_SIZE=33298]="FRAMEBUFFER_ATTACHMENT_RED_SIZE",e[e.FRAMEBUFFER_ATTACHMENT_GREEN_SIZE=33299]="FRAMEBUFFER_ATTACHMENT_GREEN_SIZE",e[e.FRAMEBUFFER_ATTACHMENT_BLUE_SIZE=33300]="FRAMEBUFFER_ATTACHMENT_BLUE_SIZE",e[e.FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE=33301]="FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE",e[e.FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE=33302]="FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE",e[e.FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE=33303]="FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE",e[e.FRAMEBUFFER_DEFAULT=33304]="FRAMEBUFFER_DEFAULT",e[e.DEPTH24_STENCIL8=35056]="DEPTH24_STENCIL8",e[e.DRAW_FRAMEBUFFER_BINDING=36006]="DRAW_FRAMEBUFFER_BINDING",e[e.READ_FRAMEBUFFER_BINDING=36010]="READ_FRAMEBUFFER_BINDING",e[e.RENDERBUFFER_SAMPLES=36011]="RENDERBUFFER_SAMPLES",e[e.FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER=36052]="FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER",e[e.FRAMEBUFFER_INCOMPLETE_MULTISAMPLE=36182]="FRAMEBUFFER_INCOMPLETE_MULTISAMPLE",e[e.UNIFORM_BUFFER=35345]="UNIFORM_BUFFER",e[e.UNIFORM_BUFFER_BINDING=35368]="UNIFORM_BUFFER_BINDING",e[e.UNIFORM_BUFFER_START=35369]="UNIFORM_BUFFER_START",e[e.UNIFORM_BUFFER_SIZE=35370]="UNIFORM_BUFFER_SIZE",e[e.MAX_VERTEX_UNIFORM_BLOCKS=35371]="MAX_VERTEX_UNIFORM_BLOCKS",e[e.MAX_FRAGMENT_UNIFORM_BLOCKS=35373]="MAX_FRAGMENT_UNIFORM_BLOCKS",e[e.MAX_COMBINED_UNIFORM_BLOCKS=35374]="MAX_COMBINED_UNIFORM_BLOCKS",e[e.MAX_UNIFORM_BUFFER_BINDINGS=35375]="MAX_UNIFORM_BUFFER_BINDINGS",e[e.MAX_UNIFORM_BLOCK_SIZE=35376]="MAX_UNIFORM_BLOCK_SIZE",e[e.MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS=35377]="MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS",e[e.MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS=35379]="MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS",e[e.UNIFORM_BUFFER_OFFSET_ALIGNMENT=35380]="UNIFORM_BUFFER_OFFSET_ALIGNMENT",e[e.ACTIVE_UNIFORM_BLOCKS=35382]="ACTIVE_UNIFORM_BLOCKS",e[e.UNIFORM_TYPE=35383]="UNIFORM_TYPE",e[e.UNIFORM_SIZE=35384]="UNIFORM_SIZE",e[e.UNIFORM_BLOCK_INDEX=35386]="UNIFORM_BLOCK_INDEX",e[e.UNIFORM_OFFSET=35387]="UNIFORM_OFFSET",e[e.UNIFORM_ARRAY_STRIDE=35388]="UNIFORM_ARRAY_STRIDE",e[e.UNIFORM_MATRIX_STRIDE=35389]="UNIFORM_MATRIX_STRIDE",e[e.UNIFORM_IS_ROW_MAJOR=35390]="UNIFORM_IS_ROW_MAJOR",e[e.UNIFORM_BLOCK_BINDING=35391]="UNIFORM_BLOCK_BINDING",e[e.UNIFORM_BLOCK_DATA_SIZE=35392]="UNIFORM_BLOCK_DATA_SIZE",e[e.UNIFORM_BLOCK_ACTIVE_UNIFORMS=35394]="UNIFORM_BLOCK_ACTIVE_UNIFORMS",e[e.UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES=35395]="UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES",e[e.UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER=35396]="UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER",e[e.UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER=35398]="UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER",e[e.OBJECT_TYPE=37138]="OBJECT_TYPE",e[e.SYNC_CONDITION=37139]="SYNC_CONDITION",e[e.SYNC_STATUS=37140]="SYNC_STATUS",e[e.SYNC_FLAGS=37141]="SYNC_FLAGS",e[e.SYNC_FENCE=37142]="SYNC_FENCE",e[e.SYNC_GPU_COMMANDS_COMPLETE=37143]="SYNC_GPU_COMMANDS_COMPLETE",e[e.UNSIGNALED=37144]="UNSIGNALED",e[e.SIGNALED=37145]="SIGNALED",e[e.ALREADY_SIGNALED=37146]="ALREADY_SIGNALED",e[e.TIMEOUT_EXPIRED=37147]="TIMEOUT_EXPIRED",e[e.CONDITION_SATISFIED=37148]="CONDITION_SATISFIED",e[e.WAIT_FAILED=37149]="WAIT_FAILED",e[e.SYNC_FLUSH_COMMANDS_BIT=1]="SYNC_FLUSH_COMMANDS_BIT",e[e.COLOR=6144]="COLOR",e[e.DEPTH=6145]="DEPTH",e[e.STENCIL=6146]="STENCIL",e[e.MIN=32775]="MIN",e[e.MAX=32776]="MAX",e[e.DEPTH_COMPONENT24=33190]="DEPTH_COMPONENT24",e[e.STREAM_READ=35041]="STREAM_READ",e[e.STREAM_COPY=35042]="STREAM_COPY",e[e.STATIC_READ=35045]="STATIC_READ",e[e.STATIC_COPY=35046]="STATIC_COPY",e[e.DYNAMIC_READ=35049]="DYNAMIC_READ",e[e.DYNAMIC_COPY=35050]="DYNAMIC_COPY",e[e.DEPTH_COMPONENT32F=36012]="DEPTH_COMPONENT32F",e[e.DEPTH32F_STENCIL8=36013]="DEPTH32F_STENCIL8",e[e.INVALID_INDEX=4294967295]="INVALID_INDEX",e[e.TIMEOUT_IGNORED=-1]="TIMEOUT_IGNORED",e[e.MAX_CLIENT_WAIT_TIMEOUT_WEBGL=37447]="MAX_CLIENT_WAIT_TIMEOUT_WEBGL",e[e.UNMASKED_VENDOR_WEBGL=37445]="UNMASKED_VENDOR_WEBGL",e[e.UNMASKED_RENDERER_WEBGL=37446]="UNMASKED_RENDERER_WEBGL",e[e.MAX_TEXTURE_MAX_ANISOTROPY_EXT=34047]="MAX_TEXTURE_MAX_ANISOTROPY_EXT",e[e.TEXTURE_MAX_ANISOTROPY_EXT=34046]="TEXTURE_MAX_ANISOTROPY_EXT",e[e.R16_EXT=33322]="R16_EXT",e[e.RG16_EXT=33324]="RG16_EXT",e[e.RGB16_EXT=32852]="RGB16_EXT",e[e.RGBA16_EXT=32859]="RGBA16_EXT",e[e.R16_SNORM_EXT=36760]="R16_SNORM_EXT",e[e.RG16_SNORM_EXT=36761]="RG16_SNORM_EXT",e[e.RGB16_SNORM_EXT=36762]="RGB16_SNORM_EXT",e[e.RGBA16_SNORM_EXT=36763]="RGBA16_SNORM_EXT",e[e.COMPRESSED_RGB_S3TC_DXT1_EXT=33776]="COMPRESSED_RGB_S3TC_DXT1_EXT",e[e.COMPRESSED_RGBA_S3TC_DXT1_EXT=33777]="COMPRESSED_RGBA_S3TC_DXT1_EXT",e[e.COMPRESSED_RGBA_S3TC_DXT3_EXT=33778]="COMPRESSED_RGBA_S3TC_DXT3_EXT",e[e.COMPRESSED_RGBA_S3TC_DXT5_EXT=33779]="COMPRESSED_RGBA_S3TC_DXT5_EXT",e[e.COMPRESSED_SRGB_S3TC_DXT1_EXT=35916]="COMPRESSED_SRGB_S3TC_DXT1_EXT",e[e.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT=35917]="COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT",e[e.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT=35918]="COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT",e[e.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT=35919]="COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT",e[e.COMPRESSED_RED_RGTC1_EXT=36283]="COMPRESSED_RED_RGTC1_EXT",e[e.COMPRESSED_SIGNED_RED_RGTC1_EXT=36284]="COMPRESSED_SIGNED_RED_RGTC1_EXT",e[e.COMPRESSED_RED_GREEN_RGTC2_EXT=36285]="COMPRESSED_RED_GREEN_RGTC2_EXT",e[e.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT=36286]="COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT",e[e.COMPRESSED_RGBA_BPTC_UNORM_EXT=36492]="COMPRESSED_RGBA_BPTC_UNORM_EXT",e[e.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT=36493]="COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT",e[e.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT=36494]="COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT",e[e.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT=36495]="COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT",e[e.COMPRESSED_R11_EAC=37488]="COMPRESSED_R11_EAC",e[e.COMPRESSED_SIGNED_R11_EAC=37489]="COMPRESSED_SIGNED_R11_EAC",e[e.COMPRESSED_RG11_EAC=37490]="COMPRESSED_RG11_EAC",e[e.COMPRESSED_SIGNED_RG11_EAC=37491]="COMPRESSED_SIGNED_RG11_EAC",e[e.COMPRESSED_RGB8_ETC2=37492]="COMPRESSED_RGB8_ETC2",e[e.COMPRESSED_RGBA8_ETC2_EAC=37493]="COMPRESSED_RGBA8_ETC2_EAC",e[e.COMPRESSED_SRGB8_ETC2=37494]="COMPRESSED_SRGB8_ETC2",e[e.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC=37495]="COMPRESSED_SRGB8_ALPHA8_ETC2_EAC",e[e.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2=37496]="COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2",e[e.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2=37497]="COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2",e[e.COMPRESSED_RGB_PVRTC_4BPPV1_IMG=35840]="COMPRESSED_RGB_PVRTC_4BPPV1_IMG",e[e.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG=35842]="COMPRESSED_RGBA_PVRTC_4BPPV1_IMG",e[e.COMPRESSED_RGB_PVRTC_2BPPV1_IMG=35841]="COMPRESSED_RGB_PVRTC_2BPPV1_IMG",e[e.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG=35843]="COMPRESSED_RGBA_PVRTC_2BPPV1_IMG",e[e.COMPRESSED_RGB_ETC1_WEBGL=36196]="COMPRESSED_RGB_ETC1_WEBGL",e[e.COMPRESSED_RGB_ATC_WEBGL=35986]="COMPRESSED_RGB_ATC_WEBGL",e[e.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL=35986]="COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL",e[e.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL=34798]="COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL",e[e.COMPRESSED_RGBA_ASTC_4x4_KHR=37808]="COMPRESSED_RGBA_ASTC_4x4_KHR",e[e.COMPRESSED_RGBA_ASTC_5x4_KHR=37809]="COMPRESSED_RGBA_ASTC_5x4_KHR",e[e.COMPRESSED_RGBA_ASTC_5x5_KHR=37810]="COMPRESSED_RGBA_ASTC_5x5_KHR",e[e.COMPRESSED_RGBA_ASTC_6x5_KHR=37811]="COMPRESSED_RGBA_ASTC_6x5_KHR",e[e.COMPRESSED_RGBA_ASTC_6x6_KHR=37812]="COMPRESSED_RGBA_ASTC_6x6_KHR",e[e.COMPRESSED_RGBA_ASTC_8x5_KHR=37813]="COMPRESSED_RGBA_ASTC_8x5_KHR",e[e.COMPRESSED_RGBA_ASTC_8x6_KHR=37814]="COMPRESSED_RGBA_ASTC_8x6_KHR",e[e.COMPRESSED_RGBA_ASTC_8x8_KHR=37815]="COMPRESSED_RGBA_ASTC_8x8_KHR",e[e.COMPRESSED_RGBA_ASTC_10x5_KHR=37816]="COMPRESSED_RGBA_ASTC_10x5_KHR",e[e.COMPRESSED_RGBA_ASTC_10x6_KHR=37817]="COMPRESSED_RGBA_ASTC_10x6_KHR",e[e.COMPRESSED_RGBA_ASTC_10x8_KHR=37818]="COMPRESSED_RGBA_ASTC_10x8_KHR",e[e.COMPRESSED_RGBA_ASTC_10x10_KHR=37819]="COMPRESSED_RGBA_ASTC_10x10_KHR",e[e.COMPRESSED_RGBA_ASTC_12x10_KHR=37820]="COMPRESSED_RGBA_ASTC_12x10_KHR",e[e.COMPRESSED_RGBA_ASTC_12x12_KHR=37821]="COMPRESSED_RGBA_ASTC_12x12_KHR",e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR=37840]="COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR",e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR=37841]="COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR",e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR=37842]="COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR",e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR=37843]="COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR",e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR=37844]="COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR",e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR=37845]="COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR",e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR=37846]="COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR",e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR=37847]="COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR",e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR=37848]="COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR",e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR=37849]="COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR",e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR=37850]="COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR",e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR=37851]="COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR",e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR=37852]="COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR",e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR=37853]="COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR",e[e.QUERY_COUNTER_BITS_EXT=34916]="QUERY_COUNTER_BITS_EXT",e[e.CURRENT_QUERY_EXT=34917]="CURRENT_QUERY_EXT",e[e.QUERY_RESULT_EXT=34918]="QUERY_RESULT_EXT",e[e.QUERY_RESULT_AVAILABLE_EXT=34919]="QUERY_RESULT_AVAILABLE_EXT",e[e.TIME_ELAPSED_EXT=35007]="TIME_ELAPSED_EXT",e[e.TIMESTAMP_EXT=36392]="TIMESTAMP_EXT",e[e.GPU_DISJOINT_EXT=36795]="GPU_DISJOINT_EXT",e[e.COMPLETION_STATUS_KHR=37297]="COMPLETION_STATUS_KHR",e[e.DEPTH_CLAMP_EXT=34383]="DEPTH_CLAMP_EXT",e[e.FIRST_VERTEX_CONVENTION_WEBGL=36429]="FIRST_VERTEX_CONVENTION_WEBGL",e[e.LAST_VERTEX_CONVENTION_WEBGL=36430]="LAST_VERTEX_CONVENTION_WEBGL",e[e.PROVOKING_VERTEX_WEBL=36431]="PROVOKING_VERTEX_WEBL",e[e.POLYGON_MODE_WEBGL=2880]="POLYGON_MODE_WEBGL",e[e.POLYGON_OFFSET_LINE_WEBGL=10754]="POLYGON_OFFSET_LINE_WEBGL",e[e.LINE_WEBGL=6913]="LINE_WEBGL",e[e.FILL_WEBGL=6914]="FILL_WEBGL",e[e.MAX_CLIP_DISTANCES_WEBGL=3378]="MAX_CLIP_DISTANCES_WEBGL",e[e.MAX_CULL_DISTANCES_WEBGL=33529]="MAX_CULL_DISTANCES_WEBGL",e[e.MAX_COMBINED_CLIP_AND_CULL_DISTANCES_WEBGL=33530]="MAX_COMBINED_CLIP_AND_CULL_DISTANCES_WEBGL",e[e.CLIP_DISTANCE0_WEBGL=12288]="CLIP_DISTANCE0_WEBGL",e[e.CLIP_DISTANCE1_WEBGL=12289]="CLIP_DISTANCE1_WEBGL",e[e.CLIP_DISTANCE2_WEBGL=12290]="CLIP_DISTANCE2_WEBGL",e[e.CLIP_DISTANCE3_WEBGL=12291]="CLIP_DISTANCE3_WEBGL",e[e.CLIP_DISTANCE4_WEBGL=12292]="CLIP_DISTANCE4_WEBGL",e[e.CLIP_DISTANCE5_WEBGL=12293]="CLIP_DISTANCE5_WEBGL",e[e.CLIP_DISTANCE6_WEBGL=12294]="CLIP_DISTANCE6_WEBGL",e[e.CLIP_DISTANCE7_WEBGL=12295]="CLIP_DISTANCE7_WEBGL",e[e.POLYGON_OFFSET_CLAMP_EXT=36379]="POLYGON_OFFSET_CLAMP_EXT",e[e.LOWER_LEFT_EXT=36001]="LOWER_LEFT_EXT",e[e.UPPER_LEFT_EXT=36002]="UPPER_LEFT_EXT",e[e.NEGATIVE_ONE_TO_ONE_EXT=37726]="NEGATIVE_ONE_TO_ONE_EXT",e[e.ZERO_TO_ONE_EXT=37727]="ZERO_TO_ONE_EXT",e[e.CLIP_ORIGIN_EXT=37724]="CLIP_ORIGIN_EXT",e[e.CLIP_DEPTH_MODE_EXT=37725]="CLIP_DEPTH_MODE_EXT",e[e.SRC1_COLOR_WEBGL=35065]="SRC1_COLOR_WEBGL",e[e.SRC1_ALPHA_WEBGL=34185]="SRC1_ALPHA_WEBGL",e[e.ONE_MINUS_SRC1_COLOR_WEBGL=35066]="ONE_MINUS_SRC1_COLOR_WEBGL",e[e.ONE_MINUS_SRC1_ALPHA_WEBGL=35067]="ONE_MINUS_SRC1_ALPHA_WEBGL",e[e.MAX_DUAL_SOURCE_DRAW_BUFFERS_WEBGL=35068]="MAX_DUAL_SOURCE_DRAW_BUFFERS_WEBGL",e[e.MIRROR_CLAMP_TO_EDGE_EXT=34627]="MIRROR_CLAMP_TO_EDGE_EXT",e}(L||{});const F={[L.BLEND]:!1,[L.BLEND_COLOR]:new Float32Array([0,0,0,0]),[L.BLEND_EQUATION_RGB]:L.FUNC_ADD,[L.BLEND_EQUATION_ALPHA]:L.FUNC_ADD,[L.BLEND_SRC_RGB]:L.ONE,[L.BLEND_DST_RGB]:L.ZERO,[L.BLEND_SRC_ALPHA]:L.ONE,[L.BLEND_DST_ALPHA]:L.ZERO,[L.COLOR_CLEAR_VALUE]:new Float32Array([0,0,0,0]),[L.COLOR_WRITEMASK]:[!0,!0,!0,!0],[L.CULL_FACE]:!1,[L.CULL_FACE_MODE]:L.BACK,[L.DEPTH_TEST]:!1,[L.DEPTH_CLEAR_VALUE]:1,[L.DEPTH_FUNC]:L.LESS,[L.DEPTH_RANGE]:new Float32Array([0,1]),[L.DEPTH_WRITEMASK]:!0,[L.DITHER]:!0,[L.CURRENT_PROGRAM]:null,[L.FRAMEBUFFER_BINDING]:null,[L.RENDERBUFFER_BINDING]:null,[L.VERTEX_ARRAY_BINDING]:null,[L.ARRAY_BUFFER_BINDING]:null,[L.FRONT_FACE]:L.CCW,[L.GENERATE_MIPMAP_HINT]:L.DONT_CARE,[L.LINE_WIDTH]:1,[L.POLYGON_OFFSET_FILL]:!1,[L.POLYGON_OFFSET_FACTOR]:0,[L.POLYGON_OFFSET_UNITS]:0,[L.SAMPLE_ALPHA_TO_COVERAGE]:!1,[L.SAMPLE_COVERAGE]:!1,[L.SAMPLE_COVERAGE_VALUE]:1,[L.SAMPLE_COVERAGE_INVERT]:!1,[L.SCISSOR_TEST]:!1,[L.SCISSOR_BOX]:new Int32Array([0,0,1024,1024]),[L.STENCIL_TEST]:!1,[L.STENCIL_CLEAR_VALUE]:0,[L.STENCIL_WRITEMASK]:4294967295,[L.STENCIL_BACK_WRITEMASK]:4294967295,[L.STENCIL_FUNC]:L.ALWAYS,[L.STENCIL_REF]:0,[L.STENCIL_VALUE_MASK]:4294967295,[L.STENCIL_BACK_FUNC]:L.ALWAYS,[L.STENCIL_BACK_REF]:0,[L.STENCIL_BACK_VALUE_MASK]:4294967295,[L.STENCIL_FAIL]:L.KEEP,[L.STENCIL_PASS_DEPTH_FAIL]:L.KEEP,[L.STENCIL_PASS_DEPTH_PASS]:L.KEEP,[L.STENCIL_BACK_FAIL]:L.KEEP,[L.STENCIL_BACK_PASS_DEPTH_FAIL]:L.KEEP,[L.STENCIL_BACK_PASS_DEPTH_PASS]:L.KEEP,[L.VIEWPORT]:[0,0,1024,1024],[L.TRANSFORM_FEEDBACK_BINDING]:null,[L.COPY_READ_BUFFER_BINDING]:null,[L.COPY_WRITE_BUFFER_BINDING]:null,[L.PIXEL_PACK_BUFFER_BINDING]:null,[L.PIXEL_UNPACK_BUFFER_BINDING]:null,[L.FRAGMENT_SHADER_DERIVATIVE_HINT]:L.DONT_CARE,[L.READ_FRAMEBUFFER_BINDING]:null,[L.RASTERIZER_DISCARD]:!1,[L.PACK_ALIGNMENT]:4,[L.UNPACK_ALIGNMENT]:4,[L.UNPACK_FLIP_Y_WEBGL]:!1,[L.UNPACK_PREMULTIPLY_ALPHA_WEBGL]:!1,[L.UNPACK_COLORSPACE_CONVERSION_WEBGL]:L.BROWSER_DEFAULT_WEBGL,[L.PACK_ROW_LENGTH]:0,[L.PACK_SKIP_PIXELS]:0,[L.PACK_SKIP_ROWS]:0,[L.UNPACK_ROW_LENGTH]:0,[L.UNPACK_IMAGE_HEIGHT]:0,[L.UNPACK_SKIP_PIXELS]:0,[L.UNPACK_SKIP_ROWS]:0,[L.UNPACK_SKIP_IMAGES]:0},y=(e,t,n)=>t?e.enable(n):e.disable(n),M=(e,t,n)=>e.hint(n,t),O=(e,t,n)=>e.pixelStorei(n,t),B=(e,t,n)=>{const i=n===L.FRAMEBUFFER_BINDING?L.DRAW_FRAMEBUFFER:L.READ_FRAMEBUFFER;return e.bindFramebuffer(i,t)},D=(e,t,n)=>{const i={[L.ARRAY_BUFFER_BINDING]:L.ARRAY_BUFFER,[L.COPY_READ_BUFFER_BINDING]:L.COPY_READ_BUFFER,[L.COPY_WRITE_BUFFER_BINDING]:L.COPY_WRITE_BUFFER,[L.PIXEL_PACK_BUFFER_BINDING]:L.PIXEL_PACK_BUFFER,[L.PIXEL_UNPACK_BUFFER_BINDING]:L.PIXEL_UNPACK_BUFFER}[n];e.bindBuffer(i,t)};function w(e){return Array.isArray(e)||ArrayBuffer.isView(e)&&!(e instanceof DataView)}const U={[L.BLEND]:y,[L.BLEND_COLOR]:(e,t)=>e.blendColor(...t),[L.BLEND_EQUATION_RGB]:"blendEquation",[L.BLEND_EQUATION_ALPHA]:"blendEquation",[L.BLEND_SRC_RGB]:"blendFunc",[L.BLEND_DST_RGB]:"blendFunc",[L.BLEND_SRC_ALPHA]:"blendFunc",[L.BLEND_DST_ALPHA]:"blendFunc",[L.COLOR_CLEAR_VALUE]:(e,t)=>e.clearColor(...t),[L.COLOR_WRITEMASK]:(e,t)=>e.colorMask(...t),[L.CULL_FACE]:y,[L.CULL_FACE_MODE]:(e,t)=>e.cullFace(t),[L.DEPTH_TEST]:y,[L.DEPTH_CLEAR_VALUE]:(e,t)=>e.clearDepth(t),[L.DEPTH_FUNC]:(e,t)=>e.depthFunc(t),[L.DEPTH_RANGE]:(e,t)=>e.depthRange(...t),[L.DEPTH_WRITEMASK]:(e,t)=>e.depthMask(t),[L.DITHER]:y,[L.FRAGMENT_SHADER_DERIVATIVE_HINT]:M,[L.CURRENT_PROGRAM]:(e,t)=>e.useProgram(t),[L.RENDERBUFFER_BINDING]:(e,t)=>e.bindRenderbuffer(L.RENDERBUFFER,t),[L.TRANSFORM_FEEDBACK_BINDING]:(e,t)=>e.bindTransformFeedback?.(L.TRANSFORM_FEEDBACK,t),[L.VERTEX_ARRAY_BINDING]:(e,t)=>e.bindVertexArray(t),[L.FRAMEBUFFER_BINDING]:B,[L.READ_FRAMEBUFFER_BINDING]:B,[L.ARRAY_BUFFER_BINDING]:D,[L.COPY_READ_BUFFER_BINDING]:D,[L.COPY_WRITE_BUFFER_BINDING]:D,[L.PIXEL_PACK_BUFFER_BINDING]:D,[L.PIXEL_UNPACK_BUFFER_BINDING]:D,[L.FRONT_FACE]:(e,t)=>e.frontFace(t),[L.GENERATE_MIPMAP_HINT]:M,[L.LINE_WIDTH]:(e,t)=>e.lineWidth(t),[L.POLYGON_OFFSET_FILL]:y,[L.POLYGON_OFFSET_FACTOR]:"polygonOffset",[L.POLYGON_OFFSET_UNITS]:"polygonOffset",[L.RASTERIZER_DISCARD]:y,[L.SAMPLE_ALPHA_TO_COVERAGE]:y,[L.SAMPLE_COVERAGE]:y,[L.SAMPLE_COVERAGE_VALUE]:"sampleCoverage",[L.SAMPLE_COVERAGE_INVERT]:"sampleCoverage",[L.SCISSOR_TEST]:y,[L.SCISSOR_BOX]:(e,t)=>e.scissor(...t),[L.STENCIL_TEST]:y,[L.STENCIL_CLEAR_VALUE]:(e,t)=>e.clearStencil(t),[L.STENCIL_WRITEMASK]:(e,t)=>e.stencilMaskSeparate(L.FRONT,t),[L.STENCIL_BACK_WRITEMASK]:(e,t)=>e.stencilMaskSeparate(L.BACK,t),[L.STENCIL_FUNC]:"stencilFuncFront",[L.STENCIL_REF]:"stencilFuncFront",[L.STENCIL_VALUE_MASK]:"stencilFuncFront",[L.STENCIL_BACK_FUNC]:"stencilFuncBack",[L.STENCIL_BACK_REF]:"stencilFuncBack",[L.STENCIL_BACK_VALUE_MASK]:"stencilFuncBack",[L.STENCIL_FAIL]:"stencilOpFront",[L.STENCIL_PASS_DEPTH_FAIL]:"stencilOpFront",[L.STENCIL_PASS_DEPTH_PASS]:"stencilOpFront",[L.STENCIL_BACK_FAIL]:"stencilOpBack",[L.STENCIL_BACK_PASS_DEPTH_FAIL]:"stencilOpBack",[L.STENCIL_BACK_PASS_DEPTH_PASS]:"stencilOpBack",[L.VIEWPORT]:(e,t)=>e.viewport(...t),[L.DEPTH_CLAMP_EXT]:y,[L.POLYGON_OFFSET_LINE_WEBGL]:y,[L.CLIP_DISTANCE0_WEBGL]:y,[L.CLIP_DISTANCE1_WEBGL]:y,[L.CLIP_DISTANCE2_WEBGL]:y,[L.CLIP_DISTANCE3_WEBGL]:y,[L.CLIP_DISTANCE4_WEBGL]:y,[L.CLIP_DISTANCE5_WEBGL]:y,[L.CLIP_DISTANCE6_WEBGL]:y,[L.CLIP_DISTANCE7_WEBGL]:y,[L.PACK_ALIGNMENT]:O,[L.UNPACK_ALIGNMENT]:O,[L.UNPACK_FLIP_Y_WEBGL]:O,[L.UNPACK_PREMULTIPLY_ALPHA_WEBGL]:O,[L.UNPACK_COLORSPACE_CONVERSION_WEBGL]:O,[L.PACK_ROW_LENGTH]:O,[L.PACK_SKIP_PIXELS]:O,[L.PACK_SKIP_ROWS]:O,[L.UNPACK_ROW_LENGTH]:O,[L.UNPACK_IMAGE_HEIGHT]:O,[L.UNPACK_SKIP_PIXELS]:O,[L.UNPACK_SKIP_ROWS]:O,[L.UNPACK_SKIP_IMAGES]:O,framebuffer:(e,t)=>{const n=t&&"handle"in t?t.handle:t;return e.bindFramebuffer(L.FRAMEBUFFER,n)},blend:(e,t)=>t?e.enable(L.BLEND):e.disable(L.BLEND),blendColor:(e,t)=>e.blendColor(...t),blendEquation:(e,t)=>{const n="number"==typeof t?[t,t]:t;e.blendEquationSeparate(...n)},blendFunc:(e,t)=>{const n=2===t?.length?[...t,...t]:t;e.blendFuncSeparate(...n)},clearColor:(e,t)=>e.clearColor(...t),clearDepth:(e,t)=>e.clearDepth(t),clearStencil:(e,t)=>e.clearStencil(t),colorMask:(e,t)=>e.colorMask(...t),cull:(e,t)=>t?e.enable(L.CULL_FACE):e.disable(L.CULL_FACE),cullFace:(e,t)=>e.cullFace(t),depthTest:(e,t)=>t?e.enable(L.DEPTH_TEST):e.disable(L.DEPTH_TEST),depthFunc:(e,t)=>e.depthFunc(t),depthMask:(e,t)=>e.depthMask(t),depthRange:(e,t)=>e.depthRange(...t),dither:(e,t)=>t?e.enable(L.DITHER):e.disable(L.DITHER),derivativeHint:(e,t)=>{e.hint(L.FRAGMENT_SHADER_DERIVATIVE_HINT,t)},frontFace:(e,t)=>e.frontFace(t),mipmapHint:(e,t)=>e.hint(L.GENERATE_MIPMAP_HINT,t),lineWidth:(e,t)=>e.lineWidth(t),polygonOffsetFill:(e,t)=>t?e.enable(L.POLYGON_OFFSET_FILL):e.disable(L.POLYGON_OFFSET_FILL),polygonOffset:(e,t)=>e.polygonOffset(...t),sampleCoverage:(e,t)=>e.sampleCoverage(t[0],t[1]||!1),scissorTest:(e,t)=>t?e.enable(L.SCISSOR_TEST):e.disable(L.SCISSOR_TEST),scissor:(e,t)=>e.scissor(...t),stencilTest:(e,t)=>t?e.enable(L.STENCIL_TEST):e.disable(L.STENCIL_TEST),stencilMask:(e,t)=>{t=w(t)?t:[t,t];const[n,i]=t;e.stencilMaskSeparate(L.FRONT,n),e.stencilMaskSeparate(L.BACK,i)},stencilFunc:(e,t)=>{t=w(t)&&3===t.length?[...t,...t]:t;const[n,i,r,o,s,a]=t;e.stencilFuncSeparate(L.FRONT,n,i,r),e.stencilFuncSeparate(L.BACK,o,s,a)},stencilOp:(e,t)=>{t=w(t)&&3===t.length?[...t,...t]:t;const[n,i,r,o,s,a]=t;e.stencilOpSeparate(L.FRONT,n,i,r),e.stencilOpSeparate(L.BACK,o,s,a)},viewport:(e,t)=>e.viewport(...t)};function G(e,t,n){return void 0!==t[e]?t[e]:n[e]}const H={blendEquation:(e,t,n)=>e.blendEquationSeparate(G(L.BLEND_EQUATION_RGB,t,n),G(L.BLEND_EQUATION_ALPHA,t,n)),blendFunc:(e,t,n)=>e.blendFuncSeparate(G(L.BLEND_SRC_RGB,t,n),G(L.BLEND_DST_RGB,t,n),G(L.BLEND_SRC_ALPHA,t,n),G(L.BLEND_DST_ALPHA,t,n)),polygonOffset:(e,t,n)=>e.polygonOffset(G(L.POLYGON_OFFSET_FACTOR,t,n),G(L.POLYGON_OFFSET_UNITS,t,n)),sampleCoverage:(e,t,n)=>e.sampleCoverage(G(L.SAMPLE_COVERAGE_VALUE,t,n),G(L.SAMPLE_COVERAGE_INVERT,t,n)),stencilFuncFront:(e,t,n)=>e.stencilFuncSeparate(L.FRONT,G(L.STENCIL_FUNC,t,n),G(L.STENCIL_REF,t,n),G(L.STENCIL_VALUE_MASK,t,n)),stencilFuncBack:(e,t,n)=>e.stencilFuncSeparate(L.BACK,G(L.STENCIL_BACK_FUNC,t,n),G(L.STENCIL_BACK_REF,t,n),G(L.STENCIL_BACK_VALUE_MASK,t,n)),stencilOpFront:(e,t,n)=>e.stencilOpSeparate(L.FRONT,G(L.STENCIL_FAIL,t,n),G(L.STENCIL_PASS_DEPTH_FAIL,t,n),G(L.STENCIL_PASS_DEPTH_PASS,t,n)),stencilOpBack:(e,t,n)=>e.stencilOpSeparate(L.BACK,G(L.STENCIL_BACK_FAIL,t,n),G(L.STENCIL_BACK_PASS_DEPTH_FAIL,t,n),G(L.STENCIL_BACK_PASS_DEPTH_PASS,t,n))},X={enable:(e,t)=>e({[t]:!0}),disable:(e,t)=>e({[t]:!1}),pixelStorei:(e,t,n)=>e({[t]:n}),hint:(e,t,n)=>e({[t]:n}),useProgram:(e,t)=>e({[L.CURRENT_PROGRAM]:t}),bindRenderbuffer:(e,t,n)=>e({[L.RENDERBUFFER_BINDING]:n}),bindTransformFeedback:(e,t,n)=>e({[L.TRANSFORM_FEEDBACK_BINDING]:n}),bindVertexArray:(e,t)=>e({[L.VERTEX_ARRAY_BINDING]:t}),bindFramebuffer:(e,t,n)=>{switch(t){case L.FRAMEBUFFER:return e({[L.DRAW_FRAMEBUFFER_BINDING]:n,[L.READ_FRAMEBUFFER_BINDING]:n});case L.DRAW_FRAMEBUFFER:return e({[L.DRAW_FRAMEBUFFER_BINDING]:n});case L.READ_FRAMEBUFFER:return e({[L.READ_FRAMEBUFFER_BINDING]:n});default:return null}},bindBuffer:(e,t,n)=>{const i={[L.ARRAY_BUFFER]:[L.ARRAY_BUFFER_BINDING],[L.COPY_READ_BUFFER]:[L.COPY_READ_BUFFER_BINDING],[L.COPY_WRITE_BUFFER]:[L.COPY_WRITE_BUFFER_BINDING],[L.PIXEL_PACK_BUFFER]:[L.PIXEL_PACK_BUFFER_BINDING],[L.PIXEL_UNPACK_BUFFER]:[L.PIXEL_UNPACK_BUFFER_BINDING]}[t];return i?e({[i]:n}):{valueChanged:!0}},blendColor:(e,t,n,i,r)=>e({[L.BLEND_COLOR]:new Float32Array([t,n,i,r])}),blendEquation:(e,t)=>e({[L.BLEND_EQUATION_RGB]:t,[L.BLEND_EQUATION_ALPHA]:t}),blendEquationSeparate:(e,t,n)=>e({[L.BLEND_EQUATION_RGB]:t,[L.BLEND_EQUATION_ALPHA]:n}),blendFunc:(e,t,n)=>e({[L.BLEND_SRC_RGB]:t,[L.BLEND_DST_RGB]:n,[L.BLEND_SRC_ALPHA]:t,[L.BLEND_DST_ALPHA]:n}),blendFuncSeparate:(e,t,n,i,r)=>e({[L.BLEND_SRC_RGB]:t,[L.BLEND_DST_RGB]:n,[L.BLEND_SRC_ALPHA]:i,[L.BLEND_DST_ALPHA]:r}),clearColor:(e,t,n,i,r)=>e({[L.COLOR_CLEAR_VALUE]:new Float32Array([t,n,i,r])}),clearDepth:(e,t)=>e({[L.DEPTH_CLEAR_VALUE]:t}),clearStencil:(e,t)=>e({[L.STENCIL_CLEAR_VALUE]:t}),colorMask:(e,t,n,i,r)=>e({[L.COLOR_WRITEMASK]:[t,n,i,r]}),cullFace:(e,t)=>e({[L.CULL_FACE_MODE]:t}),depthFunc:(e,t)=>e({[L.DEPTH_FUNC]:t}),depthRange:(e,t,n)=>e({[L.DEPTH_RANGE]:new Float32Array([t,n])}),depthMask:(e,t)=>e({[L.DEPTH_WRITEMASK]:t}),frontFace:(e,t)=>e({[L.FRONT_FACE]:t}),lineWidth:(e,t)=>e({[L.LINE_WIDTH]:t}),polygonOffset:(e,t,n)=>e({[L.POLYGON_OFFSET_FACTOR]:t,[L.POLYGON_OFFSET_UNITS]:n}),sampleCoverage:(e,t,n)=>e({[L.SAMPLE_COVERAGE_VALUE]:t,[L.SAMPLE_COVERAGE_INVERT]:n}),scissor:(e,t,n,i,r)=>e({[L.SCISSOR_BOX]:new Int32Array([t,n,i,r])}),stencilMask:(e,t)=>e({[L.STENCIL_WRITEMASK]:t,[L.STENCIL_BACK_WRITEMASK]:t}),stencilMaskSeparate:(e,t,n)=>e({[t===L.FRONT?L.STENCIL_WRITEMASK:L.STENCIL_BACK_WRITEMASK]:n}),stencilFunc:(e,t,n,i)=>e({[L.STENCIL_FUNC]:t,[L.STENCIL_REF]:n,[L.STENCIL_VALUE_MASK]:i,[L.STENCIL_BACK_FUNC]:t,[L.STENCIL_BACK_REF]:n,[L.STENCIL_BACK_VALUE_MASK]:i}),stencilFuncSeparate:(e,t,n,i,r)=>e({[t===L.FRONT?L.STENCIL_FUNC:L.STENCIL_BACK_FUNC]:n,[t===L.FRONT?L.STENCIL_REF:L.STENCIL_BACK_REF]:i,[t===L.FRONT?L.STENCIL_VALUE_MASK:L.STENCIL_BACK_VALUE_MASK]:r}),stencilOp:(e,t,n,i)=>e({[L.STENCIL_FAIL]:t,[L.STENCIL_PASS_DEPTH_FAIL]:n,[L.STENCIL_PASS_DEPTH_PASS]:i,[L.STENCIL_BACK_FAIL]:t,[L.STENCIL_BACK_PASS_DEPTH_FAIL]:n,[L.STENCIL_BACK_PASS_DEPTH_PASS]:i}),stencilOpSeparate:(e,t,n,i,r)=>e({[t===L.FRONT?L.STENCIL_FAIL:L.STENCIL_BACK_FAIL]:n,[t===L.FRONT?L.STENCIL_PASS_DEPTH_FAIL:L.STENCIL_BACK_PASS_DEPTH_FAIL]:i,[t===L.FRONT?L.STENCIL_PASS_DEPTH_PASS:L.STENCIL_BACK_PASS_DEPTH_PASS]:r}),viewport:(e,t,n,i,r)=>e({[L.VIEWPORT]:[t,n,i,r]})},V=(e,t)=>e.isEnabled(t),k={[L.BLEND]:V,[L.CULL_FACE]:V,[L.DEPTH_TEST]:V,[L.DITHER]:V,[L.POLYGON_OFFSET_FILL]:V,[L.SAMPLE_ALPHA_TO_COVERAGE]:V,[L.SAMPLE_COVERAGE]:V,[L.SCISSOR_TEST]:V,[L.STENCIL_TEST]:V,[L.RASTERIZER_DISCARD]:V},W=new Set([L.ACTIVE_TEXTURE,L.TRANSFORM_FEEDBACK_ACTIVE,L.TRANSFORM_FEEDBACK_PAUSED,L.TRANSFORM_FEEDBACK_BUFFER_BINDING,L.UNIFORM_BUFFER_BINDING,L.ELEMENT_ARRAY_BUFFER_BINDING,L.IMPLEMENTATION_COLOR_READ_FORMAT,L.IMPLEMENTATION_COLOR_READ_TYPE,L.READ_BUFFER,L.DRAW_BUFFER0,L.DRAW_BUFFER1,L.DRAW_BUFFER2,L.DRAW_BUFFER3,L.DRAW_BUFFER4,L.DRAW_BUFFER5,L.DRAW_BUFFER6,L.DRAW_BUFFER7,L.DRAW_BUFFER8,L.DRAW_BUFFER9,L.DRAW_BUFFER10,L.DRAW_BUFFER11,L.DRAW_BUFFER12,L.DRAW_BUFFER13,L.DRAW_BUFFER14,L.DRAW_BUFFER15,L.SAMPLER_BINDING,L.TEXTURE_BINDING_2D,L.TEXTURE_BINDING_2D_ARRAY,L.TEXTURE_BINDING_3D,L.TEXTURE_BINDING_CUBE_MAP]);function Y(e,t){if(function(e){for(const t in e)return!1;return!0}(t))return;const n={};for(const r in t){const i=Number(r),o=U[r];o&&("string"==typeof o?n[o]=!0:o(e,t[r],i))}const i=e.state&&e.state.cache;if(i)for(const r in n){(0,H[r])(e,t,i)}}function z(e,t){if(void 0===t&&(t=F),"number"==typeof t){const n=t,i=k[n];return i?i(e,n):e.getParameter(n)}const n=Array.isArray(t)?t:Object.keys(t),i={};for(const r of n){const t=k[r];i[r]=t?t(e,Number(r)):e.getParameter(Number(r))}return i}function K(e,t){if(e===t)return!0;const n=Array.isArray(e)||ArrayBuffer.isView(e),i=Array.isArray(t)||ArrayBuffer.isView(t);if(n&&i&&e.length===t.length){for(let n=0;n<e.length;++n)if(e[n]!==t[n])return!1;return!0}return!1}class j{static get(e){return e.state}program=null;stateStack=[];enable=!0;cache=null;initialized=!1;constructor(e,t){this.gl=e,this.log=t?.log||(()=>{}),this._updateCache=this._updateCache.bind(this),Object.seal(this)}push(e){void 0===e&&(e={}),this.stateStack.push({})}pop(){const e=this.stateStack[this.stateStack.length-1];Y(this.gl,e),this.stateStack.pop()}trackState(e,t){if(this.cache=t.copyState?z(e):Object.assign({},F),this.initialized)throw new Error("WebGLStateTracker");this.initialized=!0,this.gl.state=this,function(e){const t=e.useProgram.bind(e);e.useProgram=function(n){const i=j.get(e);i.program!==n&&(t(n),i.program=n)}}(e);for(const n in X){$(e,n,X[n])}Q(e,"getParameter"),Q(e,"isEnabled")}_updateCache(e){let t,n=!1;const i=this.stateStack.length>0?this.stateStack[this.stateStack.length-1]:null;for(const r in e){const o=e[r],s=this.cache[r];K(o,s)||(n=!0,t=s,i&&!(r in i)&&(i[r]=s),this.cache[r]=o)}return{valueChanged:n,oldValue:t}}}function Q(e,t){const n=e[t].bind(e);e[t]=function(t){if(void 0===t||W.has(t))return n(t);const i=j.get(e);return t in i.cache||(i.cache[t]=n(t)),i.enable?i.cache[t]:n(t)},Object.defineProperty(e[t],"name",{value:`${t}-from-cache`,configurable:!1})}function $(e,t,n){if(!e[t])return;const i=e[t].bind(e);e[t]=function(){const t=j.get(e);for(var r=arguments.length,o=new Array(r),s=0;s<r;s++)o[s]=arguments[s];const{valueChanged:a,oldValue:l}=n(t._updateCache,...o);return a&&i(...o),l},Object.defineProperty(e[t],"name",{value:`${t}-to-cache`,configurable:!1})}function q(e,t,n){return void 0===n[t]&&(n[t]=e.getExtension(t)||null),n[t]}function Z(e,t){const n=e.getParameter(L.VENDOR),i=e.getParameter(L.RENDERER);q(e,"WEBGL_debug_renderer_info",t);const r=t.WEBGL_debug_renderer_info,o=e.getParameter(r?r.UNMASKED_VENDOR_WEBGL:L.VENDOR)||n,s=e.getParameter(r?r.UNMASKED_RENDERER_WEBGL:L.RENDERER)||i,a=e.getParameter(L.VERSION),l=J(o,s),c=function(e,t){if(/Metal/i.exec(e)||/Metal/i.exec(t))return"metal";if(/ANGLE/i.exec(e)||/ANGLE/i.exec(t))return"opengl";return"unknown"}(o,s),u=function(e,t){if(/SwiftShader/i.exec(e)||/SwiftShader/i.exec(t))return"cpu";switch(J(e,t)){case"intel":return"integrated";case"software":return"cpu";case"unknown":return"unknown";default:return"discrete"}}(o,s);return{type:"webgl",gpu:l,gpuType:u,gpuBackend:c,vendor:o,renderer:s,version:a,shadingLanguage:"glsl",shadingLanguageVersion:300}}function J(e,t){return/NVIDIA/i.exec(e)||/NVIDIA/i.exec(t)?"nvidia":/INTEL/i.exec(e)||/INTEL/i.exec(t)?"intel":/Apple/i.exec(e)||/Apple/i.exec(t)?"apple":/AMD/i.exec(e)||/AMD/i.exec(t)||/ATI/i.exec(e)||/ATI/i.exec(t)?"amd":/SwiftShader/i.exec(e)||/SwiftShader/i.exec(t)?"software":"unknown"}function ee(e){switch(e){case"uint8":case"unorm8":return L.UNSIGNED_BYTE;case"sint8":case"snorm8":return L.BYTE;case"uint16":case"unorm16":return L.UNSIGNED_SHORT;case"sint16":case"snorm16":return L.SHORT;case"uint32":return L.UNSIGNED_INT;case"sint32":return L.INT;case"float16":return L.HALF_FLOAT;case"float32":return L.FLOAT}throw new Error(String(e))}const te="texture-compression-bc",ne="texture-compression-astc",ie="texture-compression-etc2",re="texture-compression-pvrtc-webgl",oe="texture-compression-atc-webgl",se="float32-renderable-webgl",ae="float16-renderable-webgl",le="snorm8-renderable-webgl",ce="norm16-renderable-webgl",ue="snorm16-renderable-webgl",de="float32-filterable",fe="float16-filterable-webgl",_e="WEBGL_compressed_texture_s3tc",he="WEBGL_compressed_texture_s3tc_srgb",pe="EXT_texture_compression_rgtc",me="EXT_texture_compression_bptc",ge="EXT_texture_norm16",Ee="EXT_render_snorm",Ae={"float32-renderable-webgl":["EXT_color_buffer_float"],"float16-renderable-webgl":["EXT_color_buffer_half_float"],"rgb9e5ufloat_renderable-webgl":["WEBGL_render_shared_exponent"],"snorm8-renderable-webgl":[Ee],"norm16-renderable-webgl":[ge],"snorm16-renderable-webgl":[ge,Ee],"float32-filterable":["OES_texture_float_linear"],"float16-filterable-webgl":["OES_texture_half_float_linear"],"texture-filterable-anisotropic-webgl":["EXT_texture_filter_anisotropic"],"texture-blend-float-webgl":["EXT_float_blend"],"texture-compression-bc":[_e,he,pe,me],"texture-compression-bc5-webgl":[pe],"texture-compression-bc7-webgl":[me],"texture-compression-etc2":["WEBGL_compressed_texture_etc"],"texture-compression-astc":["WEBGL_compressed_texture_astc"],"texture-compression-etc1-webgl":["WEBGL_compressed_texture_etc1"],"texture-compression-pvrtc-webgl":["WEBGL_compressed_texture_pvrtc"],"texture-compression-atc-webgl":["WEBGL_compressed_texture_atc"]};function ve(e,t,n){return(Ae[t]||[]).every((t=>q(e,t,n)))}const Te={r8unorm:{gl:L.R8,b:1,c:1,rb:!0},r8snorm:{gl:L.R8_SNORM,b:1,c:1,render:le},r8uint:{gl:L.R8UI,b:1,c:1,rb:!0},r8sint:{gl:L.R8I,b:1,c:1,rb:!0},rg8unorm:{gl:L.RG8,b:2,c:2,rb:!0},rg8snorm:{gl:L.RG8_SNORM,b:2,c:2,render:le},rg8uint:{gl:L.RG8UI,b:2,c:2,rb:!0},rg8sint:{gl:L.RG8I,b:2,c:2,rb:!0},r16uint:{gl:L.R16UI,b:2,c:1,rb:!0},r16sint:{gl:L.R16I,b:2,c:1,rb:!0},r16float:{gl:L.R16F,b:2,c:1,render:ae,filter:"float16-filterable-webgl",rb:!0},"r16unorm-webgl":{gl:L.R16_EXT,b:2,c:1,f:ce,rb:!0},"r16snorm-webgl":{gl:L.R16_SNORM_EXT,b:2,c:1,f:ue},"rgba4unorm-webgl":{gl:L.RGBA4,b:2,c:4,wgpu:!1,rb:!0},"rgb565unorm-webgl":{gl:L.RGB565,b:2,c:4,wgpu:!1,rb:!0},"rgb5a1unorm-webgl":{gl:L.RGB5_A1,b:2,c:4,wgpu:!1,rb:!0},"rgb8unorm-webgl":{gl:L.RGB8,b:3,c:3,wgpu:!1},"rgb8snorm-webgl":{gl:L.RGB8_SNORM,b:3,c:3,wgpu:!1},rgba8unorm:{gl:L.RGBA8,b:4,c:2,bpp:4},"rgba8unorm-srgb":{gl:L.SRGB8_ALPHA8,b:4,c:4,bpp:4},rgba8snorm:{gl:L.RGBA8_SNORM,b:4,c:4,render:le},rgba8uint:{gl:L.RGBA8UI,b:4,c:4,bpp:4},rgba8sint:{gl:L.RGBA8I,b:4,c:4,bpp:4},bgra8unorm:{b:4,c:4},"bgra8unorm-srgb":{b:4,c:4},rg16uint:{gl:L.RG16UI,b:4,c:1,bpp:4},rg16sint:{gl:L.RG16I,b:4,c:2,bpp:4},rg16float:{gl:L.RG16F,bpp:4,b:4,c:2,render:ae,filter:fe,rb:!0},"rg16unorm-webgl":{gl:L.RG16_EXT,b:2,c:2,render:ce},"rg16snorm-webgl":{gl:L.RG16_SNORM_EXT,b:2,c:2,render:ue},r32uint:{gl:L.R32UI,b:4,c:1,bpp:4,rb:!0},r32sint:{gl:L.R32I,b:4,c:1,bpp:4,rb:!0},r32float:{gl:L.R32F,bpp:4,b:4,c:1,render:se,filter:de},rgb9e5ufloat:{gl:L.RGB9_E5,b:4,c:3,p:1,render:"rgb9e5ufloat_renderable-webgl"},rg11b10ufloat:{gl:L.R11F_G11F_B10F,b:4,c:3,p:1,render:se,rb:!0},rgb10a2unorm:{gl:L.RGB10_A2,b:4,c:4,p:1,rb:!0},"rgb10a2uint-webgl":{b:4,c:4,gl:L.RGB10_A2UI,p:1,wgpu:!1,bpp:4,rb:!0},"rgb16unorm-webgl":{gl:L.RGB16_EXT,b:2,c:3,f:ce},"rgb16snorm-webgl":{gl:L.RGB16_SNORM_EXT,b:2,c:3,f:ce},rg32uint:{gl:L.RG32UI,b:8,c:2,rb:!0},rg32sint:{gl:L.RG32I,b:8,c:2,rb:!0},rg32float:{gl:L.RG32F,b:8,c:2,render:se,filter:de,rb:!0},rgba16uint:{gl:L.RGBA16UI,b:8,c:4,rb:!0},rgba16sint:{gl:L.RGBA16I,b:8,c:4,rb:!0},rgba16float:{gl:L.RGBA16F,b:8,c:4,render:ae,filter:fe},"rgba16unorm-webgl":{gl:L.RGBA16_EXT,b:2,c:4,render:ce,rb:!0},"rgba16snorm-webgl":{gl:L.RGBA16_SNORM_EXT,b:2,c:4,render:ue},"rgb32float-webgl":{gl:L.RGB32F,render:se,filter:de,gl2ext:"EXT_color_buffer_float",dataFormat:L.RGB,types:[L.FLOAT]},rgba32uint:{gl:L.RGBA32UI,b:16,c:4,rb:!0},rgba32sint:{gl:L.RGBA32I,b:16,c:4,rb:!0},rgba32float:{gl:L.RGBA32F,b:16,c:4,render:se,filter:de,rb:!0},stencil8:{gl:L.STENCIL_INDEX8,b:1,c:1,attachment:L.STENCIL_ATTACHMENT,rb:!0},depth16unorm:{gl:L.DEPTH_COMPONENT16,b:2,c:1,attachment:L.DEPTH_ATTACHMENT,dataFormat:L.DEPTH_COMPONENT,types:[L.UNSIGNED_SHORT],rb:!0},depth24plus:{gl:L.DEPTH_COMPONENT24,b:3,c:1,attachment:L.DEPTH_ATTACHMENT,dataFormat:L.DEPTH_COMPONENT,types:[L.UNSIGNED_INT]},depth32float:{gl:L.DEPTH_COMPONENT32F,b:4,c:1,attachment:L.DEPTH_ATTACHMENT,dataFormat:L.DEPTH_COMPONENT,types:[L.FLOAT],rb:!0},"depth24plus-stencil8":{gl:L.DEPTH24_STENCIL8,b:4,c:2,p:1,attachment:L.DEPTH_STENCIL_ATTACHMENT,rb:!0,depthTexture:!0,dataFormat:L.DEPTH_STENCIL,types:[L.UNSIGNED_INT_24_8]},"depth32float-stencil8":{gl:L.DEPTH32F_STENCIL8,b:5,c:2,p:1,attachment:L.DEPTH_STENCIL_ATTACHMENT,dataFormat:L.DEPTH_STENCIL,types:[L.FLOAT_32_UNSIGNED_INT_24_8_REV],rb:!0},"bc1-rgb-unorm-webgl":{gl:L.COMPRESSED_RGB_S3TC_DXT1_EXT,x:_e,f:te},"bc1-rgb-unorm-srgb-webgl":{gl:L.COMPRESSED_SRGB_S3TC_DXT1_EXT,x:he,f:te},"bc1-rgba-unorm":{gl:L.COMPRESSED_RGBA_S3TC_DXT1_EXT,x:_e,f:te},"bc1-rgba-unorm-srgb":{gl:L.COMPRESSED_SRGB_S3TC_DXT1_EXT,x:he,f:te},"bc2-rgba-unorm":{gl:L.COMPRESSED_RGBA_S3TC_DXT3_EXT,x:_e,f:te},"bc2-rgba-unorm-srgb":{gl:L.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,x:he,f:te},"bc3-rgba-unorm":{gl:L.COMPRESSED_RGBA_S3TC_DXT5_EXT,x:_e,f:te},"bc3-rgba-unorm-srgb":{gl:L.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT,x:he,f:te},"bc4-r-unorm":{gl:L.COMPRESSED_RED_RGTC1_EXT,x:pe,f:te},"bc4-r-snorm":{gl:L.COMPRESSED_SIGNED_RED_RGTC1_EXT,x:pe,f:te},"bc5-rg-unorm":{gl:L.COMPRESSED_RED_GREEN_RGTC2_EXT,x:pe,f:te},"bc5-rg-snorm":{gl:L.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT,x:pe,f:te},"bc6h-rgb-ufloat":{gl:L.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT,x:me,f:te},"bc6h-rgb-float":{gl:L.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT,x:me,f:te},"bc7-rgba-unorm":{gl:L.COMPRESSED_RGBA_BPTC_UNORM_EXT,x:me,f:te},"bc7-rgba-unorm-srgb":{gl:L.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT,x:me,f:te},"etc2-rgb8unorm":{gl:L.COMPRESSED_RGB8_ETC2,f:ie},"etc2-rgb8unorm-srgb":{gl:L.COMPRESSED_SRGB8_ETC2,f:ie},"etc2-rgb8a1unorm":{gl:L.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,f:ie},"etc2-rgb8a1unorm-srgb":{gl:L.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,f:ie},"etc2-rgba8unorm":{gl:L.COMPRESSED_RGBA8_ETC2_EAC,f:ie},"etc2-rgba8unorm-srgb":{gl:L.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,f:ie},"eac-r11unorm":{gl:L.COMPRESSED_R11_EAC,f:ie},"eac-r11snorm":{gl:L.COMPRESSED_SIGNED_R11_EAC,f:ie},"eac-rg11unorm":{gl:L.COMPRESSED_RG11_EAC,f:ie},"eac-rg11snorm":{gl:L.COMPRESSED_SIGNED_RG11_EAC,f:ie},"astc-4x4-unorm":{gl:L.COMPRESSED_RGBA_ASTC_4x4_KHR,f:ne},"astc-4x4-unorm-srgb":{gl:L.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,f:ne},"astc-5x4-unorm":{gl:L.COMPRESSED_RGBA_ASTC_5x4_KHR,f:ne},"astc-5x4-unorm-srgb":{gl:L.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR,f:ne},"astc-5x5-unorm":{gl:L.COMPRESSED_RGBA_ASTC_5x5_KHR,f:ne},"astc-5x5-unorm-srgb":{gl:L.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,f:ne},"astc-6x5-unorm":{gl:L.COMPRESSED_RGBA_ASTC_6x5_KHR,f:ne},"astc-6x5-unorm-srgb":{gl:L.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,f:ne},"astc-6x6-unorm":{gl:L.COMPRESSED_RGBA_ASTC_6x6_KHR,f:ne},"astc-6x6-unorm-srgb":{gl:L.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,f:ne},"astc-8x5-unorm":{gl:L.COMPRESSED_RGBA_ASTC_8x5_KHR,f:ne},"astc-8x5-unorm-srgb":{gl:L.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,f:ne},"astc-8x6-unorm":{gl:L.COMPRESSED_RGBA_ASTC_8x6_KHR,f:ne},"astc-8x6-unorm-srgb":{gl:L.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,f:ne},"astc-8x8-unorm":{gl:L.COMPRESSED_RGBA_ASTC_8x8_KHR,f:ne},"astc-8x8-unorm-srgb":{gl:L.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,f:ne},"astc-10x5-unorm":{gl:L.COMPRESSED_RGBA_ASTC_10x10_KHR,f:ne},"astc-10x5-unorm-srgb":{gl:L.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,f:ne},"astc-10x6-unorm":{gl:L.COMPRESSED_RGBA_ASTC_10x6_KHR,f:ne},"astc-10x6-unorm-srgb":{gl:L.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,f:ne},"astc-10x8-unorm":{gl:L.COMPRESSED_RGBA_ASTC_10x8_KHR,f:ne},"astc-10x8-unorm-srgb":{gl:L.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,f:ne},"astc-10x10-unorm":{gl:L.COMPRESSED_RGBA_ASTC_10x10_KHR,f:ne},"astc-10x10-unorm-srgb":{gl:L.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,f:ne},"astc-12x10-unorm":{gl:L.COMPRESSED_RGBA_ASTC_12x10_KHR,f:ne},"astc-12x10-unorm-srgb":{gl:L.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,f:ne},"astc-12x12-unorm":{gl:L.COMPRESSED_RGBA_ASTC_12x12_KHR,f:ne},"astc-12x12-unorm-srgb":{gl:L.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR,f:ne},"pvrtc-rgb4unorm-webgl":{gl:L.COMPRESSED_RGB_PVRTC_4BPPV1_IMG,f:re},"pvrtc-rgba4unorm-webgl":{gl:L.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,f:re},"pvrtc-rbg2unorm-webgl":{gl:L.COMPRESSED_RGB_PVRTC_2BPPV1_IMG,f:re},"pvrtc-rgba2unorm-webgl":{gl:L.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG,f:re},"etc1-rbg-unorm-webgl":{gl:L.COMPRESSED_RGB_ETC1_WEBGL,f:"texture-compression-etc1-webgl"},"atc-rgb-unorm-webgl":{gl:L.COMPRESSED_RGB_ATC_WEBGL,f:oe},"atc-rgba-unorm-webgl":{gl:L.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL,f:oe},"atc-rgbai-unorm-webgl":{gl:L.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL,f:oe}};L.RED,L.RED_INTEGER,L.RG,L.RG_INTEGER,L.RGB,L.RGB_INTEGER,L.RGBA,L.RGBA_INTEGER,L.DEPTH_COMPONENT,L.DEPTH_STENCIL,L.ALPHA,L.LUMINANCE,L.LUMINANCE_ALPHA,L.FLOAT,L.UNSIGNED_INT,L.INT,L.UNSIGNED_SHORT,L.SHORT,L.HALF_FLOAT,L.BYTE,L.UNSIGNED_BYTE;function Re(e,t,n){const i=Te[t];if(!i)return!1;if(void 0===i.gl)return!1;const r=i.f;if(r)return ve(e,r,n);const o=i.x||i.gl2ext;return!o||Boolean(q(e,o,n))}function be(e){const t=Te[e],n=function(e){const t=Te[e],n=t?.gl;if(void 0===n)throw new Error(`Unsupported texture format ${e}`);return n}(e),i=v(e);return{internalFormat:n,format:t?.dataFormat||Se(i.channels,i.integer,i.normalized,n),type:i.dataType?ee(i.dataType):t?.types?.[0]||L.UNSIGNED_BYTE,compressed:i.compressed||!1}}function Se(e,t,n,i){if(i===L.RGBA||i===L.RGB)return i;switch(e){case"r":return t&&!n?L.RED_INTEGER:L.RED;case"rg":return t&&!n?L.RG_INTEGER:L.RG;case"rgb":return t&&!n?L.RGB_INTEGER:L.RGB;case"rgba":return t&&!n?L.RGBA_INTEGER:L.RGBA;case"bgra":throw new Error("bgra pixels not supported by WebGL");default:return L.RGBA}}const Ce={"depth-clip-control":"EXT_depth_clamp","timer-query-webgl":"EXT_disjoint_timer_query_webgl2","compilation-status-async-webgl":"KHR_parallel_shader_compile","polygon-mode-webgl":"WEBGL_polygon_mode","provoking-vertex-webgl":"WEBGL_provoking_vertex","shader-clip-cull-distance-webgl":"WEBGL_clip_cull_distance","shader-noperspective-interpolation-webgl":"NV_shader_noperspective_interpolation","shader-conservative-depth-webgl":"EXT_conservative_depth"};class Ie extends b{testedFeatures=(()=>new Set)();constructor(e,t,n){super([],n),this.gl=e,this.extensions=t,q(e,"EXT_color_buffer_float",t)}*[Symbol.iterator](){const e=this.getFeatures();for(const t of e)this.has(t)&&(yield t);return[]}has(e){return!this.disabledFeatures?.[e]&&(this.testedFeatures.has(e)||(this.testedFeatures.add(e),function(e){return e in Ae}(e)&&ve(this.gl,e,this.extensions)&&this.features.add(e),this.getWebGLFeature(e)&&this.features.add(e)),this.features.has(e))}initializeFeatures(){const e=this.getFeatures().filter((e=>"polygon-mode-webgl"!==e));for(const t of e)this.has(t)}getFeatures(){return[...Object.keys(Ce),...Object.keys(Ae)]}getWebGLFeature(e){const t=Ce[e];return"string"==typeof t?Boolean(q(this.gl,t,this.extensions)):Boolean(t)}}class Pe extends R{get maxTextureDimension1D(){return 0}get maxTextureDimension2D(){return this.getParameter(L.MAX_TEXTURE_SIZE)}get maxTextureDimension3D(){return this.getParameter(L.MAX_3D_TEXTURE_SIZE)}get maxTextureArrayLayers(){return this.getParameter(L.MAX_ARRAY_TEXTURE_LAYERS)}get maxBindGroups(){return 0}get maxDynamicUniformBuffersPerPipelineLayout(){return 0}get maxDynamicStorageBuffersPerPipelineLayout(){return 0}get maxSampledTexturesPerShaderStage(){return this.getParameter(L.MAX_VERTEX_TEXTURE_IMAGE_UNITS)}get maxSamplersPerShaderStage(){return this.getParameter(L.MAX_COMBINED_TEXTURE_IMAGE_UNITS)}get maxStorageBuffersPerShaderStage(){return 0}get maxStorageTexturesPerShaderStage(){return 0}get maxUniformBuffersPerShaderStage(){return this.getParameter(L.MAX_UNIFORM_BUFFER_BINDINGS)}get maxUniformBufferBindingSize(){return this.getParameter(L.MAX_UNIFORM_BLOCK_SIZE)}get maxStorageBufferBindingSize(){return 0}get minUniformBufferOffsetAlignment(){return this.getParameter(L.UNIFORM_BUFFER_OFFSET_ALIGNMENT)}get minStorageBufferOffsetAlignment(){return 0}get maxVertexBuffers(){return 16}get maxVertexAttributes(){return this.getParameter(L.MAX_VERTEX_ATTRIBS)}get maxVertexBufferArrayStride(){return 2048}get maxInterStageShaderComponents(){return this.getParameter(L.MAX_VARYING_COMPONENTS)}get maxComputeWorkgroupStorageSize(){return 0}get maxComputeInvocationsPerWorkgroup(){return 0}get maxComputeWorkgroupSizeX(){return 0}get maxComputeWorkgroupSizeY(){return 0}get maxComputeWorkgroupSizeZ(){return 0}get maxComputeWorkgroupsPerDimension(){return 0}limits={};constructor(e){super(),this.gl=e}getParameter(e){return void 0===this.limits[e]&&(this.limits[e]=this.gl.getParameter(e)),this.limits[e]||0}}class xe{static defaultProps={canvas:null,width:800,height:600,useDevicePixels:!0,autoResize:!0,container:null,visible:!0,alphaMode:"opaque",colorSpace:"srgb"};width=1;height=1;_canvasSizeInfo={clientWidth:0,clientHeight:0,devicePixelRatio:1};constructor(e){if(this.props={...xe.defaultProps,...e},e=this.props,!(0,u.B)())return this.id="node-canvas-context",this.type="node",this.width=this.props.width,this.height=this.props.height,void(this.canvas=null);if(e.canvas)"string"==typeof e.canvas?this.canvas=function(e){const t=document.getElementById(e);if(!(t instanceof HTMLCanvasElement))throw new Error("Object is not a canvas element");return t}(e.canvas):this.canvas=e.canvas;else{const t=function(e){const{width:t,height:n}=e,i=document.createElement("canvas");return i.id="lumagl-auto-created-canvas",i.width=t||1,i.height=n||1,i.style.width=Number.isFinite(t)?`${t}px`:"100%",i.style.height=Number.isFinite(n)?`${n}px`:"100%",i}(e),n=function(e){if("string"==typeof e){const t=document.getElementById(e);if(!t)throw new Error(`${e} is not an HTML element`);return t}if(e)return e;return document.body}(e?.container||null);n.insertBefore(t,n.firstChild),this.canvas=t,e?.visible||(this.canvas.style.visibility="hidden")}this.canvas instanceof HTMLCanvasElement?(this.id=this.canvas.id,this.type="html-canvas",this.htmlCanvas=this.canvas):(this.id="offscreen-canvas",this.type="offscreen-canvas",this.offscreenCanvas=this.canvas),this.canvas instanceof HTMLCanvasElement&&e.autoResize&&(this.resizeObserver=new ResizeObserver((e=>{for(const t of e)t.target===this.canvas&&this.update()})),this.resizeObserver.observe(this.canvas))}getDevicePixelRatio(e){if("undefined"!=typeof OffscreenCanvas&&this.canvas instanceof OffscreenCanvas)return 1;if(!(e=void 0===e?this.props.useDevicePixels:e)||e<=0)return 1;if(!0===e){return"undefined"!=typeof window&&window.devicePixelRatio||1}return e}getPixelSize(){switch(this.type){case"node":return[this.width,this.height];case"offscreen-canvas":return[this.canvas.width,this.canvas.height];case"html-canvas":const e=this.getDevicePixelRatio(),t=this.canvas;return t.parentElement?[t.clientWidth*e,t.clientHeight*e]:[this.canvas.width,this.canvas.height];default:throw new Error(this.type)}}getAspect(){const[e,t]=this.getPixelSize();return e/t}cssToDeviceRatio(){try{const[e]=this.getDrawingBufferSize(),{clientWidth:t}=this._canvasSizeInfo;return t?e/t:1}catch{return 1}}cssToDevicePixels(e,t){void 0===t&&(t=!0);const n=this.cssToDeviceRatio(),[i,r]=this.getDrawingBufferSize();return function(e,t,n,i,r){const o=e,s=Ne(o[0],t,n);let a=Le(o[1],t,i,r),l=Ne(o[0]+1,t,n);const c=l===n-1?l:l-1;let u;l=Le(o[1]+1,t,i,r),r?(l=0===l?l:l+1,u=a,a=l):u=l===i-1?l:l-1;return{x:s,y:a,width:Math.max(c-s+1,1),height:Math.max(u-a+1,1)}}(e,n,i,r,t)}setDevicePixelRatio(e,t){if(void 0===t&&(t={}),!this.htmlCanvas)return;let n="width"in t?t.width:this.htmlCanvas.clientWidth,i="height"in t?t.height:this.htmlCanvas.clientHeight;n&&i||(_.R.log(1,"Canvas clientWidth/clientHeight is 0")(),e=1,n=this.htmlCanvas.width||1,i=this.htmlCanvas.height||1);const r=this._canvasSizeInfo;if(r.clientWidth!==n||r.clientHeight!==i||r.devicePixelRatio!==e){let t=e;const r=Math.floor(n*t),o=Math.floor(i*t);this.htmlCanvas.width=r,this.htmlCanvas.height=o;if(this.device.gl){const[s,a]=this.getDrawingBufferSize();s===r&&a===o||(t=Math.min(s/n,a/i),this.htmlCanvas.width=Math.floor(n*t),this.htmlCanvas.height=Math.floor(i*t),_.R.warn("Device pixel ratio clamped")()),this._canvasSizeInfo.clientWidth=n,this._canvasSizeInfo.clientHeight=i,this._canvasSizeInfo.devicePixelRatio=e}}}getDrawingBufferSize(){const e=this.device.gl;if(!e)throw new Error("canvas size");return[e.drawingBufferWidth,e.drawingBufferHeight]}_setAutoCreatedCanvasId(e){"lumagl-auto-created-canvas"===this.htmlCanvas?.id&&(this.htmlCanvas.id=e)}}function Ne(e,t,n){return Math.min(Math.round(e*t),n-1)}function Le(e,t,n,i){return i?Math.max(0,n-1-Math.round(e*t)):Math.min(Math.round(e*t),n-1)}var Fe=n(8314),ye=n(5839);class Me extends Fe.F{static defaultProps={...Fe.F.defaultProps,width:1,height:1,colorAttachments:[],depthStencilAttachment:null};get[Symbol.toStringTag](){return"Framebuffer"}constructor(e,t){void 0===t&&(t={}),super(e,t,Me.defaultProps),this.width=this.props.width,this.height=this.props.height}clone(e){const t=this.colorAttachments.map((t=>t.texture.clone(e))),n=this.depthStencilAttachment&&this.depthStencilAttachment.texture.clone(e);return this.device.createFramebuffer({...this.props,colorAttachments:t,depthStencilAttachment:n})}resize(e){let t=!e;if(e){const[n,i]=Array.isArray(e)?e:[e.width,e.height];t=t||i!==this.height||n!==this.width,this.width=n,this.height=i}t&&(_.R.log(2,`Resizing framebuffer ${this.id} to ${this.width}x${this.height}`)(),this.resizeAttachments(this.width,this.height))}autoCreateAttachmentTextures(){if(0===this.props.colorAttachments.length&&!this.props.depthStencilAttachment)throw new Error("Framebuffer has noattachments");this.colorAttachments=this.props.colorAttachments.map(((e,t)=>{if("string"==typeof e){const n=this.createColorTexture(e,t);return this.attachResource(n),n.view}return e instanceof ye.g?e.view:e}));const e=this.props.depthStencilAttachment;if(e)if("string"==typeof e){const t=this.createDepthStencilTexture(e);this.attachResource(t),this.depthStencilAttachment=t.view}else e instanceof ye.g?this.depthStencilAttachment=e.view:this.depthStencilAttachment=e}createColorTexture(e,t){return this.device.createTexture({id:`${this.id}-color-attachment-${t}`,usage:ye.g.RENDER_ATTACHMENT,format:e,width:this.width,height:this.height,mipmaps:!1,sampler:{magFilter:"linear",minFilter:"linear"}})}createDepthStencilTexture(e){return this.device.createTexture({id:`${this.id}-depth-stencil-attachment`,usage:ye.g.RENDER_ATTACHMENT,format:e,width:this.width,height:this.height,mipmaps:!1})}resizeAttachments(e,t){for(let n=0;n<this.colorAttachments.length;++n)if(this.colorAttachments[n]){const i=this.colorAttachments[n].texture.clone({width:e,height:t});this.destroyAttachedResource(this.colorAttachments[n]),this.colorAttachments[n]=i.view,this.attachResource(i.view)}if(this.depthStencilAttachment){const n=this.depthStencilAttachment.texture.clone({width:e,height:t});this.destroyAttachedResource(this.depthStencilAttachment),this.depthStencilAttachment=n.view,this.attachResource(n)}this.updateAttachments()}}class Oe extends Me{colorAttachments=[];depthStencilAttachment=null;constructor(e,t){super(e,t);const n=null===t.handle;this.device=e,this.gl=e.gl,this.handle=this.props.handle||n?this.props.handle:this.gl.createFramebuffer(),n||(e.setSpectorMetadata(this.handle,{id:this.props.id,props:this.props}),this.autoCreateAttachmentTextures(),this.updateAttachments())}destroy(){super.destroy(),this.destroyed||null===this.handle||this.gl.deleteFramebuffer(this.handle)}updateAttachments(){const e=this.gl.bindFramebuffer(L.FRAMEBUFFER,this.handle);for(let t=0;t<this.colorAttachments.length;++t){const e=this.colorAttachments[t];if(e){const n=L.COLOR_ATTACHMENT0+t;this._attachTextureView(n,e)}}if(this.depthStencilAttachment){const e=function(e){const t=Te[e];if(!t?.attachment)throw new Error(`${e} is not a depth stencil format`);return t.attachment}(this.depthStencilAttachment.props.format);this._attachTextureView(e,this.depthStencilAttachment)}if(this.device.props.debug){const e=this.gl.checkFramebufferStatus(L.FRAMEBUFFER);if(e!==L.FRAMEBUFFER_COMPLETE)throw new Error(`Framebuffer ${function(e){switch(e){case L.FRAMEBUFFER_COMPLETE:return"success";case L.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"Mismatched attachments";case L.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"No attachments";case L.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"Height/width mismatch";case L.FRAMEBUFFER_UNSUPPORTED:return"Unsupported or split attachments";case L.FRAMEBUFFER_INCOMPLETE_MULTISAMPLE:return"Samples mismatch";default:return`${e}`}}(e)}`)}this.gl.bindFramebuffer(L.FRAMEBUFFER,e)}_attachTextureView(e,t){const{gl:n}=this.device,{texture:i}=t,r=t.props.baseMipLevel,o=t.props.baseArrayLayer;switch(n.bindTexture(i.glTarget,i.handle),i.glTarget){case L.TEXTURE_2D_ARRAY:case L.TEXTURE_3D:n.framebufferTextureLayer(L.FRAMEBUFFER,e,i.handle,r,o);break;case L.TEXTURE_CUBE_MAP:const t=function(e){return e<L.TEXTURE_CUBE_MAP_POSITIVE_X?e+L.TEXTURE_CUBE_MAP_POSITIVE_X:e}(o);n.framebufferTexture2D(L.FRAMEBUFFER,e,t,i.handle,r);break;case L.TEXTURE_2D:n.framebufferTexture2D(L.FRAMEBUFFER,e,L.TEXTURE_2D,i.handle,r);break;default:throw new Error("Illegal texture type")}n.bindTexture(i.glTarget,null)}}class Be extends xe{format="rgba8unorm";depthStencilFormat="depth24plus";_framebuffer=null;constructor(e,t){super(t),this.device=e,this.presentationSize=[-1,-1],this._setAutoCreatedCanvasId(`${this.device.id}-canvas`),this.update()}getCurrentFramebuffer(){return this.update(),this._framebuffer=this._framebuffer||new Oe(this.device,{handle:null}),this._framebuffer}update(){const e=this.getPixelSize();(e[0]!==this.presentationSize[0]||e[1]!==this.presentationSize[1])&&(this.presentationSize=e,this.resize())}resize(e){if(this.device.gl)if(this.canvas){const t=this.getDevicePixelRatio(e?.useDevicePixels);this.setDevicePixelRatio(t,e)}else;}commit(){}}async function De(e,t){const n=document.getElementsByTagName("head")[0];if(!n)throw new Error("loadScript");const i=document.createElement("script");return i.setAttribute("type","text/javascript"),i.setAttribute("src",e),t&&(i.id=t),new Promise(((t,r)=>{i.onload=t,i.onerror=t=>r(new Error(`Unable to load script '${e}': ${t}`)),n.appendChild(i)}))}let we=null,Ue=!1;const Ge={debugSpectorJS:_.R.get("debug-spectorjs"),debugSpectorJSUrl:"https://cdn.jsdelivr.net/npm/spectorjs@0.9.30/dist/spector.bundle.js",gl:void 0};function He(e){return e.luma=e.luma||{},e.luma}function Xe(e,t){return void 0===t&&(t={}),t.debugWebGL||t.traceWebGL?function(e,t){if(!globalThis.WebGLDebugUtils)return _.R.warn("webgl-debug not loaded")(),e;const n=He(e);if(n.debugContext)return n.debugContext;globalThis.WebGLDebugUtils.init({...L,...e});const i=globalThis.WebGLDebugUtils.makeDebugContext(e,ke.bind(null,t),We.bind(null,t));for(const s in L)s in i||"number"!=typeof L[s]||(i[s]=L[s]);class r{}Object.setPrototypeOf(i,Object.getPrototypeOf(e)),Object.setPrototypeOf(r,i);const o=Object.create(r);return n.realContext=e,n.debugContext=o,o.debug=!0,o}(e,t):function(e){const t=He(e);return t.realContext?t.realContext:e}(e)}function Ve(e,t){t=Array.from(t).map((e=>void 0===e?"undefined":e));let n=globalThis.WebGLDebugUtils.glFunctionArgsToString(e,t);return n=`${n.slice(0,100)}${n.length>100?"...":""}`,`gl.${e}(${n})`}function ke(e,t,n,i){i=Array.from(i).map((e=>void 0===e?"undefined":e));const r=`${globalThis.WebGLDebugUtils.glEnumToString(t)} in gl.${n}(${globalThis.WebGLDebugUtils.glFunctionArgsToString(n,i)})`;_.R.error(r)()}function We(e,t,n){let i="";_.R.level>=1&&(i=Ve(t,n),e.traceWebGL&&_.R.log(1,i)());for(const r of n)void 0===r&&(i=i||Ve(t,n))}const Ye={};function ze(e){void 0===e&&(e="id"),Ye[e]=Ye[e]||1;return`${e}-${Ye[e]++}`}class Ke extends p.h{glIndexType=(()=>L.UNSIGNED_SHORT)();constructor(e,t){void 0===t&&(t={}),super(e,t),this.device=e,this.gl=this.device.gl;const n="object"==typeof t?t.handle:void 0;this.handle=n||this.gl.createBuffer(),e.setSpectorMetadata(this.handle,{...this.props,data:typeof this.props.data}),this.glTarget=function(e){if(e&p.h.INDEX)return L.ELEMENT_ARRAY_BUFFER;if(e&p.h.VERTEX)return L.ARRAY_BUFFER;if(e&p.h.UNIFORM)return L.UNIFORM_BUFFER;return L.ARRAY_BUFFER}(this.props.usage),this.glUsage=function(e){if(e&p.h.INDEX)return L.STATIC_DRAW;if(e&p.h.VERTEX)return L.STATIC_DRAW;if(e&p.h.UNIFORM)return L.DYNAMIC_DRAW;return L.STATIC_DRAW}(this.props.usage),this.glIndexType="uint32"===this.props.indexType?L.UNSIGNED_INT:L.UNSIGNED_SHORT,t.data?this._initWithData(t.data,t.byteOffset,t.byteLength):this._initWithByteLength(t.byteLength||0)}_initWithData(e,t,n){void 0===t&&(t=0),void 0===n&&(n=e.byteLength+t);const i=this.glTarget;this.gl.bindBuffer(i,this.handle),this.gl.bufferData(i,n,this.glUsage),this.gl.bufferSubData(i,t,e),this.gl.bindBuffer(i,null),this.bytesUsed=n,this.byteLength=n,this._setDebugData(e,t,n),this.trackAllocatedMemory(n)}_initWithByteLength(e){let t=e;0===e&&(t=new Float32Array(0));const n=this.glTarget;return this.gl.bindBuffer(n,this.handle),this.gl.bufferData(n,t,this.glUsage),this.gl.bindBuffer(n,null),this.bytesUsed=e,this.byteLength=e,this._setDebugData(null,0,e),this.trackAllocatedMemory(e),this}destroy(){!this.destroyed&&this.handle&&(this.removeStats(),this.trackDeallocatedMemory(),this.gl.deleteBuffer(this.handle),this.destroyed=!0,this.handle=null)}write(e,t){void 0===t&&(t=0);const n=L.COPY_WRITE_BUFFER;this.gl.bindBuffer(n,this.handle),this.gl.bufferSubData(n,t,e),this.gl.bindBuffer(n,null),this._setDebugData(e,t,e.byteLength)}async readAsync(e,t){return void 0===e&&(e=0),this.readSyncWebGL(e,t)}readSyncWebGL(e,t){void 0===e&&(e=0),t=t??this.byteLength-e;const n=new Uint8Array(t);return this.gl.bindBuffer(L.COPY_READ_BUFFER,this.handle),this.gl.getBufferSubData(L.COPY_READ_BUFFER,e,n,0,t),this.gl.bindBuffer(L.COPY_READ_BUFFER,null),this._setDebugData(n,e,t),n}}var je=n(349);function Qe(e){const t=e.toLowerCase();return["warning","error","info"].includes(t)?t:"info"}class $e extends je.M{constructor(e,t){switch(super(e,t),this.device=e,this.props.stage){case"vertex":this.handle=this.props.handle||this.device.gl.createShader(L.VERTEX_SHADER);break;case"fragment":this.handle=this.props.handle||this.device.gl.createShader(L.FRAGMENT_SHADER);break;default:throw new Error(this.props.stage)}this._compile(this.source)}destroy(){this.handle&&(this.removeStats(),this.device.gl.deleteShader(this.handle),this.destroyed=!0)}get asyncCompilationStatus(){return this._waitForCompilationComplete().then((()=>this.compilationStatus))}async getCompilationInfo(){return await this._waitForCompilationComplete(),this.getCompilationInfoSync()}getCompilationInfoSync(){const e=this.device.gl.getShaderInfoLog(this.handle);return e?function(e){const t=e.split(/\r?\n/),n=[];for(const i of t){if(i.length<=1)continue;const e=i.split(":");if(2===e.length){const[t,i]=e;n.push({message:i.trim(),type:Qe(t),lineNum:0,linePos:0});continue}const[t,r,o,...s]=e;let a=parseInt(o,10);isNaN(a)&&(a=0);let l=parseInt(r,10);isNaN(l)&&(l=0),n.push({message:s.join(":").trim(),type:Qe(t),lineNum:a,linePos:l})}return n}(e):[]}getTranslatedSource(){const e=this.device.getExtension("WEBGL_debug_shaders").WEBGL_debug_shaders;return e?.getTranslatedShaderSource(this.handle)||null}async _compile(e){e=e.startsWith("#version ")?e:`#version 300 es\n${e}`;const{gl:t}=this.device;if(t.shaderSource(this.handle,e),t.compileShader(this.handle),this.device.props.debug){if(this.device.features.has("compilation-status-async-webgl"))_.R.once(1,"Shader compilation is asynchronous")(),await this._waitForCompilationComplete(),_.R.info(2,`Shader ${this.id} - async compilation complete: ${this.compilationStatus}`)(),this._getCompilationStatus(),this.debugShader();else if(this._getCompilationStatus(),this.debugShader(),"error"===this.compilationStatus)throw new Error(`GLSL compilation errors in ${this.props.stage} shader ${this.props.id}`)}else this.compilationStatus="pending"}async _waitForCompilationComplete(){const e=async e=>await new Promise((t=>setTimeout(t,e)));if(!this.device.features.has("compilation-status-async-webgl"))return void await e(10);const{gl:t}=this.device;for(;;){if(t.getShaderParameter(this.handle,L.COMPLETION_STATUS_KHR))return;await e(10)}}_getCompilationStatus(){this.compilationStatus=this.device.gl.getShaderParameter(this.handle,L.COMPILE_STATUS)?"success":"error"}}var qe=n(9532);function Ze(e,t){const n=e,{gl:i}=n;if(t.cullMode)switch(t.cullMode){case"none":i.disable(L.CULL_FACE);break;case"front":i.enable(L.CULL_FACE),i.cullFace(L.FRONT);break;case"back":i.enable(L.CULL_FACE),i.cullFace(L.BACK)}if(t.frontFace&&i.frontFace(it("frontFace",t.frontFace,{ccw:L.CCW,cw:L.CW})),t.unclippedDepth&&e.features.has("depth-clip-control")&&i.enable(L.DEPTH_CLAMP_EXT),void 0!==t.depthBias&&(i.enable(L.POLYGON_OFFSET_FILL),i.polygonOffset(t.depthBias,t.depthBiasSlopeScale||0)),t.provokingVertex&&e.features.has("provoking-vertex-webgl")){const e=n.getExtension("WEBGL_provoking_vertex").WEBGL_provoking_vertex,i=it("provokingVertex",t.provokingVertex,{first:L.FIRST_VERTEX_CONVENTION_WEBGL,last:L.LAST_VERTEX_CONVENTION_WEBGL});e?.provokingVertexWEBGL(i)}if((t.polygonMode||t.polygonOffsetLine)&&e.features.has("polygon-mode-webgl")){if(t.polygonMode){const e=n.getExtension("WEBGL_polygon_mode").WEBGL_polygon_mode,i=it("polygonMode",t.polygonMode,{fill:L.FILL_WEBGL,line:L.LINE_WEBGL});e?.polygonModeWEBGL(L.FRONT,i),e?.polygonModeWEBGL(L.BACK,i)}t.polygonOffsetLine&&i.enable(L.POLYGON_OFFSET_LINE_WEBGL)}if(e.features.has("shader-clip-cull-distance-webgl")&&(t.clipDistance0&&i.enable(L.CLIP_DISTANCE0_WEBGL),t.clipDistance1&&i.enable(L.CLIP_DISTANCE1_WEBGL),t.clipDistance2&&i.enable(L.CLIP_DISTANCE2_WEBGL),t.clipDistance3&&i.enable(L.CLIP_DISTANCE3_WEBGL),t.clipDistance4&&i.enable(L.CLIP_DISTANCE4_WEBGL),t.clipDistance5&&i.enable(L.CLIP_DISTANCE5_WEBGL),t.clipDistance6&&i.enable(L.CLIP_DISTANCE6_WEBGL),t.clipDistance7&&i.enable(L.CLIP_DISTANCE7_WEBGL)),void 0!==t.depthWriteEnabled&&i.depthMask(t.depthWriteEnabled),t.depthCompare&&("always"!==t.depthCompare?i.enable(L.DEPTH_TEST):i.disable(L.DEPTH_TEST),i.depthFunc(Je("depthCompare",t.depthCompare))),t.stencilWriteMask){const e=t.stencilWriteMask;i.stencilMaskSeparate(L.FRONT,e),i.stencilMaskSeparate(L.BACK,e)}if(t.stencilReadMask&&_.R.warn("stencilReadMask not supported under WebGL"),t.stencilCompare){const e=t.stencilReadMask||4294967295,n=Je("depthCompare",t.stencilCompare);"always"!==t.stencilCompare?i.enable(L.STENCIL_TEST):i.disable(L.STENCIL_TEST),i.stencilFuncSeparate(L.FRONT,n,0,e),i.stencilFuncSeparate(L.BACK,n,0,e)}if(t.stencilPassOperation&&t.stencilFailOperation&&t.stencilDepthFailOperation){const e=et("stencilPassOperation",t.stencilPassOperation),n=et("stencilFailOperation",t.stencilFailOperation),r=et("stencilDepthFailOperation",t.stencilDepthFailOperation);i.stencilOpSeparate(L.FRONT,n,r,e),i.stencilOpSeparate(L.BACK,n,r,e)}switch(t.blend){case!0:i.enable(L.BLEND);break;case!1:i.disable(L.BLEND)}if(t.blendColorOperation||t.blendAlphaOperation){const e=tt("blendColorOperation",t.blendColorOperation||"add"),n=tt("blendAlphaOperation",t.blendAlphaOperation||"add");i.blendEquationSeparate(e,n);const r=nt("blendColorSrcFactor",t.blendColorSrcFactor||"one"),o=nt("blendColorDstFactor",t.blendColorDstFactor||"zero"),s=nt("blendAlphaSrcFactor",t.blendAlphaSrcFactor||"one"),a=nt("blendAlphaDstFactor",t.blendAlphaDstFactor||"zero");i.blendFuncSeparate(r,o,s,a)}}function Je(e,t){return it(e,t,{never:L.NEVER,less:L.LESS,equal:L.EQUAL,"less-equal":L.LEQUAL,greater:L.GREATER,"not-equal":L.NOTEQUAL,"greater-equal":L.GEQUAL,always:L.ALWAYS})}function et(e,t){return it(e,t,{keep:L.KEEP,zero:L.ZERO,replace:L.REPLACE,invert:L.INVERT,"increment-clamp":L.INCR,"decrement-clamp":L.DECR,"increment-wrap":L.INCR_WRAP,"decrement-wrap":L.DECR_WRAP})}function tt(e,t){return it(e,t,{add:L.FUNC_ADD,subtract:L.FUNC_SUBTRACT,"reverse-subtract":L.FUNC_REVERSE_SUBTRACT,min:L.MIN,max:L.MAX})}function nt(e,t){return it(e,t,{one:L.ONE,zero:L.ZERO,"src-color":L.SRC_COLOR,"one-minus-src-color":L.ONE_MINUS_SRC_COLOR,"dst-color":L.DST_COLOR,"one-minus-dst-color":L.ONE_MINUS_DST_COLOR,"src-alpha":L.SRC_ALPHA,"one-minus-src-alpha":L.ONE_MINUS_SRC_ALPHA,"dst-alpha":L.DST_ALPHA,"one-minus-dst-alpha":L.ONE_MINUS_DST_ALPHA,"src-alpha-saturated":L.SRC_ALPHA_SATURATE,"constant-color":L.CONSTANT_COLOR,"one-minus-constant-color":L.ONE_MINUS_CONSTANT_COLOR,"constant-alpha":L.CONSTANT_ALPHA,"one-minus-constant-alpha":L.ONE_MINUS_CONSTANT_ALPHA})}function it(e,t,n){if(!(t in n))throw new Error(function(e,t){return`Illegal parameter ${t} for ${e}`}(e,t));return n[t]}function rt(e){let t=!0;for(const n in e){t=!1;break}return t}function ot(e){const t={};return e.addressModeU&&(t[L.TEXTURE_WRAP_S]=st(e.addressModeU)),e.addressModeV&&(t[L.TEXTURE_WRAP_T]=st(e.addressModeV)),e.addressModeW&&(t[L.TEXTURE_WRAP_R]=st(e.addressModeW)),e.magFilter&&(t[L.TEXTURE_MAG_FILTER]=at(e.magFilter)),(e.minFilter||e.mipmapFilter)&&(t[L.TEXTURE_MIN_FILTER]=function(e,t){void 0===t&&(t="none");if(!t)return at(e);switch(t){case"none":return at(e);case"nearest":return"nearest"===e?L.NEAREST_MIPMAP_NEAREST:L.NEAREST_MIPMAP_LINEAR;case"linear":return"nearest"===e?L.LINEAR_MIPMAP_NEAREST:L.LINEAR_MIPMAP_LINEAR}}(e.minFilter||"linear",e.mipmapFilter)),void 0!==e.lodMinClamp&&(t[L.TEXTURE_MIN_LOD]=e.lodMinClamp),void 0!==e.lodMaxClamp&&(t[L.TEXTURE_MAX_LOD]=e.lodMaxClamp),"comparison-sampler"===e.type&&(t[L.TEXTURE_COMPARE_MODE]=L.COMPARE_REF_TO_TEXTURE),e.compare&&(t[L.TEXTURE_COMPARE_FUNC]=Je("compare",e.compare)),e.maxAnisotropy&&(t[L.TEXTURE_MAX_ANISOTROPY_EXT]=e.maxAnisotropy),t}function st(e){switch(e){case"clamp-to-edge":return L.CLAMP_TO_EDGE;case"repeat":return L.REPEAT;case"mirror-repeat":return L.MIRRORED_REPEAT}}function at(e){switch(e){case"nearest":return L.NEAREST;case"linear":return L.LINEAR}}class lt extends qe.L{constructor(e,t){super(e,t),this.device=e,this.parameters=ot(t),this.handle=this.handle||this.device.gl.createSampler(),this._setSamplerParameters(this.parameters)}destroy(){this.handle&&(this.device.gl.deleteSampler(this.handle),this.handle=void 0)}toString(){return`Sampler(${this.id},${JSON.stringify(this.props)})`}_setSamplerParameters(e){for(const[t,n]of Object.entries(e)){const e=Number(t);switch(e){case L.TEXTURE_MIN_LOD:case L.TEXTURE_MAX_LOD:this.device.gl.samplerParameterf(this.handle,e,n);break;default:this.device.gl.samplerParameteri(this.handle,e,n)}}}}function ct(e,t,n){if(function(e){for(const t in e)return!1;return!0}(t))return n(e);const{nocatch:i=!0}=t,r=j.get(e);let o;if(r.push(),Y(e,t),i)o=n(e),r.pop();else try{o=n(e)}finally{r.pop()}return o}var ut=n(1213);class dt extends ut.X{constructor(e,t){super(e,{...ye.g.defaultProps,...t}),this.device=e,this.gl=this.device.gl,this.handle=null,this.texture=t.texture}}const ft="Failed to deduce GL constant from typed array";function _t(e){switch(e){case L.ALPHA:case L.R32F:case L.RED:case L.RED_INTEGER:return 1;case L.RG32I:case L.RG32UI:case L.RG32F:case L.RG_INTEGER:case L.RG:return 2;case L.RGB:case L.RGB_INTEGER:case L.RGB32F:return 3;case L.RGBA:case L.RGBA_INTEGER:case L.RGBA32F:return 4;default:return 0}}function ht(e,t,n,i){const{width:r,height:o}=i,{dimension:s,depth:a=0,mipLevel:l=0}=i,{x:c=0,y:u=0,z:d=0}=i,{glFormat:f,glType:_}=i,h=mt(i.glTarget,s,a),p=i.flipY?{[L.UNPACK_FLIP_Y_WEBGL]:!0}:{};ct(e,p,(()=>{switch(s){case"2d-array":case"3d":e.bindTexture(h,t),e.texSubImage3D(h,l,c,u,d,r,o,a,f,_,n),e.bindTexture(h,null);break;case"2d":case"cube":e.bindTexture(h,t),e.texSubImage2D(h,l,c,u,r,o,f,_,n),e.bindTexture(h,null);break;default:throw new Error(s)}}))}function pt(e,t,n){const{dimension:i,width:r,height:o,depth:s=0,mipLevel:a=0,byteOffset:l=0}=n,{x:c=0,y:u=0,z:d=0}=n,{glFormat:f,glType:_,compressed:h}=n,p=mt(n.glTarget,i,s);switch(i){case"2d-array":case"3d":h?e.compressedTexSubImage3D(p,a,c,u,d,r,o,s,f,t,l):e.texSubImage3D(p,a,c,u,d,r,o,s,f,_,t,l);break;case"2d":case"cube":h?e.compressedTexSubImage2D(p,a,c,u,r,o,f,t,l):e.texSubImage2D(p,a,c,u,r,o,f,_,t,l);break;default:throw new Error(i)}}function mt(e,t,n){return"cube"===t?L.TEXTURE_CUBE_MAP_POSITIVE_X+n:e}function gt(e,t){const{sourceX:n=0,sourceY:i=0,sourceAttachment:r=0}=t||{};let{target:o=null,sourceWidth:s,sourceHeight:a,sourceDepth:l,sourceFormat:c,sourceType:u}=t||{};const{framebuffer:d,deleteFramebuffer:f}=At(e),{gl:_,handle:h}=d;s||=d.width,a||=d.height;const p=d.colorAttachments[r]?.texture;if(!p)throw new Error(`Invalid framebuffer attachment ${r}`);l=p?.depth||1,c||=p?.glFormat||L.RGBA,u||=p?.glType||L.UNSIGNED_BYTE,o=function(e,t,n,i,r,o){if(e)return e;t||=L.UNSIGNED_BYTE;const s=function(e,t){const{clamped:n=!0}=t||{};switch(e){case L.FLOAT:return Float32Array;case L.UNSIGNED_SHORT:case L.UNSIGNED_SHORT_5_6_5:case L.UNSIGNED_SHORT_4_4_4_4:case L.UNSIGNED_SHORT_5_5_5_1:return Uint16Array;case L.UNSIGNED_INT:return Uint32Array;case L.UNSIGNED_BYTE:return n?Uint8ClampedArray:Uint8Array;case L.BYTE:return Int8Array;case L.SHORT:return Int16Array;case L.INT:return Int32Array;default:throw new Error("Failed to deduce typed array type from GL constant")}}(t,{clamped:!1}),a=_t(n);return new s(i*r*a)}(o,u,c,s,a),u=u||function(e){switch(ArrayBuffer.isView(e)?e.constructor:e){case Float32Array:return L.FLOAT;case Uint16Array:return L.UNSIGNED_SHORT;case Uint32Array:return L.UNSIGNED_INT;case Uint8Array:case Uint8ClampedArray:return L.UNSIGNED_BYTE;case Int8Array:return L.BYTE;case Int16Array:return L.SHORT;case Int32Array:return L.INT;default:throw new Error(ft)}}(o);const m=_.bindFramebuffer(L.FRAMEBUFFER,h);return _.readBuffer(_.COLOR_ATTACHMENT0+r),_.readPixels(n,i,s,a,c,u,o),_.readBuffer(_.COLOR_ATTACHMENT0),_.bindFramebuffer(L.FRAMEBUFFER,m||null),f&&d.destroy(),o}function Et(e,t){const{target:n,sourceX:i=0,sourceY:r=0,sourceFormat:o=L.RGBA,targetByteOffset:s=0}=t||{};let{sourceWidth:a,sourceHeight:l,sourceType:c}=t||{};const{framebuffer:u,deleteFramebuffer:d}=At(e);a=a||u.width,l=l||u.height;const f=u;c=c||L.UNSIGNED_BYTE;let _=n;if(!_){const e=s+a*l*_t(o)*function(e){switch(e){case L.UNSIGNED_BYTE:return 1;case L.UNSIGNED_SHORT_5_6_5:case L.UNSIGNED_SHORT_4_4_4_4:case L.UNSIGNED_SHORT_5_5_5_1:return 2;case L.FLOAT:return 4;default:return 0}}(c);_=f.device.createBuffer({byteLength:e})}const h=e.device.createCommandEncoder();return h.copyTextureToBuffer({sourceTexture:e,width:a,height:l,origin:[i,r],destinationBuffer:_,byteOffset:s}),h.destroy(),d&&u.destroy(),_}function At(e){return e instanceof Me?{framebuffer:e,deleteFramebuffer:!1}:{framebuffer:vt(e),deleteFramebuffer:!0}}function vt(e,t){const{device:n,width:i,height:r,id:o}=e;return n.createFramebuffer({...t,id:`framebuffer-for-${o}`,width:i,height:r,colorAttachments:[e]})}class Tt extends ye.g{sampler=void 0;view=void 0;mipmaps=!1;textureUnit=0;_video=null;constructor(e,t){t=ye.g._fixProps(t),super(e,{...ye.g.defaultProps,...t,data:void 0}),this.device=e,this.gl=this.device.gl,this.glTarget=function(e){switch(e){case"1d":case"cube-array":break;case"2d":return L.TEXTURE_2D;case"3d":return L.TEXTURE_3D;case"cube":return L.TEXTURE_CUBE_MAP;case"2d-array":return L.TEXTURE_2D_ARRAY}throw new Error(e)}(this.props.dimension);const n=be(this.props.format);if(this.glInternalFormat=n.internalFormat,this.glFormat=n.format,this.glType=n.type,this.compressed=n.compressed,"undefined"!=typeof HTMLVideoElement&&t.data instanceof HTMLVideoElement&&t.data.readyState<HTMLVideoElement.HAVE_METADATA){const e=t.data;this._video=null,e.addEventListener("loadeddata",(()=>this.initialize(t)))}this.initialize({...this.props,data:t.data})}initialize(e){void 0===e&&(e={}),this.handle=this.props.handle||this.gl.createTexture(),this.device.setSpectorMetadata(this.handle,{...this.props,data:typeof this.props.data});const t=e.data;let{width:n,height:i}=e;if(!n||!i){const e=ye.g.getTextureDataSize(t);n=e?.width||1,i=e?.height||1}if(this.width=n,this.height=i,this.depth=e.depth,this.setSampler(e.sampler),this.view=new dt(this.device,{...this.props,texture:this}),this.bind(),this.props.data||function(e,t,n){const{dimension:i,width:r,height:o,depth:s=0}=n,{glInternalFormat:a}=n,l=n.glTarget;switch(i){case"2d-array":case"3d":e.texStorage3D(l,t,a,r,o,s);break;default:e.texStorage2D(l,t,a,r,o)}}(this.gl,this.mipLevels,this),e.data)switch(e.dimension){case"1d":this.setTexture1DData(e.data);break;case"2d":this.setTexture2DData(e.data);break;case"3d":this.setTexture3DData(e.data);break;case"cube":this.setTextureCubeData(e.data);break;case"2d-array":this.setTextureArrayData(e.data);break;case"cube-array":this.setTextureCubeArrayData(e.data);break;default:throw new Error(e.dimension)}this.mipmaps=Boolean(e.mipmaps),this.mipmaps&&this.generateMipmap()}destroy(){this.handle&&(this.gl.deleteTexture(this.handle),this.removeStats(),this.trackDeallocatedMemory("Texture"),this.destroyed=!0)}toString(){return`Texture(${this.id},${this.width}x${this.height})`}createView(e){return new dt(this.device,{...e,texture:this})}setSampler(e){let t;void 0===e&&(e={}),e instanceof lt?(this.sampler=e,t=e.props):(this.sampler=new lt(this.device,e),t=e);const n=ot(t);this._setSamplerParameters(n)}update(){_.R.warn("Texture.update() not implemented")}generateMipmap(e){void 0===e&&(e={}),this.props.data&&(this.mipmaps=!0,this.gl.bindTexture(this.glTarget,this.handle),ct(this.gl,e,(()=>{this.gl.generateMipmap(this.glTarget)})),this.gl.bindTexture(this.glTarget,null))}copyExternalImage(e){const t=ye.g.getExternalImageSize(e.image),n={...ye.g.defaultCopyExternalImageOptions,...t,...e},{image:i,depth:r,mipLevel:o,x:s,y:a,z:l,flipY:c}=n;let{width:u,height:d}=n;const{dimension:f,glTarget:_,glFormat:h,glInternalFormat:p,glType:m}=this;if(u=Math.min(u,t.width-s),d=Math.min(d,t.height-a),e.sourceX||e.sourceY)throw new Error("WebGL does not support sourceX/sourceY)");return ht(this.device.gl,this.handle,i,{dimension:f,mipLevel:o,x:s,y:a,z:l,width:u,height:d,depth:r,glFormat:h,glInternalFormat:p,glType:m,glTarget:_,flipY:c}),{width:n.width,height:n.height}}setTexture1DData(e){throw new Error("setTexture1DData not supported in WebGL.")}setTexture2DData(e,t){void 0===t&&(t=0),this.bind();const n=function(e,t){let n;return n=ArrayBuffer.isView(e)?[{data:e,width:t.width,height:t.height}]:Array.isArray(e)?e:[e],n}(e,this);n.length>1&&!1!==this.props.mipmaps&&_.R.warn(`Texture ${this.id} mipmap and multiple LODs.`)();for(let i=0;i<n.length;i++){const e=n[i];this._setMipLevel(t,i,e)}this.unbind()}setTexture3DData(e){if("3d"!==this.props.dimension)throw new Error(this.id);ArrayBuffer.isView(e)&&(this.bind(),pt(this.device.gl,e,this),this.unbind())}setTextureCubeData(e,t){if(void 0===t&&(t=0),"cube"!==this.props.dimension)throw new Error(this.id);for(const n of ye.g.CubeFaces)this.setTextureCubeFaceData(e[n],n)}setTextureArrayData(e){if("2d-array"!==this.props.dimension)throw new Error(this.id);throw new Error("setTextureArrayData not implemented.")}setTextureCubeArrayData(e){throw new Error("setTextureCubeArrayData not supported in WebGL2.")}setTextureCubeFaceData(e,t,n){void 0===n&&(n=0),Array.isArray(e)&&e.length>1&&!1!==this.props.mipmaps&&_.R.warn(`${this.id} has mipmap and multiple LODs.`)();const i=ye.g.CubeFaces.indexOf(t);this.setTexture2DData(e,i)}setImageDataForFace(e){const{face:t,width:n,height:i,pixels:r,data:o,format:s=L.RGBA,type:a=L.UNSIGNED_BYTE}=e,{gl:l}=this,c=r||o;this.bind(),c instanceof Promise?c.then((n=>this.setImageDataForFace(Object.assign({},e,{face:t,data:n,pixels:n})))):this.width||this.height?l.texImage2D(t,0,s,n,i,0,s,a,c):l.texImage2D(t,0,s,s,a,c)}_getImageDataMap(e){for(let t=0;t<ye.g.CubeFaces.length;++t){const n=ye.g.CubeFaces[t];e[n]&&(e[L.TEXTURE_CUBE_MAP_POSITIVE_X+t]=e[n],delete e[n])}return e}_setSamplerParameters(e){_.R.log(1,`${this.id} sampler parameters`,this.device.getGLKeys(e))(),this.gl.bindTexture(this.glTarget,this.handle);for(const[t,n]of Object.entries(e)){const e=Number(t),i=n;switch(e){case L.TEXTURE_MIN_LOD:case L.TEXTURE_MAX_LOD:this.gl.texParameterf(this.glTarget,e,i);break;case L.TEXTURE_MIN_FILTER:case L.TEXTURE_WRAP_S:case L.TEXTURE_WRAP_T:this.gl.texParameteri(this.glTarget,e,i);break;case L.TEXTURE_MAX_ANISOTROPY_EXT:this.device.features.has("texture-filterable-anisotropic-webgl")&&this.gl.texParameteri(this.glTarget,e,i);break;default:this.gl.texParameteri(this.glTarget,e,i)}}this.gl.bindTexture(this.glTarget,null)}_setMipLevel(e,t,n,i){if(void 0===i&&(i=this.glTarget),ye.g.isExternalImage(n))ht(this.device.gl,this.handle,n,{...this,depth:e,mipLevel:t,glTarget:i,flipY:this.props.flipY});else{if(!ye.g.isTextureLevelData(n))throw new Error("Texture: invalid image data");pt(this.device.gl,n.data,{...this,depth:e,mipLevel:t,glTarget:i})}}getActiveUnit(){return this.gl.getParameter(L.ACTIVE_TEXTURE)-L.TEXTURE0}bind(e){const{gl:t}=this;return void 0!==e&&(this.textureUnit=e,t.activeTexture(t.TEXTURE0+e)),t.bindTexture(this.glTarget,this.handle),e}unbind(e){const{gl:t}=this;return void 0!==e&&(this.textureUnit=e,t.activeTexture(t.TEXTURE0+e)),t.bindTexture(this.glTarget,null),e}}class Rt extends Fe.F{static defaultProps=(()=>({...Fe.F.defaultProps,framebuffer:null,parameters:void 0,clearColor:!1,clearColors:void 0,clearDepth:!0,clearStencil:void 0,depthReadOnly:!1,stencilReadOnly:!1,discard:!1,occlusionQuerySet:void 0,timestampQuerySet:void 0,beginTimestampIndex:void 0,endTimestampIndex:void 0}))();get[Symbol.toStringTag](){return"RenderPass"}constructor(e,t){super(e,t,Rt.defaultProps)}}const bt=[1,2,4,8];class St extends Rt{constructor(e,t){let n;if(super(e,t),this.device=e,!t?.parameters?.viewport)if(t?.framebuffer){const{width:e,height:i}=t.framebuffer;n=[0,0,e,i]}else{const[t,i]=e.getCanvasContext().getDrawingBufferSize();n=[0,0,t,i]}if(this.device.pushState(),this.setParameters({viewport:n,...this.props.parameters}),this.props.framebuffer){const e=this.props.framebuffer.colorAttachments.map(((e,t)=>L.COLOR_ATTACHMENT0+t));this.device.gl.drawBuffers(e)}else this.device.gl.drawBuffers([L.BACK]);this.clear()}end(){this.device.popState()}pushDebugGroup(e){}popDebugGroup(){}insertDebugMarker(e){}setParameters(e){void 0===e&&(e={});const t={...this.glParameters};t.framebuffer=this.props.framebuffer||null,this.props.depthReadOnly&&(t.depthMask=!this.props.depthReadOnly),t.stencilMask=this.props.stencilReadOnly?0:1,t[L.RASTERIZER_DISCARD]=this.props.discard,e.viewport&&(e.viewport.length>=6?(t.viewport=e.viewport.slice(0,4),t.depthRange=[e.viewport[4],e.viewport[5]]):t.viewport=e.viewport),e.scissorRect&&(t.scissorTest=!0,t.scissor=e.scissorRect),e.blendConstant&&(t.blendColor=e.blendConstant),e.stencilReference&&(console.warn("RenderPassParameters.stencilReference not yet implemented in WebGL"),e[L.STENCIL_REF]=e.stencilReference),e.colorMask&&(t.colorMask=bt.map((t=>Boolean(t&e.colorMask)))),this.glParameters=t,Y(this.device.gl,t)}beginOcclusionQuery(e){const t=this.props.occlusionQuerySet;t?.beginOcclusionQuery()}endOcclusionQuery(){const e=this.props.occlusionQuerySet;e?.endOcclusionQuery()}clear(){const e=[0,0,0,1],t={...this.glParameters};let n=0;this.props.clearColors&&this.props.clearColors.forEach(((t,n)=>{t&&(t=!0===t?e:t,this.clearColorBuffer(n,t))})),!1!==this.props.clearColor&&void 0===this.props.clearColors&&(n|=L.COLOR_BUFFER_BIT,t.clearColor=this.props.clearColor),!1!==this.props.clearDepth&&(n|=L.DEPTH_BUFFER_BIT,t.clearDepth=!0===this.props.clearDepth?1:this.props.clearDepth),!1!==this.props.clearStencil&&(n|=L.STENCIL_BUFFER_BIT,t.clearStencil=!0===this.props.clearStencil?0:this.props.clearStencil),0!==n&&ct(this.device.gl,t,(()=>{this.device.gl.clear(n)}))}clearColorBuffer(e,t){void 0===e&&(e=0),void 0===t&&(t=[0,0,0,0]),ct(this.device.gl,{framebuffer:this.props.framebuffer},(()=>{switch(t.constructor){case Int8Array:case Int16Array:case Int32Array:this.device.gl.clearBufferiv(L.COLOR,e,t);break;case Uint8Array:case Uint8ClampedArray:case Uint16Array:case Uint32Array:this.device.gl.clearBufferuiv(L.COLOR,e,t);break;case Float32Array:default:this.device.gl.clearBufferfv(L.COLOR,e,t)}}))}}var Ct=n(9853);const It=[L.SAMPLER_2D,L.SAMPLER_CUBE,L.SAMPLER_3D,L.SAMPLER_2D_SHADOW,L.SAMPLER_2D_ARRAY,L.SAMPLER_2D_ARRAY_SHADOW,L.SAMPLER_CUBE_SHADOW,L.INT_SAMPLER_2D,L.INT_SAMPLER_3D,L.INT_SAMPLER_CUBE,L.INT_SAMPLER_2D_ARRAY,L.UNSIGNED_INT_SAMPLER_2D,L.UNSIGNED_INT_SAMPLER_3D,L.UNSIGNED_INT_SAMPLER_CUBE,L.UNSIGNED_INT_SAMPLER_2D_ARRAY],Pt={[L.FLOAT]:[L.FLOAT,1,"float","f32","float32"],[L.FLOAT_VEC2]:[L.FLOAT,2,"vec2","vec2<f32>","float32x2"],[L.FLOAT_VEC3]:[L.FLOAT,3,"vec3","vec3<f32>","float32x3"],[L.FLOAT_VEC4]:[L.FLOAT,4,"vec4","vec4<f32>","float32x4"],[L.INT]:[L.INT,1,"int","i32","sint32"],[L.INT_VEC2]:[L.INT,2,"ivec2","vec2<i32>","sint32x2"],[L.INT_VEC3]:[L.INT,3,"ivec3","vec3<i32>","sint32x3"],[L.INT_VEC4]:[L.INT,4,"ivec4","vec4<i32>","sint32x4"],[L.UNSIGNED_INT]:[L.UNSIGNED_INT,1,"uint","u32","uint32"],[L.UNSIGNED_INT_VEC2]:[L.UNSIGNED_INT,2,"uvec2","vec2<u32>","uint32x2"],[L.UNSIGNED_INT_VEC3]:[L.UNSIGNED_INT,3,"uvec3","vec3<u32>","uint32x3"],[L.UNSIGNED_INT_VEC4]:[L.UNSIGNED_INT,4,"uvec4","vec4<u32>","uint32x4"],[L.BOOL]:[L.FLOAT,1,"bool","f32","float32"],[L.BOOL_VEC2]:[L.FLOAT,2,"bvec2","vec2<f32>","float32x2"],[L.BOOL_VEC3]:[L.FLOAT,3,"bvec3","vec3<f32>","float32x3"],[L.BOOL_VEC4]:[L.FLOAT,4,"bvec4","vec4<f32>","float32x4"],[L.FLOAT_MAT2]:[L.FLOAT,8,"mat2","mat2x2<f32>"],[L.FLOAT_MAT2x3]:[L.FLOAT,8,"mat2x3","mat2x3<f32>"],[L.FLOAT_MAT2x4]:[L.FLOAT,8,"mat2x4","mat2x4<f32>"],[L.FLOAT_MAT3x2]:[L.FLOAT,12,"mat3x2","mat3x2<f32>"],[L.FLOAT_MAT3]:[L.FLOAT,12,"mat3","mat3x3<f32>"],[L.FLOAT_MAT3x4]:[L.FLOAT,12,"mat3x4","mat3x4<f32>"],[L.FLOAT_MAT4x2]:[L.FLOAT,16,"mat4x2","mat4x2<f32>"],[L.FLOAT_MAT4x3]:[L.FLOAT,16,"mat4x3","mat4x3<f32>"],[L.FLOAT_MAT4]:[L.FLOAT,16,"mat4","mat4x4<f32>"]};function xt(e){const t=Pt[e];if(!t)throw new Error("uniform");const[n,i,,r]=t;return{format:r,components:i,glType:n}}function Nt(e){const t=Pt[e];if(!t)throw new Error("attribute");const[,n,,i,r]=t;return{attributeType:i,vertexFormat:r,components:n}}function Lt(e,t){const n={attributes:[],bindings:[]};n.attributes=function(e,t){const n=[],i=e.getProgramParameter(t,e.ACTIVE_ATTRIBUTES);for(let r=0;r<i;r++){const i=e.getActiveAttrib(t,r);if(!i)throw new Error("activeInfo");const{name:o,type:s}=i,a=e.getAttribLocation(t,o);if(a>=0){const{attributeType:e}=Nt(s),t=/instance/i.test(o)?"instance":"vertex";n.push({name:o,location:a,stepMode:t,type:e})}}return n.sort(((e,t)=>e.location-t.location)),n}(e,t);const i=function(e,t){const n=(n,i)=>e.getActiveUniformBlockParameter(t,n,i),i=[],r=e.getProgramParameter(t,L.ACTIVE_UNIFORM_BLOCKS);for(let o=0;o<r;o++){const r={name:e.getActiveUniformBlockName(t,o)||"",location:n(o,L.UNIFORM_BLOCK_BINDING),byteLength:n(o,L.UNIFORM_BLOCK_DATA_SIZE),vertex:n(o,L.UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER),fragment:n(o,L.UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER),uniformCount:n(o,L.UNIFORM_BLOCK_ACTIVE_UNIFORMS),uniforms:[]},s=n(o,L.UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES)||[],a=e.getActiveUniforms(t,s,L.UNIFORM_TYPE),l=e.getActiveUniforms(t,s,L.UNIFORM_SIZE),c=e.getActiveUniforms(t,s,L.UNIFORM_OFFSET),u=e.getActiveUniforms(t,s,L.UNIFORM_ARRAY_STRIDE);for(let n=0;n<r.uniformCount;++n){const i=e.getActiveUniform(t,s[n]);if(!i)throw new Error("activeInfo");r.uniforms.push({name:i.name,format:xt(a[n]).format,type:a[n],arrayLength:l[n],byteOffset:c[n],byteStride:u[n]})}i.push(r)}return i.sort(((e,t)=>e.location-t.location)),i}(e,t);for(const l of i){const e=l.uniforms.map((e=>({name:e.name,format:e.format,byteOffset:e.byteOffset,byteStride:e.byteStride,arrayLength:e.arrayLength})));n.bindings.push({type:"uniform",name:l.name,location:l.location,visibility:(l.vertex?1:0)&(l.fragment?2:0),minBindingSize:l.byteLength,uniforms:e})}const r=function(e,t){const n=[],i=e.getProgramParameter(t,L.ACTIVE_UNIFORMS);for(let r=0;r<i;r++){const i=e.getActiveUniform(t,r);if(!i)throw new Error("activeInfo");const{name:o,size:s,type:a}=i,{name:l,isArray:c}=Mt(o);let u=e.getUniformLocation(t,l);const d={location:u,name:l,size:s,type:a,isArray:c};if(n.push(d),d.size>1)for(let r=0;r<d.size;r++){const i=`${l}[${r}]`;u=e.getUniformLocation(t,i);const o={...d,name:i,location:u};n.push(o)}}return n}(e,t);let o=0;for(const l of r)if(s=l.type,It.includes(s)){const{viewDimension:e,sampleType:t}=yt(l.type);n.bindings.push({type:"texture",name:l.name,location:o,viewDimension:e,sampleType:t}),l.textureUnit=o,o+=1}var s;r.length&&(n.uniforms=r);const a=function(e,t){const n=[],i=e.getProgramParameter(t,L.TRANSFORM_FEEDBACK_VARYINGS);for(let r=0;r<i;r++){const i=e.getTransformFeedbackVarying(t,r);if(!i)throw new Error("activeInfo");const{name:o,type:s,size:a}=i,{glType:l,components:c}=xt(s),u={location:r,name:o,type:l,size:a*c};n.push(u)}return n.sort(((e,t)=>e.location-t.location)),n}(e,t);return a?.length&&(n.varyings=a),n}const Ft={[L.SAMPLER_2D]:["2d","float"],[L.SAMPLER_CUBE]:["cube","float"],[L.SAMPLER_3D]:["3d","float"],[L.SAMPLER_2D_SHADOW]:["3d","depth"],[L.SAMPLER_2D_ARRAY]:["2d-array","float"],[L.SAMPLER_2D_ARRAY_SHADOW]:["2d-array","depth"],[L.SAMPLER_CUBE_SHADOW]:["cube","float"],[L.INT_SAMPLER_2D]:["2d","sint"],[L.INT_SAMPLER_3D]:["3d","sint"],[L.INT_SAMPLER_CUBE]:["cube","sint"],[L.INT_SAMPLER_2D_ARRAY]:["2d-array","uint"],[L.UNSIGNED_INT_SAMPLER_2D]:["2d","uint"],[L.UNSIGNED_INT_SAMPLER_3D]:["3d","uint"],[L.UNSIGNED_INT_SAMPLER_CUBE]:["cube","uint"],[L.UNSIGNED_INT_SAMPLER_2D_ARRAY]:["2d-array","uint"]};function yt(e){const t=Ft[e];if(!t)throw new Error("sampler");const[n,i]=t;return{viewDimension:n,sampleType:i}}function Mt(e){if("]"!==e[e.length-1])return{name:e,length:1,isArray:!1};const t=/([^[]*)(\[[0-9]+\])?/.exec(e);if(!t||t.length<2)throw new Error(`Failed to parse GLSL uniform name ${e}`);return{name:t[1],length:t[2]?1:0,isArray:Boolean(t[2])}}function Ot(e,t,n,i){const r=e;let o=i;!0===o&&(o=1),!1===o&&(o=0);const s="number"==typeof o?[o]:o;switch(n){case L.SAMPLER_2D:case L.SAMPLER_CUBE:case L.SAMPLER_3D:case L.SAMPLER_2D_SHADOW:case L.SAMPLER_2D_ARRAY:case L.SAMPLER_2D_ARRAY_SHADOW:case L.SAMPLER_CUBE_SHADOW:case L.INT_SAMPLER_2D:case L.INT_SAMPLER_3D:case L.INT_SAMPLER_CUBE:case L.INT_SAMPLER_2D_ARRAY:case L.UNSIGNED_INT_SAMPLER_2D:case L.UNSIGNED_INT_SAMPLER_3D:case L.UNSIGNED_INT_SAMPLER_CUBE:case L.UNSIGNED_INT_SAMPLER_2D_ARRAY:if("number"!=typeof i)throw new Error("samplers must be set to integers");return e.uniform1i(t,i);case L.FLOAT:return e.uniform1fv(t,s);case L.FLOAT_VEC2:return e.uniform2fv(t,s);case L.FLOAT_VEC3:return e.uniform3fv(t,s);case L.FLOAT_VEC4:return e.uniform4fv(t,s);case L.INT:return e.uniform1iv(t,s);case L.INT_VEC2:return e.uniform2iv(t,s);case L.INT_VEC3:return e.uniform3iv(t,s);case L.INT_VEC4:return e.uniform4iv(t,s);case L.BOOL:return e.uniform1iv(t,s);case L.BOOL_VEC2:return e.uniform2iv(t,s);case L.BOOL_VEC3:return e.uniform3iv(t,s);case L.BOOL_VEC4:return e.uniform4iv(t,s);case L.UNSIGNED_INT:return r.uniform1uiv(t,s,1);case L.UNSIGNED_INT_VEC2:return r.uniform2uiv(t,s,2);case L.UNSIGNED_INT_VEC3:return r.uniform3uiv(t,s,3);case L.UNSIGNED_INT_VEC4:return r.uniform4uiv(t,s,4);case L.FLOAT_MAT2:return e.uniformMatrix2fv(t,!1,s);case L.FLOAT_MAT3:return e.uniformMatrix3fv(t,!1,s);case L.FLOAT_MAT4:return e.uniformMatrix4fv(t,!1,s);case L.FLOAT_MAT2x3:return r.uniformMatrix2x3fv(t,!1,s);case L.FLOAT_MAT2x4:return r.uniformMatrix2x4fv(t,!1,s);case L.FLOAT_MAT3x2:return r.uniformMatrix3x2fv(t,!1,s);case L.FLOAT_MAT3x4:return r.uniformMatrix3x4fv(t,!1,s);case L.FLOAT_MAT4x2:return r.uniformMatrix4x2fv(t,!1,s);case L.FLOAT_MAT4x3:return r.uniformMatrix4x3fv(t,!1,s)}throw new Error("Illegal uniform")}var Bt=n(6282);function Dt(e){const t={bindings:{},uniforms:{}};return Object.keys(e).forEach((n=>{const i=e[n];var r;r=i,null!==(0,Bt.H9)(r)||"number"==typeof r||"boolean"==typeof r?t.uniforms[n]=i:t.bindings[n]=i})),t}class wt extends Ct.r{uniforms={};bindings={};varyings=null;_uniformCount=0;_uniformSetters={};constructor(e,t){super(e,t),this.device=e,this.handle=this.props.handle||this.device.gl.createProgram(),this.device.setSpectorMetadata(this.handle,{id:this.props.id}),this.vs=t.vs,this.fs=t.fs;const{varyings:n,bufferMode:i=L.SEPARATE_ATTRIBS}=t;n&&n.length>0&&(this.varyings=n,this.device.gl.transformFeedbackVaryings(this.handle,n,i)),this._linkShaders(),_.R.time(1,`RenderPipeline ${this.id} - shaderLayout introspection`)(),this.introspectedLayout=Lt(this.device.gl,this.handle),_.R.timeEnd(1,`RenderPipeline ${this.id} - shaderLayout introspection`)(),this.shaderLayout=function(e,t){const n={...e,attributes:e.attributes.map((e=>({...e})))};for(const i of t?.attributes||[]){const e=n.attributes.find((e=>e.name===i.name));e?(e.type=i.type||e.type,e.stepMode=i.stepMode||e.stepMode):_.R.warn(`shader layout attribute ${i.name} not present in shader`)}return n}(this.introspectedLayout,t.shaderLayout)}destroy(){this.handle&&(this.device.gl.deleteProgram(this.handle),this.destroyed=!0)}setBindings(e,t){for(const[n,i]of Object.entries(e)){const e=this.shaderLayout.bindings.find((e=>e.name===n))||this.shaderLayout.bindings.find((e=>e.name===`${n}Uniforms`));if(e){switch(i||_.R.warn(`Unsetting binding "${n}" in render pipeline "${this.id}"`)(),e.type){case"uniform":if(!(i instanceof Ke||i.buffer instanceof Ke))throw new Error("buffer value");break;case"texture":if(!(i instanceof dt||i instanceof Tt||i instanceof Oe))throw new Error("texture value");break;case"sampler":_.R.warn(`Ignoring sampler ${n}`)();break;default:throw new Error(e.type)}this.bindings[n]=i}else{const e=this.shaderLayout.bindings.map((e=>`"${e.name}"`)).join(", ");t?.disableWarnings||_.R.warn(`No binding "${n}" in render pipeline "${this.id}", expected one of ${e}`,i)()}}}draw(e){const{renderPass:t,parameters:n=this.props.parameters,topology:i=this.props.topology,vertexArray:r,vertexCount:o,instanceCount:s,isInstanced:a=!1,firstVertex:l=0,transformFeedback:c}=e,u=function(e){switch(e){case"point-list":return L.POINTS;case"line-list":return L.LINES;case"line-strip":return L.LINE_STRIP;case"triangle-list":return L.TRIANGLES;case"triangle-strip":return L.TRIANGLE_STRIP;default:throw new Error(e)}}(i),d=Boolean(r.indexBuffer),f=r.indexBuffer?.glIndexType;if("success"!==this.linkStatus)return _.R.info(2,`RenderPipeline:${this.id}.draw() aborted - waiting for shader linking`)(),!1;if(!this._areTexturesRenderable())return _.R.info(2,`RenderPipeline:${this.id}.draw() aborted - textures not yet loaded`)(),!1;this.device.gl.useProgram(this.handle),r.bindBeforeRender(t),c&&c.begin(this.props.topology),this._applyBindings(),this._applyUniforms();const h=t;return function(e,t,n,i){if(rt(t))return i(e);const r=e;r.pushState();try{return Ze(e,t),Y(r.gl,n),i(e)}finally{r.popState()}}(this.device,n,h.glParameters,(()=>{d&&a?this.device.gl.drawElementsInstanced(u,o||0,f,l,s||0):d?this.device.gl.drawElements(u,o||0,f,l):a?this.device.gl.drawArraysInstanced(u,l,o||0,s||0):this.device.gl.drawArrays(u,l,o||0),c&&c.end()})),r.unbindAfterRender(t),!0}setUniformsWebGL(e){const{bindings:t}=Dt(e);Object.keys(t).forEach((e=>{_.R.warn(`Unsupported value "${JSON.stringify(t[e])}" used in setUniforms() for key ${e}. Use setBindings() instead?`)()})),Object.assign(this.uniforms,e)}async _linkShaders(){const{gl:e}=this.device;if(e.attachShader(this.handle,this.vs.handle),e.attachShader(this.handle,this.fs.handle),_.R.time(4,`linkProgram for ${this.id}`)(),e.linkProgram(this.handle),_.R.timeEnd(4,`linkProgram for ${this.id}`)(),_.R.level,!this.device.features.has("compilation-status-async-webgl")){const e=this._getLinkStatus();return void this._reportLinkStatus(e)}_.R.once(1,"RenderPipeline linking is asynchronous")(),await this._waitForLinkComplete(),_.R.info(2,`RenderPipeline ${this.id} - async linking complete: ${this.linkStatus}`)();const t=this._getLinkStatus();this._reportLinkStatus(t)}async _reportLinkStatus(e){if("success"!==e){switch(this.vs.compilationStatus){case"error":throw this.vs.debugShader(),new Error(`Error during compilation of shader ${this.vs.id}`);case"pending":this.vs.asyncCompilationStatus.then((()=>this.vs.debugShader()))}switch(this.fs?.compilationStatus){case"error":throw this.fs.debugShader(),new Error(`Error during compilation of shader ${this.fs.id}`);case"pending":this.fs.asyncCompilationStatus.then((()=>this.fs.debugShader()))}const t=this.device.gl.getProgramInfoLog(this.handle);throw new Error(`Error during ${e}: ${t}`)}}_getLinkStatus(){const{gl:e}=this.device;if(!e.getProgramParameter(this.handle,e.LINK_STATUS))return this.linkStatus="error","linking";e.validateProgram(this.handle);return e.getProgramParameter(this.handle,e.VALIDATE_STATUS)?(this.linkStatus="success","success"):(this.linkStatus="error","validation")}async _waitForLinkComplete(){const e=async e=>await new Promise((t=>setTimeout(t,e)));if(!this.device.features.has("compilation-status-async-webgl"))return void await e(10);const{gl:t}=this.device;for(;;){if(t.getProgramParameter(this.handle,L.COMPLETION_STATUS_KHR))return;await e(10)}}_areTexturesRenderable(){let e=!0;for(const t of this.shaderLayout.bindings)this.bindings[t.name]||this.bindings[t.name.replace(/Uniforms$/,"")]||(_.R.warn(`Binding ${t.name} not found in ${this.id}`)(),e=!1);for(const[,t]of Object.entries(this.bindings))t instanceof Tt&&t.update();return e}_applyBindings(){if("success"!==this.linkStatus)return;const{gl:e}=this.device;e.useProgram(this.handle);let t=0,n=0;for(const i of this.shaderLayout.bindings){const r=this.bindings[i.name]||this.bindings[i.name.replace(/Uniforms$/,"")];if(!r)throw new Error(`No value for binding ${i.name} in ${this.id}`);switch(i.type){case"uniform":const{name:o}=i,s=e.getUniformBlockIndex(this.handle,o);if(s===L.INVALID_INDEX)throw new Error(`Invalid uniform block name ${o}`);e.uniformBlockBinding(this.handle,n,s),r instanceof Ke?e.bindBufferBase(L.UNIFORM_BUFFER,n,r.handle):e.bindBufferRange(L.UNIFORM_BUFFER,n,r.buffer.handle,r.offset||0,r.size||r.buffer.byteLength-r.offset),n+=1;break;case"texture":if(!(r instanceof dt||r instanceof Tt||r instanceof Oe))throw new Error("texture");let a;if(r instanceof dt)a=r.texture;else if(r instanceof Tt)a=r;else{if(!(r instanceof Oe&&r.colorAttachments[0]instanceof dt))throw new Error("No texture");_.R.warn("Passing framebuffer in texture binding may be deprecated. Use fbo.colorAttachments[0] instead")(),a=r.colorAttachments[0].texture}e.activeTexture(L.TEXTURE0+t),e.bindTexture(a.glTarget,a.handle),t+=1;break;case"sampler":break;case"storage":case"read-only-storage":throw new Error(`binding type '${i.type}' not supported in WebGL`)}}}_applyUniforms(){for(const e of this.shaderLayout.uniforms||[]){const{name:t,location:n,type:i,textureUnit:r}=e,o=this.uniforms[t]??r;void 0!==o&&Ot(this.device.gl,n,i,o)}}}class Ut extends Fe.F{static defaultProps=(()=>({...Fe.F.defaultProps,measureExecutionTime:void 0}))();get[Symbol.toStringTag](){return"CommandEncoder"}constructor(e,t){super(e,t,Ut.defaultProps)}}class Gt extends Fe.F{static defaultProps={...Fe.F.defaultProps};get[Symbol.toStringTag](){return"CommandBuffer"}constructor(e,t){super(e,t,Gt.defaultProps)}}class Ht extends Gt{commands=[];constructor(e){super(e,{}),this.device=e}submitCommands(e){void 0===e&&(e=this.commands);for(const t of e)switch(t.name){case"copy-buffer-to-buffer":Xt(this.device,t.options);break;case"copy-buffer-to-texture":Vt(this.device,t.options);break;case"copy-texture-to-buffer":kt(this.device,t.options);break;case"copy-texture-to-texture":Wt(this.device,t.options);break;default:throw new Error(t.name)}}}function Xt(e,t){const n=t.sourceBuffer,i=t.destinationBuffer;e.gl.bindBuffer(L.COPY_READ_BUFFER,n.handle),e.gl.bindBuffer(L.COPY_WRITE_BUFFER,i.handle),e.gl.copyBufferSubData(L.COPY_READ_BUFFER,L.COPY_WRITE_BUFFER,t.sourceOffset??0,t.destinationOffset??0,t.size),e.gl.bindBuffer(L.COPY_READ_BUFFER,null),e.gl.bindBuffer(L.COPY_WRITE_BUFFER,null)}function Vt(e,t){throw new Error("Not implemented")}function kt(e,t){const{sourceTexture:n,mipLevel:i=0,aspect:r="all",width:o=t.sourceTexture.width,height:s=t.sourceTexture.height,depthOrArrayLayers:a=0,origin:l=[0,0],destinationBuffer:c,byteOffset:u=0,bytesPerRow:d,rowsPerImage:f}=t;if("all"!==r)throw new Error("aspect not supported in WebGL");if(0!==i||0!==a||d||f)throw new Error("not implemented");const{framebuffer:_,destroyFramebuffer:h}=Yt(n);let p;try{const t=c,n=o||_.width,i=s||_.height,r=be(_.colorAttachments[0].texture.props.format),a=r.format,d=r.type;e.gl.bindBuffer(L.PIXEL_PACK_BUFFER,t.handle),p=e.gl.bindFramebuffer(L.FRAMEBUFFER,_.handle),e.gl.readPixels(l[0],l[1],n,i,a,d,u)}finally{e.gl.bindBuffer(L.PIXEL_PACK_BUFFER,null),void 0!==p&&e.gl.bindFramebuffer(L.FRAMEBUFFER,p),h&&_.destroy()}}function Wt(e,t){const{sourceTexture:n,destinationMipLevel:i=0,origin:r=[0,0],destinationOrigin:o=[0,0],destinationTexture:s}=t;let{width:a=t.destinationTexture.width,height:l=t.destinationTexture.height}=t;const{framebuffer:c,destroyFramebuffer:u}=Yt(n),[d,f]=r,[_,h,p]=o,m=e.gl.bindFramebuffer(L.FRAMEBUFFER,c.handle);let g,E=null;if(!(s instanceof Tt))throw new Error("invalid destination");switch(E=s,a=Number.isFinite(a)?a:E.width,l=Number.isFinite(l)?l:E.height,E.bind(0),g=E.glTarget,g){case L.TEXTURE_2D:case L.TEXTURE_CUBE_MAP:e.gl.copyTexSubImage2D(g,i,_,h,d,f,a,l);break;case L.TEXTURE_2D_ARRAY:case L.TEXTURE_3D:e.gl.copyTexSubImage3D(g,i,_,h,p,d,f,a,l)}E&&E.unbind(),e.gl.bindFramebuffer(L.FRAMEBUFFER,m),u&&c.destroy()}function Yt(e){if(e instanceof ye.g){const{width:t,height:n,id:i}=e;return{framebuffer:e.device.createFramebuffer({id:`framebuffer-for-${i}`,width:t,height:n,colorAttachments:[e]}),destroyFramebuffer:!0}}return{framebuffer:e,destroyFramebuffer:!1}}class zt extends Ut{constructor(e,t){super(e,t),this.device=e,this.commandBuffer=new Ht(e)}destroy(){}finish(){this.commandBuffer.submitCommands()}copyBufferToBuffer(e){this.commandBuffer.commands.push({name:"copy-buffer-to-buffer",options:e})}copyBufferToTexture(e){this.commandBuffer.commands.push({name:"copy-buffer-to-texture",options:e})}copyTextureToBuffer(e){this.commandBuffer.commands.push({name:"copy-texture-to-buffer",options:e})}copyTextureToTexture(e){this.commandBuffer.commands.push({name:"copy-texture-to-texture",options:e})}pushDebugGroup(e){}popDebugGroup(){}insertDebugMarker(e){}resolveQuerySet(e,t,n){}}var Kt=n(9647);class jt extends Fe.F{static defaultProps={...Fe.F.defaultProps,renderPipeline:null};get[Symbol.toStringTag](){return"VertexArray"}indexBuffer=null;constructor(e,t){super(e,t,jt.defaultProps),this.maxVertexAttributes=e.limits.maxVertexAttributes,this.attributes=new Array(this.maxVertexAttributes).fill(null);const{shaderLayout:n,bufferLayout:i}=t.renderPipeline||{};if(!n||!i)throw new Error("VertexArray");this.attributeInfos=(0,Kt.M)(n,i,this.maxVertexAttributes)}setConstantWebGL(e,t){throw new Error("constant attributes not supported")}}var Qt=n(8397),$t=n(7651);class qt extends jt{get[Symbol.toStringTag](){return"VertexArray"}buffer=null;bufferValue=null;static isConstantAttributeZeroSupported(e){return"Chrome"===(0,$t.X)()}constructor(e,t){super(e,t),this.device=e,this.handle=this.device.gl.createVertexArray()}destroy(){super.destroy(),this.buffer&&this.buffer?.destroy(),this.handle&&(this.device.gl.deleteVertexArray(this.handle),this.handle=void 0)}setIndexBuffer(e){const t=e;if(t&&t.glTarget!==L.ELEMENT_ARRAY_BUFFER)throw new Error("Use .setBuffer()");this.device.gl.bindVertexArray(this.handle),this.device.gl.bindBuffer(L.ELEMENT_ARRAY_BUFFER,t?t.handle:null),this.indexBuffer=t,this.device.gl.bindVertexArray(null)}setBuffer(e,t){const n=t;if(n.glTarget===L.ELEMENT_ARRAY_BUFFER)throw new Error("Use .setIndexBuffer()");const{size:i,type:r,stride:o,offset:s,normalized:a,integer:l,divisor:c}=this._getAccessor(e);this.device.gl.bindVertexArray(this.handle),this.device.gl.bindBuffer(L.ARRAY_BUFFER,n.handle),l?this.device.gl.vertexAttribIPointer(e,i,r,o,s):this.device.gl.vertexAttribPointer(e,i,r,a,o,s),this.device.gl.bindBuffer(L.ARRAY_BUFFER,null),this.device.gl.enableVertexAttribArray(e),this.device.gl.vertexAttribDivisor(e,c||0),this.attributes[e]=n,this.device.gl.bindVertexArray(null)}setConstantWebGL(e,t){this._enable(e,!1),this.attributes[e]=t}bindBeforeRender(){this.device.gl.bindVertexArray(this.handle),this._applyConstantAttributes()}unbindAfterRender(){this.device.gl.bindVertexArray(null)}_applyConstantAttributes(){for(let e=0;e<this.maxVertexAttributes;++e){const t=this.attributes[e];ArrayBuffer.isView(t)&&this.device.setConstantAttributeWebGL(e,t)}}_getAccessor(e){const t=this.attributeInfos[e];if(!t)throw new Error(`Unknown attribute location ${e}`);const n=ee(t.bufferDataType);return{size:t.bufferComponents,type:n,stride:t.byteStride,offset:t.byteOffset,normalized:t.normalized,integer:t.integer,divisor:"instance"===t.stepMode?1:0}}_enable(e,t){void 0===t&&(t=!0);const n=qt.isConstantAttributeZeroSupported(this.device);(t||(n||0!==e))&&(e=Number(e),this.device.gl.bindVertexArray(this.handle),t?this.device.gl.enableVertexAttribArray(e):this.device.gl.disableVertexAttribArray(e),this.device.gl.bindVertexArray(null))}getConstantBuffer(e,t){const n=function(e){if(Array.isArray(e))return new Float32Array(e);return e}(t),i=n.byteLength*e,r=n.length*e;if(this.buffer&&i!==this.buffer.byteLength)throw new Error(`Buffer size is immutable, byte length ${i} !== ${this.buffer.byteLength}.`);let o=!this.buffer;if(this.buffer=this.buffer||this.device.createBuffer({byteLength:i}),o=o||!function(e,t){if(!e||!t||e.length!==t.length||e.constructor!==t.constructor)return!1;for(let n=0;n<e.length;++n)if(e[n]!==t[n])return!1;return!0}(n,this.bufferValue),o){const e=(0,Qt.X)(t.constructor,r);!function(e){const{target:t,source:n,start:i=0,count:r=1}=e,o=n.length,s=r*o;let a=0;for(let l=i;a<o;a++)t[l++]=n[a];for(;a<s;)a<s-a?(t.copyWithin(i+a,i,i+a),a*=2):(t.copyWithin(i+a,i,i+s-a),a=s);e.target}({target:e,source:n,start:0,count:r}),this.buffer.write(e),this.bufferValue=t}return this.buffer}}class Zt extends Fe.F{static defaultProps=(()=>({...Fe.F.defaultProps,layout:void 0,buffers:{}}))();get[Symbol.toStringTag](){return"TransformFeedback"}constructor(e,t){super(e,t,Zt.defaultProps)}}class Jt extends Zt{buffers={};unusedBuffers={};bindOnUse=!0;_bound=!1;constructor(e,t){super(e,t),this.device=e,this.gl=e.gl,this.handle=this.props.handle||this.gl.createTransformFeedback(),this.layout=this.props.layout,t.buffers&&this.setBuffers(t.buffers),Object.seal(this)}destroy(){this.gl.deleteTransformFeedback(this.handle),super.destroy()}begin(e){void 0===e&&(e="point-list"),this.gl.bindTransformFeedback(L.TRANSFORM_FEEDBACK,this.handle),this.bindOnUse&&this._bindBuffers(),this.gl.beginTransformFeedback(function(e){switch(e){case"point-list":return L.POINTS;case"line-list":case"line-strip":return L.LINES;case"triangle-list":case"triangle-strip":return L.TRIANGLES;default:throw new Error(e)}}(e))}end(){this.gl.endTransformFeedback(),this.bindOnUse&&this._unbindBuffers(),this.gl.bindTransformFeedback(L.TRANSFORM_FEEDBACK,null)}setBuffers(e){this.buffers={},this.unusedBuffers={},this.bind((()=>{for(const t in e)this.setBuffer(t,e[t])}))}setBuffer(e,t){const n=this._getVaryingIndex(e),{buffer:i,byteLength:r,byteOffset:o}=this._getBufferRange(t);if(n<0)return this.unusedBuffers[e]=i,void _.R.warn(`${this.id} unusedBuffers varying buffer ${e}`)();this.buffers[n]={buffer:i,byteLength:r,byteOffset:o},this.bindOnUse||this._bindBuffer(n,i,o,r)}getBuffer(e){if(en(e))return this.buffers[e]||null;const t=this._getVaryingIndex(e);return t>=0?this.buffers[t]:null}bind(e){if(void 0===e&&(e=this.handle),"function"!=typeof e)return this.gl.bindTransformFeedback(L.TRANSFORM_FEEDBACK,e),this;let t;return this._bound?t=e():(this.gl.bindTransformFeedback(L.TRANSFORM_FEEDBACK,this.handle),this._bound=!0,t=e(),this._bound=!1,this.gl.bindTransformFeedback(L.TRANSFORM_FEEDBACK,null)),t}unbind(){this.bind(null)}_getBufferRange(e){if(e instanceof Ke)return{buffer:e,byteOffset:0,byteLength:e.byteLength};const{buffer:t,byteOffset:n=0,byteLength:i=e.buffer.byteLength}=e;return{buffer:t,byteOffset:n,byteLength:i}}_getVaryingIndex(e){if(en(e))return Number(e);for(const t of this.layout.varyings)if(e===t.name)return t.location;return-1}_bindBuffers(){for(const e in this.buffers){const{buffer:t,byteLength:n,byteOffset:i}=this._getBufferRange(this.buffers[e]);this._bindBuffer(Number(e),t,i,n)}}_unbindBuffers(){for(const e in this.buffers)this.gl.bindBufferBase(L.TRANSFORM_FEEDBACK_BUFFER,Number(e),null)}_bindBuffer(e,t,n,i){void 0===n&&(n=0);const r=t&&t.handle;r&&void 0!==i?this.gl.bindBufferRange(L.TRANSFORM_FEEDBACK_BUFFER,e,r,n,i):this.gl.bindBufferBase(L.TRANSFORM_FEEDBACK_BUFFER,e,r)}}function en(e){return"number"==typeof e?Number.isInteger(e):/^\d+$/.test(e)}class tn extends Fe.F{static defaultProps=(()=>({...Fe.F.defaultProps,type:void 0,count:void 0}))();get[Symbol.toStringTag](){return"QuerySet"}constructor(e,t){super(e,t,tn.defaultProps)}}class nn extends tn{target=null;_queryPending=!1;_pollingPromise=null;get[Symbol.toStringTag](){return"Query"}constructor(e,t){if(super(e,t),this.device=e,t.count>1)throw new Error("WebGL QuerySet can only have one value");this.handle=this.device.gl.createQuery(),Object.seal(this)}destroy(){this.device.gl.deleteQuery(this.handle)}beginTimestampQuery(){return this._begin(L.TIME_ELAPSED_EXT)}endTimestampQuery(){this._end()}beginOcclusionQuery(e){return this._begin(e?.conservative?L.ANY_SAMPLES_PASSED_CONSERVATIVE:L.ANY_SAMPLES_PASSED)}endOcclusionQuery(){this._end()}beginTransformFeedbackQuery(){return this._begin(L.TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN)}endTransformFeedbackQuery(){this._end()}async resolveQuery(){return[await this.pollQuery()]}_begin(e){this._queryPending||(this.target=e,this.device.gl.beginQuery(this.target,this.handle))}_end(){this._queryPending||this.target&&(this.device.gl.endQuery(this.target),this.target=null,this._queryPending=!0)}isResultAvailable(){if(!this._queryPending)return!1;const e=this.device.gl.getQueryParameter(this.handle,L.QUERY_RESULT_AVAILABLE);return e&&(this._queryPending=!1),e}isTimerDisjoint(){return this.device.gl.getParameter(L.GPU_DISJOINT_EXT)}getResult(){return this.device.gl.getQueryParameter(this.handle,L.QUERY_RESULT)}getTimerMilliseconds(){return this.getResult()/1e6}pollQuery(e){if(void 0===e&&(e=Number.POSITIVE_INFINITY),this._pollingPromise)return this._pollingPromise;let t=0;return this._pollingPromise=new Promise(((n,i)=>{const r=()=>{this.isResultAvailable()?(n(this.getResult()),this._pollingPromise=null):t++>e?(i("Timed out"),this._pollingPromise=null):requestAnimationFrame(r)};requestAnimationFrame(r)})),this._pollingPromise}}class rn extends S{type="webgl";debug=!1;_canvasSizeInfo={clientWidth:0,clientHeight:0,devicePixelRatio:1};_extensions={};_polyfilled=!1;constructor(e){if(super({...e,id:e.id||ze("webgl-device")}),!e.createCanvasContext)throw new Error("WebGLDevice requires props.createCanvasContext to be set");const t=!0===e.createCanvasContext?{}:e.createCanvasContext;let n=t.canvas?.gl?.device;if(n)throw new Error(`WebGL context already attached to device ${n.id}`);this.canvasContext=new Be(this,t),this.lost=new Promise((e=>{this._resolveContextLost=e}));const i={...e.webgl};"premultiplied"===t.alphaMode&&(i.premultipliedAlpha=!0),void 0!==e.powerPreference&&(i.powerPreference=e.powerPreference);const r=function(e,t,n){let i="";const r={preserveDrawingBuffer:!0,...n};let o=null;if(o||=e.getContext("webgl2",r),r.failIfMajorPerformanceCaveat&&(i||="Only software GPU is available. Set `failIfMajorPerformanceCaveat: false` to allow."),o||n.failIfMajorPerformanceCaveat||(r.failIfMajorPerformanceCaveat=!1,o=e.getContext("webgl2",r),o.luma||={},o.luma.softwareRenderer=!0),o||(o=e.getContext("webgl",{}),o&&(o=null,i||="Your browser only supports WebGL1")),!o)throw i||="Your browser does not support WebGL",new Error(`Failed to create WebGL context: ${i}`);const{onContextLost:s,onContextRestored:a}=t;return e.addEventListener("webglcontextlost",(e=>s(e)),!1),e.addEventListener("webglcontextrestored",(e=>a(e)),!1),o.luma||={},o}(this.canvasContext.canvas,{onContextLost:e=>this._resolveContextLost?.({reason:"destroyed",message:"Entered sleep mode, or too many apps or browser tabs are using the GPU."}),onContextRestored:e=>console.log("WebGL context restored")},i);if(!r)throw new Error("WebGL context creation failed");if(n=r.device,n)throw new Error(`WebGL context already attached to device ${n.id}`);this.handle=r,this.gl=r,this.spectorJS=function(e){if(!(e={...Ge,...e}).debugSpectorJS)return null;if(!we&&globalThis.SPECTOR&&!globalThis.luma?.spector){_.R.probe(1,"SPECTOR found and initialized. Start with `luma.spector.displayUI()`")();const{Spector:e}=globalThis.SPECTOR;we=new e,globalThis.luma&&(globalThis.luma.spector=we)}if(!we)return null;if(Ue||(Ue=!0,we.spyCanvases(),we?.onCaptureStarted.add((e=>_.R.info("Spector capture started:",e)())),we?.onCapture.add((e=>{_.R.info("Spector capture complete:",e)(),we?.getResultUI(),we?.resultView.display(),we?.resultView.addCapture(e)}))),e.gl){const t=e.gl,n=t.device;we?.startCapture(e.gl,500),t.device=n,new Promise((e=>setTimeout(e,2e3))).then((e=>{_.R.info("Spector capture stopped after 2 seconds")(),we?.stopCapture()}))}return we}({...this.props,gl:this.handle}),this.gl.device=this,this.gl._version=2,this.info=Z(this.gl,this._extensions),this.limits=new Pe(this.gl),this.features=new Ie(this.gl,this._extensions,this.props._disabledFeatures),this.props._initializeFeatures&&this.features.initializeFeatures(),this.canvasContext.resize();const o=new j(this.gl,{log:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return _.R.log(1,...t)()}});o.trackState(this.gl,{copyState:!1});const s=e.debugWebGL||e.debug,a=e.debugWebGL;s&&(this.gl=Xe(this.gl,{debugWebGL:s,traceWebGL:a}),_.R.warn("WebGL debug mode activated. Performance reduced.")(),e.debugWebGL&&(_.R.level=Math.max(_.R.level,1)))}destroy(){}get isLost(){return this.gl.isContextLost()}isTextureFormatSupported(e){return Re(this.gl,e,this._extensions)}isTextureFormatFilterable(e){return function(e,t,n){if(!Re(e,t,n))return!1;if(t.startsWith("depth")||t.startsWith("stencil"))return!1;try{if(v(t).signed)return!1}catch{return!1}return t.endsWith("32float")?Boolean(q(e,"OES_texture_float_linear, extensions",n)):!t.endsWith("16float")||Boolean(q(e,"OES_texture_half_float_linear, extensions",n))}(this.gl,e,this._extensions)}isTextureFormatRenderable(e){return function(e,t,n){return!!Re(e,t,n)&&"number"!=typeof t}(this.gl,e,this._extensions)}createCanvasContext(e){throw new Error("WebGL only supports a single canvas")}createBuffer(e){const t=this._normalizeBufferProps(e);return new Ke(this,t)}createTexture(e){return new Tt(this,e)}createExternalTexture(e){throw new Error("createExternalTexture() not implemented")}createSampler(e){return new lt(this,e)}createShader(e){return new $e(this,e)}createFramebuffer(e){return new Oe(this,e)}createVertexArray(e){return new qt(this,e)}createTransformFeedback(e){return new Jt(this,e)}createQuerySet(e){return new nn(this,e)}createRenderPipeline(e){return new wt(this,e)}beginRenderPass(e){return new St(this,e)}createComputePipeline(e){throw new Error("ComputePipeline not supported in WebGL")}beginComputePass(e){throw new Error("ComputePass not supported in WebGL")}renderPass=null;createCommandEncoder(e){return void 0===e&&(e={}),new zt(this,e)}submit(){this.renderPass?.end(),this.renderPass=null}readPixelsToArrayWebGL(e,t){return gt(e,t)}readPixelsToBufferWebGL(e,t){return Et(e,t)}setParametersWebGL(e){Y(this.gl,e)}getParametersWebGL(e){return z(this.gl,e)}withParametersWebGL(e,t){return ct(this.gl,e,t)}clearWebGL(e){!function(e,t){_.R.warn("clear will be removed in next minor release");const{framebuffer:n=null,color:i=null,depth:r=null,stencil:o=null}=t||{},s={};n&&(s.framebuffer=n);let a=0;i&&(a|=16384,!0!==i&&(s.clearColor=i)),r&&(a|=256,!0!==r&&(s.clearDepth=r)),o&&(a|=1024,!0!==r&&(s.clearStencil=r));const l=e.gl;ct(l,s,(()=>{l.clear(a)}))}(this,e)}resetWebGL(){_.R.warn("WebGLDevice.resetWebGL is deprecated, use only for debugging")(),Y(this.gl,F)}loseDevice(){let e=!1;const t=this.getExtension("WEBGL_lose_context").WEBGL_lose_context;return t&&(e=!0,t.loseContext()),this._resolveContextLost?.({reason:"destroyed",message:"Application triggered context loss"}),e}pushState(){j.get(this.gl).push()}popState(){j.get(this.gl).pop()}setSpectorMetadata(e,t){e.__SPECTOR_Metadata=t}getGLKey(e,t){const n=Number(e);for(const i in this.gl)if(this.gl[i]===n)return`GL.${i}`;return t?.emptyIfUnknown?"":String(e)}getGLKeys(e){const t={emptyIfUnknown:!0};return Object.entries(e).reduce(((e,n)=>{let[i,r]=n;return e[`${i}:${this.getGLKey(i,t)}`]=`${r}:${this.getGLKey(r,t)}`,e}),{})}setConstantAttributeWebGL(e,t){const n=this.limits.maxVertexAttributes;this._constants=this._constants||new Array(n).fill(null);const i=this._constants[e];switch(i&&function(e,t){if(!e||!t||e.length!==t.length||e.constructor!==t.constructor)return!1;for(let n=0;n<e.length;++n)if(e[n]!==t[n])return!1;return!0}(i,t)&&_.R.info(1,`setConstantAttributeWebGL(${e}) could have been skipped, value unchanged`)(),this._constants[e]=t,t.constructor){case Float32Array:!function(e,t,n){switch(n.length){case 1:e.gl.vertexAttrib1fv(t,n);break;case 2:e.gl.vertexAttrib2fv(t,n);break;case 3:e.gl.vertexAttrib3fv(t,n);break;case 4:e.gl.vertexAttrib4fv(t,n)}}(this,e,t);break;case Int32Array:!function(e,t,n){e.gl.vertexAttribI4iv(t,n)}(this,e,t);break;case Uint32Array:!function(e,t,n){e.gl.vertexAttribI4uiv(t,n)}(this,e,t);break;default:throw new Error("constant")}}getExtension(e){return q(this.gl,e,this._extensions),this._extensions}}const on={WEBGL_depth_texture:{UNSIGNED_INT_24_8_WEBGL:L.UNSIGNED_INT_24_8},OES_element_index_uint:{},OES_texture_float:{},OES_texture_half_float:{HALF_FLOAT_OES:L.HALF_FLOAT},EXT_color_buffer_float:{},OES_standard_derivatives:{FRAGMENT_SHADER_DERIVATIVE_HINT_OES:L.FRAGMENT_SHADER_DERIVATIVE_HINT},EXT_frag_depth:{},EXT_blend_minmax:{MIN_EXT:L.MIN,MAX_EXT:L.MAX},EXT_shader_texture_lod:{}},sn=e=>({drawBuffersWEBGL:t=>e.drawBuffers(t),COLOR_ATTACHMENT0_WEBGL:L.COLOR_ATTACHMENT0,COLOR_ATTACHMENT1_WEBGL:L.COLOR_ATTACHMENT1,COLOR_ATTACHMENT2_WEBGL:L.COLOR_ATTACHMENT2,COLOR_ATTACHMENT3_WEBGL:L.COLOR_ATTACHMENT3}),an=e=>({VERTEX_ARRAY_BINDING_OES:L.VERTEX_ARRAY_BINDING,createVertexArrayOES:()=>e.createVertexArray(),deleteVertexArrayOES:t=>e.deleteVertexArray(t),isVertexArrayOES:t=>e.isVertexArray(t),bindVertexArrayOES:t=>e.bindVertexArray(t)}),ln=e=>({VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE:35070,drawArraysInstancedANGLE(){return e.drawArraysInstanced(...arguments)},drawElementsInstancedANGLE(){return e.drawElementsInstanced(...arguments)},vertexAttribDivisorANGLE(){return e.vertexAttribDivisor(...arguments)}});function cn(e){void 0===e&&(e=!0);const t=HTMLCanvasElement.prototype;if(!e&&t.originalGetContext)return t.getContext=t.originalGetContext,void(t.originalGetContext=void 0);t.originalGetContext=t.getContext,t.getContext=function(e,t){if("webgl"===e||"experimental-webgl"===e){const e=this.originalGetContext("webgl2",t);return e instanceof HTMLElement&&function(e){e.getExtension("EXT_color_buffer_float");const t={...on,WEBGL_disjoint_timer_query:e.getExtension("EXT_disjoint_timer_query_webgl2"),WEBGL_draw_buffers:sn(e),OES_vertex_array_object:an(e),ANGLE_instanced_arrays:ln(e)},n=e.getExtension;e.getExtension=function(i){const r=n.call(e,i);return r||(i in t?t[i]:null)};const i=e.getSupportedExtensions;e.getSupportedExtensions=function(){const n=i.apply(e)||[];return n?.concat(Object.keys(t))}}(e),e}return this.originalGetContext(e,t)}}const un=new class extends N{type="webgl";constructor(){super(),S.defaultProps={...S.defaultProps,...Ge},rn.adapter=this}isSupported(){return"undefined"!=typeof WebGL2RenderingContext}enforceWebGL2(e){cn(e)}async attach(e){if(e instanceof rn)return e;if(e?.device instanceof S)return e.device;if(!function(e){if("undefined"!=typeof WebGL2RenderingContext&&e instanceof WebGL2RenderingContext)return!0;return Boolean(e&&Number.isFinite(e._version))}(e))throw new Error("Invalid WebGL2RenderingContext");return new rn({_handle:e})}async create(e){void 0===e&&(e={}),_.R.groupCollapsed(1,"WebGLDevice created")();const t=[];(e.debugWebGL||e.debug)&&t.push(async function(){(0,u.B)()&&!globalThis.WebGLDebugUtils&&(globalThis.global=globalThis.global||globalThis,globalThis.global.module={},await De("https://unpkg.com/webgl-debug@2.0.1/index.js"))}()),e.debugSpectorJS&&t.push(async function(e){if(!globalThis.SPECTOR)try{await De(e.debugSpectorJSUrl||Ge.debugSpectorJSUrl)}catch(t){_.R.warn(String(t))}}(e));const n=await Promise.allSettled(t);for(const o of n)"rejected"===o.status&&_.R.error(`Failed to initialize debug libraries ${o.reason}`)();const i=new rn(e),r=`Created ${i.type}${i.debug?" debug":""} context: ${i.info.vendor}, ${i.info.renderer} for canvas: ${i.canvasContext.id}`;return _.R.probe(1,r)(),_.R.table(1,i.info)(),_.R.groupEnd(1)(),i}};class dn extends p.h{constructor(e,t){super(e,t),this.device=e,this.byteLength=function(e){return e.byteLength||e.data?.byteLength||0}(t);const n=Boolean(t.data),i=4*Math.ceil(this.byteLength/4);this.handle=this.props.handle||this.device.handle.createBuffer({size:i,usage:this.props.usage||GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,mappedAtCreation:this.props.mappedAtCreation||n,label:this.props.id}),t.data&&this._writeMapped(t.data),n&&!t.mappedAtCreation&&this.handle.unmap()}destroy(){this.handle?.destroy(),this.handle=null}write(e,t){void 0===t&&(t=0),this.device.handle.queue.writeBuffer(this.handle,t,e.buffer,e.byteOffset,e.byteLength)}async readAsync(e,t){void 0===e&&(e=0),void 0===t&&(t=this.byteLength);const n=new dn(this.device,{usage:p.h.MAP_READ|p.h.COPY_DST,byteLength:t}),i=this.device.handle.createCommandEncoder();i.copyBufferToBuffer(this.handle,e,n.handle,0,t),this.device.handle.queue.submit([i.finish()]),await n.handle.mapAsync(GPUMapMode.READ,e,t);const r=n.handle.getMappedRange().slice(0);return n.handle.unmap(),n.destroy(),new Uint8Array(r)}_writeMapped(e){const t=this.handle.getMappedRange();new e.constructor(t).set(e)}mapAsync(e,t,n){return void 0===t&&(t=0),this.handle.mapAsync(e,t,n)}getMappedRange(e,t){return void 0===e&&(e=0),this.handle.getMappedRange(e,t)}unmap(){this.handle.unmap()}}function fn(e){if(e.includes("webgl"))throw new Error("webgl-only format");return e}class _n extends qe.L{constructor(e,t){super(e,t),this.device=e;const n={...this.props,mipmapFilter:void 0};"comparison-sampler"!==t.type&&delete n.compare,t.mipmapFilter&&"none"!==t.mipmapFilter&&(n.mipmapFilter=t.mipmapFilter),this.handle=this.handle||this.device.handle.createSampler(n),this.handle.label=this.props.id}destroy(){this.handle=null}}class hn extends ut.X{constructor(e,t){super(e,t),this.device=e,this.texture=t.texture,this.handle=this.handle||this.texture.handle.createView({format:t.format||this.texture.format,dimension:t.dimension||this.texture.dimension,aspect:t.aspect,baseMipLevel:t.baseMipLevel,mipLevelCount:t.mipLevelCount,baseArrayLayer:t.baseArrayLayer,arrayLayerCount:t.arrayLayerCount}),this.handle.label=this.props.id}destroy(){this.handle=null}}const pn={"1d":"1d","2d":"2d","2d-array":"2d",cube:"2d","cube-array":"2d","3d":"3d"};class mn extends ye.g{height=1;width=1;constructor(e,t){super(e,t=ye.g._fixProps(t)),this.device=e,this.initialize(t)}destroy(){this.handle?.destroy(),this.handle=null}createView(e){return new hn(this.device,{...e,texture:this})}initialize(e){this.handle=this.props.handle||this.createHandle(),this.handle.label||=this.id,this.props.data&&(ye.g.isExternalImage(this.props.data)?this.copyExternalImage({image:this.props.data}):this.setData({data:this.props.data})),this.width=this.handle.width,this.height=this.handle.height,this.sampler=e.sampler instanceof _n?e.sampler:new _n(this.device,e.sampler||{}),this.view=new hn(this.device,{...this.props,texture:this})}createHandle(){const e=this.props.width||this.props.data?.width||1,t=this.props.height||this.props.data?.height||1;return this.device.handle.createTexture({label:this.id,size:{width:e,height:t,depthOrArrayLayers:this.depth},usage:this.props.usage||ye.g.TEXTURE|ye.g.COPY_DST,dimension:pn[this.dimension],format:fn(this.format),mipLevelCount:this.mipLevels,sampleCount:this.props.samples})}createGPUTextureView(){return this.handle.createView({label:this.id})}setSampler(e){return this.sampler=e instanceof _n?e:new _n(this.device,e),this}setTexture1DData(e){throw new Error("not implemented")}setTexture2DData(e,t,n){throw new Error("not implemented")}setTexture3DData(e,t,n){throw new Error("not implemented")}setTextureCubeData(e,t){throw new Error("not implemented")}setTextureArrayData(e){throw new Error("not implemented")}setTextureCubeArrayData(e){throw new Error("not implemented")}setData(e){if(ArrayBuffer.isView(e.data)){const t=new Uint8ClampedArray(e.data.buffer),n=new ImageData(t,this.width,this.height);return this.copyExternalImage({image:n})}throw new Error("Texture.setData: Use CommandEncoder to upload data to texture in WebGPU")}copyExternalImage(e){const t=ye.g.getExternalImageSize(e.image),n={...ye.g.defaultCopyExternalImageOptions,...t,...e},{image:i,sourceX:r,sourceY:o,width:s,height:a,depth:l,mipLevel:c,x:u,y:d,z:f,aspect:_,colorSpace:h,premultipliedAlpha:p,flipY:m}=n;return this.device.handle.queue.copyExternalImageToTexture({source:i,origin:[r,o],flipY:m},{texture:this.handle,origin:[u,d,f],mipLevel:c,aspect:_,colorSpace:h,premultipliedAlpha:p},[s,a,l]),{width:s,height:a}}}class gn extends Fe.F{static defaultProps=(()=>({...Fe.F.defaultProps,source:void 0,colorSpace:"srgb"}))();get[Symbol.toStringTag](){return"ExternalTexture"}constructor(e,t){super(e,t,gn.defaultProps)}}class En extends gn{constructor(e,t){super(e,t),this.device=e,this.handle=this.props.handle||this.device.handle.importExternalTexture({source:t.source,colorSpace:t.colorSpace}),this.sampler=null}destroy(){this.handle=null}setSampler(e){return this.sampler=e instanceof _n?e:new _n(this.device,e),this}}class An extends je.M{constructor(e,t){super(e,t),this.device=e,this.device.handle.pushErrorScope("validation"),this.handle=this.props.handle||this.createHandle(),this.handle.label=this.props.id,this._checkCompilationError(this.device.handle.popErrorScope())}get asyncCompilationStatus(){return this.getCompilationInfo().then((()=>this.compilationStatus))}async _checkCompilationError(e){const t=await e;if(t){this.debugShader();const e=await this.getCompilationInfo();throw _.R.error(`Shader compilation error: ${t.message}`,e)(),new Error(`Shader compilation error: ${t.message}`)}}destroy(){this.handle=null}async getCompilationInfo(){return(await this.handle.getCompilationInfo()).messages}createHandle(){const{source:e}=this.props,t=e.includes("#version");if("glsl"===this.props.language||t)throw new Error("GLSL shaders are not supported in WebGPU");return this.device.handle.createShaderModule({code:e})}}function vn(e){return e.depthStencil=e.depthStencil||{format:"depth24plus",stencilFront:{},stencilBack:{},depthWriteEnabled:!1,depthCompare:"less-equal"},e.depthStencil}function Tn(e){return vn(e).stencilFront}function Rn(e){return vn(e).stencilBack}const bn={cullMode:(e,t,n)=>{n.primitive=n.primitive||{},n.primitive.cullMode=t},frontFace:(e,t,n)=>{n.primitive=n.primitive||{},n.primitive.frontFace=t},depthWriteEnabled:(e,t,n)=>{vn(n).depthWriteEnabled=t},depthCompare:(e,t,n)=>{vn(n).depthCompare=t},depthFormat:(e,t,n)=>{vn(n).format=t},depthBias:(e,t,n)=>{vn(n).depthBias=t},depthBiasSlopeScale:(e,t,n)=>{vn(n).depthBiasSlopeScale=t},depthBiasClamp:(e,t,n)=>{vn(n).depthBiasClamp=t},stencilReadMask:(e,t,n)=>{vn(n).stencilReadMask=t},stencilWriteMask:(e,t,n)=>{vn(n).stencilWriteMask=t},stencilCompare:(e,t,n)=>{const i=Tn(n),r=Rn(n);i.compare=t,r.compare=t},stencilPassOperation:(e,t,n)=>{const i=Tn(n),r=Rn(n);i.passOp=t,r.passOp=t},stencilFailOperation:(e,t,n)=>{const i=Tn(n),r=Rn(n);i.failOp=t,r.failOp=t},stencilDepthFailOperation:(e,t,n)=>{const i=Tn(n),r=Rn(n);i.depthFailOp=t,r.depthFailOp=t},sampleCount:(e,t,n)=>{n.multisample=n.multisample||{},n.multisample.count=t},sampleMask:(e,t,n)=>{n.multisample=n.multisample||{},n.multisample.mask=t},sampleAlphaToCoverageEnabled:(e,t,n)=>{n.multisample=n.multisample||{},n.multisample.alphaToCoverageEnabled=t},colorMask:(e,t,n)=>{In(n)[0].writeMask=t},blendColorOperation:(e,t,n)=>{In(n)}},Sn={primitive:{cullMode:"back",topology:"triangle-list"},vertex:{module:void 0,entryPoint:"main"},fragment:{module:void 0,entryPoint:"main",targets:[]},layout:"auto"};function Cn(e,t){void 0===t&&(t={}),Object.assign(e,{...Sn,...e}),function(e,t){for(const[n,i]of Object.entries(t)){const t=bn[n];if(!t)throw new Error(`Illegal parameter ${n}`);t(n,i,e)}}(e,t)}function In(e){if(e.fragment.targets=e.fragment?.targets||[],!Array.isArray(e.fragment?.targets))throw new Error("colorstate");return 0===e.fragment?.targets?.length&&e.fragment.targets?.push({}),e.fragment?.targets}function Pn(e,t,n,i){const r=function(e,t){const n=[];for(const[i,r]of Object.entries(e)){const e=xn(t,i);e&&n.push(Nn(r,e.location))}return n}(i,n);return e.createBindGroup({layout:t,entries:r})}function xn(e,t){const n=e.bindings.find((e=>e.name===t||`${e.name}uniforms`===t.toLocaleLowerCase()));return n||_.R.warn(`Binding ${t} not set: Not found in shader layout.`)(),n||null}function Nn(e,t){if(e instanceof p.h)return{binding:t,resource:{buffer:e.handle}};if(e instanceof qe.L)return{binding:t,resource:e.handle};if(e instanceof ye.g)return{binding:t,resource:e.handle.createView({label:"bind-group-auto-created"})};throw new Error("invalid binding")}var Ln=n(8337);function Fn(e){if(e.endsWith("-webgl"))throw new Error(`WebGPU does not support vertex format ${e}`);return e}function yn(e,t){const n=[],i=new Set;for(const r of t){const t=[];let o="vertex",s=0;const a=r.format;if(r.attributes)for(const n of r.attributes){const l=Mn(e,n.attribute,i),c=l?.location;o=l?.stepMode||(l?.name.startsWith("instance")?"instance":"vertex"),t.push({format:Fn(n.format||r.format),offset:n.byteOffset,shaderLocation:c}),s+=(0,Ln.w)(a).byteLength}else{const n=Mn(e,r.name,i);if(!n)continue;s=(0,Ln.w)(a).byteLength,o=n.stepMode||(n.name.startsWith("instance")?"instance":"vertex"),t.push({format:Fn(a),offset:0,shaderLocation:n.location})}n.push({arrayStride:r.byteStride||s,stepMode:o,attributes:t})}for(const r of e.attributes)i.has(r.name)||n.push({arrayStride:(0,Ln.w)("float32x3").byteLength,stepMode:r.stepMode||(r.name.startsWith("instance")?"instance":"vertex"),attributes:[{format:Fn("float32x3"),offset:0,shaderLocation:r.location}]});return n}function Mn(e,t,n){const i=e.attributes.find((e=>e.name===t));if(!i)return _.R.warn(`Unknown attribute ${t}`)(),null;if(n.has(t))throw new Error(`Duplicate attribute ${t}`);return n.add(t),i}class On extends Ct.r{fs=null;_bindGroupLayout=null;_bindGroup=null;constructor(e,t){if(super(e,t),this.device=e,this.handle=this.props.handle,!this.handle){const e=this._getRenderPipelineDescriptor();_.R.groupCollapsed(1,`new WebGPURenderPipeline(${this.id})`)(),_.R.probe(1,JSON.stringify(e,null,2))(),_.R.groupEnd(1)(),this.handle=this.device.handle.createRenderPipeline(e)}this.handle.label=this.props.id,this.vs=t.vs,this.fs=t.fs,this._bindings={...this.props.bindings}}destroy(){this.handle=null}setBindings(e){Object.assign(this._bindings,e)}draw(e){const t=e.renderPass;t.handle.setPipeline(this.handle);const n=this._getBindGroup();return n&&t.handle.setBindGroup(0,n),e.vertexArray.bindBeforeRender(e.renderPass),e.indexCount?t.handle.drawIndexed(e.indexCount,e.instanceCount,e.firstIndex,e.baseVertex,e.firstInstance):t.handle.draw(e.vertexCount||0,e.instanceCount||1,e.firstInstance),e.vertexArray.unbindAfterRender(e.renderPass),!0}_getBindGroup(){return 0===this.shaderLayout.bindings.length?null:(this._bindGroupLayout=this._bindGroupLayout||this.handle.getBindGroupLayout(0),this._bindGroup=this._bindGroup||Pn(this.device.handle,this._bindGroupLayout,this.shaderLayout,this._bindings),this._bindGroup)}_getRenderPipelineDescriptor(){const e={vertex:{module:this.props.vs.handle,entryPoint:this.props.vertexEntryPoint||"main",buffers:yn(this.shaderLayout,this.props.bufferLayout)},fragment:{module:this.props.fs.handle,entryPoint:this.props.fragmentEntryPoint||"main",targets:[{format:fn(this.device.getCanvasContext().format)}]},primitive:{topology:this.props.topology},layout:"auto"};return Cn(e,this.props.parameters),e}}class Bn extends Me{colorAttachments=[];depthStencilAttachment=null;constructor(e,t){super(e,t),this.device=e,this.autoCreateAttachmentTextures()}updateAttachments(){}}var Dn=n(5128);class wn extends Dn.C{_bindGroupLayout=null;_bindGroup=null;_bindings={};constructor(e,t){super(e,t),this.device=e;const n=this.props.shader;this.handle=this.props.handle||this.device.handle.createComputePipeline({label:this.props.id,compute:{module:n.handle,entryPoint:this.props.entryPoint,constants:this.props.constants},layout:"auto"})}setBindings(e){Object.assign(this._bindings,e)}_getBindGroup(){return this._bindGroupLayout=this._bindGroupLayout||this.handle.getBindGroupLayout(0),this._bindGroup=this._bindGroup||Pn(this.device.handle,this._bindGroupLayout,this.shaderLayout,this._bindings),this._bindGroup}}class Un extends Rt{pipeline=null;constructor(e,t){void 0===t&&(t={}),super(e,t),this.device=e;const n=t.framebuffer||e.getCanvasContext().getCurrentFramebuffer(),i=this.getRenderPassDescriptor(n),r=t.timestampQuerySet;if(r&&(i.occlusionQuerySet=r.handle),e.features.has("timestamp-query")){const e=t.timestampQuerySet;i.timestampWrites=e?{querySet:e.handle,beginningOfPassWriteIndex:t.beginTimestampIndex,endOfPassWriteIndex:t.endTimestampIndex}:void 0}if(!e.commandEncoder)throw new Error("commandEncoder not available");this.handle=this.props.handle||e.commandEncoder.beginRenderPass(i),this.handle.label=this.props.id,_.R.groupCollapsed(3,`new WebGPURenderPass(${this.id})`)(),_.R.probe(3,JSON.stringify(i,null,2))(),_.R.groupEnd(3)()}destroy(){}end(){this.handle.end()}setPipeline(e){this.pipeline=e,this.handle.setPipeline(this.pipeline.handle)}setBindings(e){this.pipeline?.setBindings(e);const t=this.pipeline?._getBindGroup();t&&this.handle.setBindGroup(0,t)}setIndexBuffer(e,t,n,i){void 0===n&&(n=0),this.handle.setIndexBuffer(e.handle,t,n,i)}setVertexBuffer(e,t,n){void 0===n&&(n=0),this.handle.setVertexBuffer(e,t.handle,n)}draw(e){e.indexCount?this.handle.drawIndexed(e.indexCount,e.instanceCount,e.firstIndex,e.baseVertex,e.firstInstance):this.handle.draw(e.vertexCount||0,e.instanceCount||1,e.firstIndex,e.firstInstance)}drawIndirect(){}setParameters(e){const{blendConstant:t,stencilReference:n,scissorRect:i,viewport:r}=e;t&&this.handle.setBlendConstant(t),n&&this.handle.setStencilReference(n),i&&this.handle.setScissorRect(i[0],i[1],i[2],i[3]),r&&this.handle.setViewport(r[0],r[1],r[2],r[3],r[4],r[5])}pushDebugGroup(e){this.handle.pushDebugGroup(e)}popDebugGroup(){this.handle.popDebugGroup()}insertDebugMarker(e){this.handle.insertDebugMarker(e)}beginOcclusionQuery(e){this.handle.beginOcclusionQuery(e)}endOcclusionQuery(){this.handle.endOcclusionQuery()}getRenderPassDescriptor(e){const t={colorAttachments:[]};if(t.colorAttachments=e.colorAttachments.map((e=>({loadOp:!1!==this.props.clearColor?"clear":"load",colorClearValue:this.props.clearColor||[0,0,0,0],storeOp:this.props.discard?"discard":"store",view:e.handle}))),e.depthStencilAttachment){t.depthStencilAttachment={view:e.depthStencilAttachment.handle};const{depthStencilAttachment:n}=t;this.props.depthReadOnly&&(n.depthReadOnly=!0),!1!==this.props.clearDepth&&(n.depthClearValue=!0===this.props.clearDepth?1:this.props.clearDepth);!0&&(n.depthLoadOp=!1!==this.props.clearDepth?"clear":"load",n.depthStoreOp="store");!1&&(n.stencilLoadOp=!1!==this.props.clearStencil?"clear":"load",n.stencilStoreOp="store")}return t}}class Gn extends Fe.F{static defaultProps=(()=>({...Fe.F.defaultProps,timestampQuerySet:void 0,beginTimestampIndex:void 0,endTimestampIndex:void 0}))();get[Symbol.toStringTag](){return"ComputePass"}constructor(e,t){super(e,t,Gn.defaultProps)}}class Hn extends Gn{_webgpuPipeline=null;constructor(e,t){let n;if(super(e,t),this.device=e,e.features.has("timestamp-query")){const e=t.timestampQuerySet;e&&(n={querySet:e.handle,beginningOfPassWriteIndex:t.beginTimestampIndex,endOfPassWriteIndex:t.endTimestampIndex})}this.handle=this.props.handle||e.commandEncoder?.beginComputePass({label:this.props.id,timestampWrites:n})}destroy(){}end(){this.handle.end()}setPipeline(e){const t=e;this.handle.setPipeline(t.handle),this._webgpuPipeline=t,this.setBindings([])}setBindings(e){const t=this._webgpuPipeline._getBindGroup();this.handle.setBindGroup(0,t)}dispatch(e,t,n){this.handle.dispatchWorkgroups(e,t,n)}dispatchIndirect(e,t){void 0===t&&(t=0);const n=e;this.handle.dispatchWorkgroupsIndirect(n.handle,t)}pushDebugGroup(e){this.handle.pushDebugGroup(e)}popDebugGroup(){this.handle.popDebugGroup()}insertDebugMarker(e){this.handle.insertDebugMarker(e)}}class Xn extends jt{get[Symbol.toStringTag](){return"WebGPUVertexArray"}constructor(e,t){super(e,t),this.device=e}destroy(){}setIndexBuffer(e){this.indexBuffer=e}setBuffer(e,t){this.attributes[e]=t}bindBeforeRender(e,t,n){const i=e,r=this.indexBuffer;r?.handle&&(_.R.warn("setting index buffer",r?.handle,r?.indexType)(),i.handle.setIndexBuffer(r?.handle,r?.indexType));for(let o=0;o<this.maxVertexAttributes;o++){const e=this.attributes[o];e?.handle&&(_.R.warn(`setting vertex buffer ${o}`,e?.handle)(),i.handle.setVertexBuffer(o,e?.handle))}}unbindAfterRender(e){}static isConstantAttributeZeroSupported(e){return"Chrome"===(0,$t.X)()}}class Vn extends xe{format=(()=>navigator.gpu.getPreferredCanvasFormat())();depthStencilFormat="depth24plus";depthStencilAttachment=null;constructor(e,t,n){super(n),this.device=e,this.width=-1,this.height=-1,this._setAutoCreatedCanvasId(`${this.device.id}-canvas`),this.gpuCanvasContext=this.canvas.getContext("webgpu"),this.format="bgra8unorm"}destroy(){this.gpuCanvasContext.unconfigure()}getCurrentFramebuffer(){this.update();const e=this.getCurrentTexture();return this.width=e.width,this.height=e.height,this._createDepthStencilAttachment(),new Bn(this.device,{colorAttachments:[e],depthStencilAttachment:this.depthStencilAttachment})}update(){const[e,t]=this.getPixelSize();(e!==this.width||t!==this.height)&&(this.width=e,this.height=t,this.depthStencilAttachment&&(this.depthStencilAttachment.destroy(),this.depthStencilAttachment=null),this.gpuCanvasContext.configure({device:this.device.handle,format:fn(this.format),colorSpace:this.props.colorSpace,alphaMode:this.props.alphaMode}),_.R.log(1,`Resized to ${this.width}x${this.height}px`)())}resize(e){if(this.update(),this.device.handle)if(this.canvas){const t=this.getDevicePixelRatio(e?.useDevicePixels);this.setDevicePixelRatio(t,e)}else;}getCurrentTexture(){return this.device.createTexture({id:`${this.id}#color-texture`,handle:this.gpuCanvasContext.getCurrentTexture(),format:this.format})}_createDepthStencilAttachment(){return this.depthStencilAttachment||(this.depthStencilAttachment=this.device.createTexture({id:`${this.id}#depth-stencil-texture`,format:this.depthStencilFormat,width:this.width,height:this.height,usage:GPUTextureUsage.RENDER_ATTACHMENT})),this.depthStencilAttachment}}class kn extends tn{constructor(e,t){super(e,t),this.device=e,this.handle=this.props.handle||this.device.handle.createQuerySet({type:this.props.type,count:this.props.count}),this.handle.label=this.props.id}destroy(){this.handle?.destroy(),this.handle=null}}class Wn extends S{type="webgpu";canvasContext=null;_isLost=!1;commandEncoder=null;renderPass=null;constructor(e,t,n,i){if(super({...e,id:e.id||"webgpu-device"}),this.handle=t,this.adapter=n,this.adapterInfo=i,this.info=this._getInfo(),this.features=this._getFeatures(),this.limits=this.handle.limits,t.addEventListener("uncapturederror",(e=>{const t=e instanceof GPUUncapturedErrorEvent?e.error.message:"Unknown error";this.error(new Error(t))})),this.lost=new Promise((async e=>{const t=await this.handle.lost;this._isLost=!0,e({reason:"destroyed",message:t.message})})),e.createCanvasContext){const t=!0===e.createCanvasContext?{}:e.createCanvasContext;this.canvasContext=new Vn(this,this.adapter,t)}}destroy(){this.handle.destroy()}isTextureFormatSupported(e){return!e.includes("webgl")}isTextureFormatFilterable(e){return this.isTextureFormatSupported(e)&&!e.startsWith("depth")&&!e.startsWith("stencil")}isTextureFormatRenderable(e){return this.isTextureFormatSupported(e)}get isLost(){return this._isLost}createBuffer(e){const t=this._normalizeBufferProps(e);return new dn(this,t)}createTexture(e){return new mn(this,e)}createExternalTexture(e){return new En(this,e)}createShader(e){return new An(this,e)}createSampler(e){return new _n(this,e)}createRenderPipeline(e){return new On(this,e)}createFramebuffer(e){return new Bn(this,e)}createComputePipeline(e){return new wn(this,e)}createVertexArray(e){return new Xn(this,e)}beginRenderPass(e){return this.commandEncoder=this.commandEncoder||this.handle.createCommandEncoder(),new Un(this,e)}beginComputePass(e){return this.commandEncoder=this.commandEncoder||this.handle.createCommandEncoder(),new Hn(this,e)}createTransformFeedback(e){throw new Error("Transform feedback not supported in WebGPU")}createQuerySet(e){return new kn(this,e)}createCanvasContext(e){return new Vn(this,this.adapter,e)}submit(){const e=this.commandEncoder?.finish();e&&this.handle.queue.submit([e]),this.commandEncoder=null}_getInfo(){const[e,t]=(this.adapterInfo.driver||"").split(" Version "),n=this.adapterInfo.vendor||this.adapter.__brand||"unknown",i=e||"",r=t||"",o="apple"===n?"apple":"unknown",s=this.adapterInfo.architecture||"unknown",a=this.adapterInfo.backend||"unknown";return{type:"webgpu",vendor:n,renderer:i,version:r,gpu:o,gpuType:(this.adapterInfo.type||"").split(" ")[0].toLowerCase()||"unknown",gpuBackend:a,gpuArchitecture:s,shadingLanguage:"wgsl",shadingLanguageVersion:100}}_getFeatures(){const e=new Set(this.handle.features);e.has("depth-clamping")&&(e.delete("depth-clamping"),e.add("depth-clip-control")),e.has("texture-compression-bc")&&e.add("texture-compression-bc5-webgl");const t=["timer-query-webgl","compilation-status-async-webgl","float32-renderable-webgl","float16-renderable-webgl","norm16-renderable-webgl","texture-filterable-anisotropic-webgl","shader-noperspective-interpolation-webgl"];for(const n of t)e.add(n);return new b(Array.from(e),this.props._disabledFeatures)}copyExternalImageToTexture(e){const{source:t,sourceX:n=0,sourceY:i=0,texture:r,mipLevel:o=0,aspect:s="all",colorSpace:a="display-p3",premultipliedAlpha:l=!1,width:c=r.width,height:u=r.height,depth:d=1}=e,f=r;this.handle?.queue.copyExternalImageToTexture({source:t,origin:[n,i]},{texture:f.handle,origin:[0,0,0],mipLevel:o,aspect:s,colorSpace:a,premultipliedAlpha:l},[c,u,d])}}const Yn=new class extends N{type="webgpu";constructor(){super(),Wn.adapter=this}isSupported(){return Boolean("undefined"!=typeof navigator&&navigator.gpu)}async create(e){if(!navigator.gpu)throw new Error("WebGPU not available. Open in Chrome Canary and turn on chrome://flags/#enable-unsafe-webgpu");_.R.groupCollapsed(1,"WebGPUDevice created")();const t=await navigator.gpu.requestAdapter({powerPreference:"high-performance"});if(!t)throw new Error("Failed to request WebGPU adapter");const n=await t.requestAdapterInfo();_.R.probe(2,"Adapter available",n)();const i=[],r={};if(e._requestMaxLimits){i.push(...Array.from(t.features));const e=Object.keys(t.limits).filter((e=>!["minSubgroupSize","maxSubgroupSize"].includes(e)));for(const n of e){const e=n,i=t.limits[e];"number"==typeof i&&(r[e]=i)}}const o=await t.requestDevice({requiredFeatures:i,requiredLimits:r});_.R.probe(1,"GPUDevice available")();const s=new Wn(e,o,t,n);return _.R.probe(1,"Device created. For more info, set chrome://flags/#enable-webgpu-developer-features")(),_.R.table(1,s.info)(),_.R.groupEnd(1)(),s}async attach(e){throw new Error("WebGPUAdapter.attach() not implemented")}};let zn,Kn={};const jn=(0,c.vt)((e=>({deviceType:void 0,deviceError:void 0,device:void 0,setDeviceType:async t=>{let n,i;try{i=await async function(e){return Kn[e]=Kn[e]||x.createDevice({adapters:[un,Yn],type:e,height:0,createCanvasContext:{container:(zn||(zn=document.createElement("div"),zn.style.display="none",document.body.appendChild(zn)),zn)}}),await Kn[e]}(t)}catch(r){n=r.message}return e((e=>({deviceType:t,deviceError:n,device:i})))}})));jn.getState().setDeviceType("webgl");var Qn=n(6065);const $n=Qn.Ay.div`
  display: flex;
  flex-direction: row;

  & > * + * {
    margin-left: 2px;
  }
`,qn=Qn.Ay.div((e=>`\n  cursor: pointer;\n  padding: 10px 20px;\n  font-weight: bold;\n  &:hover {\n    background-color: #eeefef;\n  }\n  ${e.isSelected?"\n    color: #276EF1;\n    border-bottom: 4px solid #276EF1;\n  ":""}\n`)),Zn=Qn.Ay.div`
  background-color: rgb(250, 248, 245);
`,Jn=e=>{const{children:t}=e,n=i.Children.toArray(t),[r,o]=(0,i.useState)(n[0]?.props.tag||n[0]?.props.title);let s=void 0!==e.selectedItem?e.selectedItem:r;const a=void 0!==e.setSelectedItem?e.setSelectedItem:o;return n.some((e=>(e.props.tag||e.props.title)===s))||(s=r),i.createElement(i.Fragment,null,i.createElement($n,null,n.map((e=>i.createElement(qn,{key:e.props.title,isSelected:(e.props.tag||e.props.title)===s,onClick:()=>a(e.props.tag||e.props.title)},e.props.title)))),i.createElement(Zn,null,n.find((e=>(e.props.tag||e.props.title)===s))))},ei=e=>{const{children:t}=e;return i.createElement(i.Fragment,null,t)};var ti=n(1993);const ni={devices:["webgl2","webgpu"]},ii=e=>{e={...ni,...e};const t=jn((e=>e.deviceType)),n=jn((e=>e.deviceError)),r=jn((e=>e.setDeviceType));return i.createElement(Jn,{selectedItem:t,setSelectedItem:r},e.devices.includes("webgl2")&&i.createElement(ei,{key:"WebGL2",title:"WebGL2",tag:"webgl"},n),e.devices.includes("webgpu")&&i.createElement(ei,{key:"WebGPU",title:"WebGPU",tag:"webgpu"},n))},ri=e=>i.createElement(ti.A,null,(()=>i.createElement(ii,e)));const oi=e=>{let{f:t}=e;const n=jn((e=>e.device)),r=n?n.info[t]:"N/A";return i.createElement("code",{style:{color:"darkgreen"}},r)},si=e=>{let{f:t}=e;const n=jn((e=>e.device));return i.createElement("code",{style:{color:"darkgreen"}},function(e,t){return e?e.limits[t]?String(e.limits[t]):"0 \u274c":"N/A"}(n,t))},ai=e=>{let{f:t}=e;const n=jn((e=>e.device));return i.createElement("span",null,function(e,t){return e?e.features.has(t)?"\u2705":"\u274c":"N/A"}(n,t))},li=e=>{let{f:t}=e;const n=jn((e=>e.device));return i.createElement("span",{key:t},function(e,t){const n=e&&e.isTextureFormatSupported(t);return e?n?"\u2705":"\u274c":"N/A"}(n,t))},ci=e=>{let{f:t}=e;const n=jn((e=>e.device));return i.createElement("span",null,function(e,t){const n=e&&e.isTextureFormatSupported(t)&&e.isTextureFormatFilterable(t);return e?n?"\u2705":"\u274c":"N/A"}(n,t))},ui=e=>{let{f:t}=e;const n=jn((e=>e.device)),i=t,r=n&&n.isTextureFormatSupported(i)&&n.isTextureFormatRenderable(i);return n?r?"\u2705":"\u274c":"N/A"};let di=0;const fi={device:null,onAddHTML:()=>"",onInitialize:async()=>null,onRender:()=>{},onFinalize:()=>{},onError:e=>console.error(e),stats:x.stats.get("animation-loop-"+di++),useDevicePixels:!0,autoResizeViewport:!1,autoResizeDrawingBuffer:!1};class _i{device=null;canvas=null;animationProps=null;timeline=null;needsRedraw="initialized";_initialized=!1;_running=!1;_animationFrameId=null;_nextFramePromise=null;_resolveNextFrame=null;_cpuStartTime=0;_error=null;constructor(e){if(this.props={...fi,...e},!(e=this.props).device)throw new Error("No device provided");const{useDevicePixels:t=!0}=this.props;this.stats=e.stats||new d.A({id:"animation-loop-stats"}),this.cpuTime=this.stats.get("CPU Time"),this.gpuTime=this.stats.get("GPU Time"),this.frameRate=this.stats.get("Frame Rate"),this.setProps({autoResizeViewport:e.autoResizeViewport,autoResizeDrawingBuffer:e.autoResizeDrawingBuffer,useDevicePixels:t}),this.start=this.start.bind(this),this.stop=this.stop.bind(this),this._onMousemove=this._onMousemove.bind(this),this._onMouseleave=this._onMouseleave.bind(this)}destroy(){this.stop(),this._setDisplay(null)}delete(){this.destroy()}setError(e){this.props.onError(e),this._error=Error();const t=this.device?.canvasContext?.canvas;if(t instanceof HTMLCanvasElement){const t=document.createElement("h1");t.innerHTML=e.message,t.style.position="absolute",t.style.top="20%",t.style.left="10px",t.style.color="black",t.style.backgroundColor="red",document.body.appendChild(t)}}setNeedsRedraw(e){return this.needsRedraw=this.needsRedraw||e,this}setProps(e){return"autoResizeViewport"in e&&(this.props.autoResizeViewport=e.autoResizeViewport||!1),"autoResizeDrawingBuffer"in e&&(this.props.autoResizeDrawingBuffer=e.autoResizeDrawingBuffer||!1),"useDevicePixels"in e&&(this.props.useDevicePixels=e.useDevicePixels||!1),this}async start(){if(this._running)return this;this._running=!0;try{let e;return this._initialized||(this._initialized=!0,await this._initDevice(),this._initialize(),await this.props.onInitialize(this._getAnimationProps())),this._running?(!1!==e&&(this._cancelAnimationFrame(),this._requestAnimationFrame()),this):null}catch(e){const t=e instanceof Error?e:new Error("Unknown error");throw this.props.onError(t),t}}stop(){return this._running&&(this.animationProps&&!this._error&&this.props.onFinalize(this.animationProps),this._cancelAnimationFrame(),this._nextFramePromise=null,this._resolveNextFrame=null,this._running=!1),this}redraw(){return this.device?.isLost||this._error||(this._beginFrameTimers(),this._setupFrame(),this._updateAnimationProps(),this._renderFrame(this._getAnimationProps()),this._clearNeedsRedraw(),this._resolveNextFrame&&(this._resolveNextFrame(this),this._nextFramePromise=null,this._resolveNextFrame=null),this._endFrameTimers()),this}attachTimeline(e){return this.timeline=e,this.timeline}detachTimeline(){this.timeline=null}waitForRender(){return this.setNeedsRedraw("waitForRender"),this._nextFramePromise||(this._nextFramePromise=new Promise((e=>{this._resolveNextFrame=e}))),this._nextFramePromise}async toDataURL(){if(this.setNeedsRedraw("toDataURL"),await this.waitForRender(),this.canvas instanceof HTMLCanvasElement)return this.canvas.toDataURL();throw new Error("OffscreenCanvas")}_initialize(){this._startEventHandling(),this._initializeAnimationProps(),this._updateAnimationProps(),this._resizeCanvasDrawingBuffer(),this._resizeViewport()}_setDisplay(e){this.display&&(this.display.destroy(),this.display.animationLoop=null),e&&(e.animationLoop=this),this.display=e}_requestAnimationFrame(){var e;this._running&&(this._animationFrameId=(e=this._animationFrame.bind(this),"undefined"!=typeof window&&window.requestAnimationFrame?window.requestAnimationFrame(e):setTimeout(e,1e3/60)))}_cancelAnimationFrame(){var e;null!==this._animationFrameId&&(e=this._animationFrameId,"undefined"!=typeof window&&window.cancelAnimationFrame?window.cancelAnimationFrame(e):clearTimeout(e),this._animationFrameId=null)}_animationFrame(){this._running&&(this.redraw(),this._requestAnimationFrame())}_renderFrame(e){this.display?this.display._renderFrame(e):(this.props.onRender(this._getAnimationProps()),this.device?.submit())}_clearNeedsRedraw(){this.needsRedraw=!1}_setupFrame(){this._resizeCanvasDrawingBuffer(),this._resizeViewport()}_initializeAnimationProps(){const e=this.device?.canvasContext?.canvas;if(!this.device||!e)throw new Error("loop");this.animationProps={animationLoop:this,device:this.device,canvas:e,timeline:this.timeline,useDevicePixels:this.props.useDevicePixels,needsRedraw:!1,width:1,height:1,aspect:1,time:0,startTime:Date.now(),engineTime:0,tick:0,tock:0,_mousePosition:null}}_getAnimationProps(){if(!this.animationProps)throw new Error("animationProps");return this.animationProps}_updateAnimationProps(){if(!this.animationProps)return;const{width:e,height:t,aspect:n}=this._getSizeAndAspect();e===this.animationProps.width&&t===this.animationProps.height||this.setNeedsRedraw("drawing buffer resized"),n!==this.animationProps.aspect&&this.setNeedsRedraw("drawing buffer aspect changed"),this.animationProps.width=e,this.animationProps.height=t,this.animationProps.aspect=n,this.animationProps.needsRedraw=this.needsRedraw,this.animationProps.engineTime=Date.now()-this.animationProps.startTime,this.timeline&&this.timeline.update(this.animationProps.engineTime),this.animationProps.tick=Math.floor(this.animationProps.time/1e3*60),this.animationProps.tock++,this.animationProps.time=this.timeline?this.timeline.getTime():this.animationProps.engineTime}async _initDevice(){if(this.device=await this.props.device,!this.device)throw new Error("No device provided");this.canvas=this.device.canvasContext?.canvas||null}_createInfoDiv(){if(this.canvas&&this.props.onAddHTML){const e=document.createElement("div");document.body.appendChild(e),e.style.position="relative";const t=document.createElement("div");t.style.position="absolute",t.style.left="10px",t.style.bottom="10px",t.style.width="300px",t.style.background="white",this.canvas instanceof HTMLCanvasElement&&e.appendChild(this.canvas),e.appendChild(t);const n=this.props.onAddHTML(t);n&&(t.innerHTML=n)}}_getSizeAndAspect(){if(!this.device)return{width:1,height:1,aspect:1};const[e,t]=this.device?.canvasContext?.getPixelSize()||[1,1];let n=1;const i=this.device?.canvasContext?.canvas;return i&&i.clientHeight?n=i.clientWidth/i.clientHeight:e>0&&t>0&&(n=e/t),{width:e,height:t,aspect:n}}_resizeViewport(){this.props.autoResizeViewport&&this.device.gl&&this.device.gl.viewport(0,0,this.device.gl.drawingBufferWidth,this.device.gl.drawingBufferHeight)}_resizeCanvasDrawingBuffer(){this.props.autoResizeDrawingBuffer&&this.device?.canvasContext?.resize({useDevicePixels:this.props.useDevicePixels})}_beginFrameTimers(){this.frameRate.timeEnd(),this.frameRate.timeStart(),this.cpuTime.timeStart()}_endFrameTimers(){this.cpuTime.timeEnd()}_startEventHandling(){this.canvas&&(this.canvas.addEventListener("mousemove",this._onMousemove.bind(this)),this.canvas.addEventListener("mouseleave",this._onMouseleave.bind(this)))}_onMousemove(e){e instanceof MouseEvent&&(this._getAnimationProps()._mousePosition=[e.offsetX,e.offsetY])}_onMouseleave(e){this._getAnimationProps()._mousePosition=null}}var hi=n(147);"undefined"!=typeof window&&(window.website=!0);const pi=e=>{let t="ssr";const[n,r]=(0,i.useState)(null),o=(0,i.useRef)(new WeakMap),s=(0,i.useRef)(null),a=jn((e=>e.deviceType));return t=e.container||`luma-example-container-${a}`,(0,i.useEffect)((()=>{if(!n||o.current.get(n))return;o.current.set(n,!0);let i=null,r=null;const l=async()=>{n.style.width="100%",n.style.height="100%",r=await x.createDevice({adapters:[un,Yn],type:a,createCanvasContext:{canvas:n,container:t}}),i=function(e,t){let n=null;const i=t?.device||x.createDevice({id:"animation-loop",adapters:t?.adapters,createCanvasContext:!0}),r=new _i({...t,device:i,onInitialize:async t=>(n=new e(t),await(n?.onInitialize(t))),onRender:e=>n?.onRender(e),onFinalize:e=>n?.onFinalize(e)});return r.getInfo=()=>this.AnimationLoopTemplateCtor.info,r}(e.template,{device:r,autoResizeViewport:!0,autoResizeDrawingBuffer:!0}),i?.start();const o="https://raw.githubusercontent.com/visgl/luma.gl/master";e.directory?(0,hi.Qj)(`${o}/examples/${e.directory}/${e.id}/`):(0,hi.Qj)(`${o}/website/static/images/`)};return s.current=Promise.resolve(s.current).then((()=>{l().catch((e=>{console.error(`start ${a} failed`,e)}))})),()=>{s.current=Promise.resolve(s.current).then((()=>{i&&(i.destroy(),i=null),r&&r.destroy()})).catch((e=>{console.error(`unmounting ${a} failed`,e)}))}}),[a,n]),i.createElement("canvas",{key:a,ref:r})}},959:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>l,default:()=>_,frontMatter:()=>a,metadata:()=>c,toc:()=>d});var i=n(4848),r=n(8453),o=n(5783),s=n(6041);const a={},l="Shader Modules",c={id:"tutorials/shader-modules",title:"Shader Modules",description:"This tutorial will demonstrate how to use luma.gl shader modules to make",source:"@site/../docs/tutorials/shader-modules.mdx",sourceDirName:"tutorials",slug:"/tutorials/shader-modules",permalink:"/docs/tutorials/shader-modules",draft:!1,unlisted:!1,editUrl:"https://github.com/visgl/luma.gl/tree/main/docs/../docs/tutorials/shader-modules.mdx",tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Hello Instancing",permalink:"/docs/tutorials/hello-instancing"},next:{title:"Shader Hooks",permalink:"/docs/tutorials/shader-hooks"}},u={},d=[];function f(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"shader-modules",children:"Shader Modules"}),"\n",(0,i.jsx)(t.p,{children:"This tutorial will demonstrate how to use luma.gl shader modules to make\nreusable bits of functionality and dynamically insert them into your shaders."}),"\n",(0,i.jsx)(t.admonition,{type:"caution",children:(0,i.jsx)(t.p,{children:"The tutorial pages have not yet been updated for luma.gl v9."})}),"\n",(0,i.jsx)(o.xN,{devices:["webgl2"]}),"\n",(0,i.jsx)(s.ZM,{}),"\n",(0,i.jsx)(t.p,{children:"We'll start by setting up our imports and defining our base vertex and fragment shaders:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"import {AnimationLoop, Model} from '@luma.gl/engine';\n\nconst vs1 = `\n  attribute vec2 position;\n\n  void main() {\n    gl_Position = vec4(position - vec2(0.5, 0.0), 0.0, 1.0);\n  }\n`;\n\nconst fs1 = `\n  uniform vec3 hsvColor;\n\n  void main() {\n    gl_FragColor = vec4(color_hsv2rgb(hsvColor), 1.0);\n  }\n`;\n\nconst vs2 = `\n  attribute vec2 position;\n\n  void main() {\n    gl_Position = vec4(position + vec2(0.5, 0.0), 0.0, 1.0);\n  }\n`;\n\nconst fs2 = `\n  uniform vec3 hsvColor;\n\n  void main() {\n    gl_FragColor = vec4(color_hsv2rgb(hsvColor) - 0.3, 1.0);\n  }\n`;\n"})}),"\n",(0,i.jsxs)(t.p,{children:["We have two vertex and fragment shader pairs: one will move vertices to the left, the other moves vertices to the right. Both fragment shaders take an ",(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/HSL_and_HSV",children:"HSV color"})," as input call a ",(0,i.jsx)(t.code,{children:"color_hsv2rgb"})," to convert it to RGB. But ",(0,i.jsx)(t.code,{children:"color_hsv2rgb"})," isn't defined anywhere, so these shaders will not compile as-is."]}),"\n",(0,i.jsxs)(t.p,{children:["We define ",(0,i.jsx)(t.code,{children:"color_hsv2rgb"})," in a shader module:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"// Taken from http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nconst colorModule = {\n  name: 'color',\n  fs: `\n    vec3 color_hsv2rgb(vec3 c) {\n      vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n      vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n      vec3 rgb = c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n      return rgb;\n    }\n  `\n};\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Shader modules are simply JavaScript objects that contain at least a name and some shader code. They can be defined to inject code into the vertex shader, the fragment shader or both. Our ",(0,i.jsx)(t.code,{children:"colorModule"})," defines the ",(0,i.jsx)(t.code,{children:"color_hsv2rgb"})," function used by our fragment shaders. It converts the HSV value to RGB and returns it. We're applying a shader module best practice of prefixing our function with the module name (",(0,i.jsx)(t.code,{children:"color_"}),") to avoid name collisions."]}),"\n",(0,i.jsxs)(t.p,{children:["In the ",(0,i.jsx)(t.code,{children:"onInitialize"})," method of our ",(0,i.jsx)(t.code,{children:"AnimationLoop"}),", we create two models with different vertex and fragment shader sources, but both including the our ",(0,i.jsx)(t.code,{children:"colorModule"}),"."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"  override onInitialize({device}) {\n    const positionBuffer = new Buffer(device, new Float32Array([\n      -0.3, -0.5,\n      0.3, -0.5,\n      0.0, 0.5\n    ]));\n\n    const model1 = new Model(device, {\n      vs: vs1,\n      fs: fs1,\n      modules: [colorModule],\n      attributes: {\n        position: positionBuffer\n      },\n      uniforms: {\n        hsvColor: [0.7, 1.0, 1.0]\n      },\n      vertexCount: 3\n    });\n\n    const model2 = new Model(device, {\n      vs: vs2,\n      fs: fs2,\n      modules: [colorModule],\n      attributes: {\n        position: positionBuffer\n      },\n      uniforms: {\n        hsvColor: [1.0, 1.0, 1.0]\n      },\n      vertexCount: 3\n    });\n\n    return {model1, model2};\n  }\n"})}),"\n",(0,i.jsxs)(t.p,{children:["In ",(0,i.jsx)(t.code,{children:"onRender"}),", we simply draw both models:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"  override onRender({device, model1, model2}) {\n    clear(device, {color: [0, 0, 0, 1]});\n    model1.draw();\n    model2.draw();\n  }\n"})}),"\n",(0,i.jsx)(t.p,{children:"If all went well, a blue trangle and a red triangle should be drawn side-by-side on the canvas."}),"\n",(0,i.jsx)(t.p,{children:"Shader modules allowed us to define our HSL to RGB conversion function once and use it across multiple programs."}),"\n",(0,i.jsx)(t.p,{children:"The entire application should look like the following:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"import {AnimationLoop, Model} from '@luma.gl/engine';\nimport {clear} from '@luma.gl/webgl';\n\nconst vs1 = `\n  attribute vec2 position;\n\n  void main() {\n    gl_Position = vec4(position - vec2(0.5, 0.0), 0.0, 1.0);\n  }\n`;\n\nconst fs1 = `\n  void main() {\n    gl_FragColor = color_getColor();\n  }\n`;\n\nconst vs2 = `\n  attribute vec2 position;\n\n  void main() {\n    gl_Position = vec4(position + vec2(0.5, 0.0), 0.0, 1.0);\n  }\n`;\n\nconst fs2 = `\n  void main() {\n    gl_FragColor = color_getColor() - 0.3;\n  }\n`;\n\n// Taken from http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nconst colorModule = {\n  name: 'color',\n  fs: `\n    vec3 color_hsv2rgb(vec3 c) {\n      vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n      vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n      return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n    }\n  `\n};\n\nconst loop = new AnimationLoop({\n  override onInitialize({device}) {\n    const positionBuffer = new Buffer(device, new Float32Array([-0.3, -0.5, 0.3, -0.5, 0.0, 0.5]));\n\n    const model1 = new Model(device, {\n      vs: vs1,\n      fs: fs1,\n      modules: [colorModule],\n      attributes: {\n        position: positionBuffer\n      },\n      vertexCount: 3\n    });\n\n    const model2 = new Model(device, {\n      vs: vs2,\n      fs: fs2,\n      modules: [colorModule],\n      attributes: {\n        position: positionBuffer\n      },\n      vertexCount: 3\n    });\n\n    return {model1, model2};\n  },\n\n  override onRender({device, model}) {\n    clear(device, {color: [0, 0, 0, 1]});\n    model1.draw();\n    model2.draw();\n  }\n});\n\nloop.start();\n"})})]})}function _(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(f,{...e})}):f(e)}},1020:(e,t,n)=>{var i=n(6540),r=Symbol.for("react.element"),o=Symbol.for("react.fragment"),s=Object.prototype.hasOwnProperty,a=i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,l={key:!0,ref:!0,__self:!0,__source:!0};function c(e,t,n){var i,o={},c=null,u=null;for(i in void 0!==n&&(c=""+n),void 0!==t.key&&(c=""+t.key),void 0!==t.ref&&(u=t.ref),t)s.call(t,i)&&!l.hasOwnProperty(i)&&(o[i]=t[i]);if(e&&e.defaultProps)for(i in t=e.defaultProps)void 0===o[i]&&(o[i]=t[i]);return{$$typeof:r,type:e,key:c,ref:u,props:o,_owner:a.current}}t.Fragment=o,t.jsx=c,t.jsxs=c},4848:(e,t,n)=>{e.exports=n(1020)},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>a});var i=n(6540);const r={},o=i.createContext(r);function s(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);